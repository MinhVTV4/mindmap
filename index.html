<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sơ đồ tư duy MVP - Firebase AI</title>
    <script src="https://unpkg.com/konva@9.3.6/konva.min.js"></script>
    <style>
        html, body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
            color: #1c1e21;
            height: 100%;
            overflow: hidden;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #app-root {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        .container {
            width: 100%;
            padding: 0;
            background-color: #fff;
            box-shadow: none;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        #auth-section {
            padding: 20px;
            max-width: 450px;
            margin: auto;
            flex-grow: 0;
        }
        .form-container {
            max-width: 400px;
            margin: 20px auto;
            padding: 20px;
            border: 1px solid #dddfe2;
            border-radius: 8px;
        }
        .form-container h3 {
            text-align: center;
            color: #1877f2;
            margin-bottom: 20px;
        }
        input[type="email"], input[type="password"], input[type="text"] {
            width: calc(100% - 22px);
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #dddfe2;
            border-radius: 6px;
            font-size: 16px;
        }
        input[type="number"] {
            width: 50px;
            padding: 6px;
            margin-left: 3px;
            margin-right: 10px;
            border: 1px solid #dddfe2;
            border-radius: 4px;
            font-size: 13px;
            text-align: center;
        }
        select {
            padding: 6px;
            margin-left: 3px;
            margin-right: 10px;
            border: 1px solid #dddfe2;
            border-radius: 4px;
            font-size: 13px;
            background-color: white;
        }
        button {
            padding: 8px 12px;
            font-size: 14px;
            font-weight: bold;
            background-color: #1877f2;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 6px;
            transition: background-color 0.3s;
        }
        button:hover { background-color: #166fe5; }
        button.secondary { background-color: #e4e6eb; color: #4b4f56; }
        button.secondary:hover { background-color: #ccd0d5; }
        button.danger { background-color: #fa3e3e; }
        button.danger:hover { background-color: #e03030; }
        .auth-toggle { text-align: center; margin-top: 15px; }
        .auth-toggle a { color: #1877f2; text-decoration: none; font-weight: bold; }
        .auth-toggle a:hover { text-decoration: underline; }
        .error-message { color: #fa3e3e; font-size: 0.9em; margin-bottom: 10px; text-align: center; }
        #main-app-section { display: flex; flex-direction: column; height: 100%; padding: 8px; box-sizing: border-box; }
        header { display: flex; justify-content: space-between; align-items: center; padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid #dddfe2; flex-shrink: 0; }
        header h1 { color: #1c1e21; font-size: 18px; margin: 0; }
        #user-info span { margin-right: 8px; font-size: 0.85em; }
        #mindmap-management-view { display: flex; flex-direction: column; }
        #mindmap-management, #canvas-view { margin-bottom: 8px; }
        #mindmap-list-container{ flex-grow: 1; overflow-y: auto; }
        #mindmap-list { list-style: none; padding: 0; }
        #mindmap-list li { padding: 8px; border: 1px solid #dddfe2; margin-bottom: 4px; cursor: pointer; border-radius: 6px; display: flex; justify-content: space-between; align-items: center; transition: background-color 0.2s; }
        #mindmap-list li:hover { background-color: #f0f2f5; }
        #canvas-view { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }
        #canvas-toolbar { display: flex; align-items: center; flex-wrap: wrap; padding: 6px 5px; margin-bottom: 5px; border-bottom: 1px solid #ccd0d5; flex-shrink: 0; }
        #canvas-toolbar .toolbar-section { display: flex; align-items: center; margin-right: 15px; margin-bottom: 5px; }
        #canvas-toolbar .toolbar-section:last-child { margin-right: 0; }
        #canvas-toolbar h2 { margin: 0 10px 0 0; font-size: 16px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 150px; }
        #back-to-maps-list-button { padding: 6px 8px; font-size: 18px; line-height: 1; }
        #konva-container { width: 100%; flex-grow: 1; background-color: #f7f7f7; border: 1px solid #ccd0d5; border-radius: 6px; position: relative; overflow: hidden; }
        .hidden { display: none !important; }
        .loading-indicator { text-align: center; padding: 20px; font-style: italic; color: #555; }
        #ai-loading-indicator { position: fixed; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); color: white; display: flex; justify-content: center; align-items: center; z-index: 2000; font-size: 1.2em; text-shadow: 1px 1px 2px black; }
        #node-style-panel { padding: 5px; background-color: #f9f9f9; border: 1px solid #e0e0e0; border-radius: 4px; box-sizing: border-box; display: flex; align-items: center; flex-wrap: wrap; }
        #node-style-panel h5 { margin: 0 5px 0 0; font-size: 0.85em; color: #606770; white-space: nowrap; }
        #node-style-panel label { margin-right: 2px; font-size: 0.8em; vertical-align: middle; white-space: nowrap; }
        #node-style-panel input[type="color"] { width: 22px; height: 22px; padding: 0; border: 1px solid #ccc; border-radius: 3px; vertical-align: middle; margin-right: 5px; }
        #node-style-panel input[type="number"], #node-style-panel select { width: auto; min-width: 60px; padding: 4px; font-size: 0.8em; }
        .style-group { margin-bottom: 0; display: flex; align-items: center; margin-right: 8px; }
        .style-group:last-child { margin-right: 0; }
        #context-menu { position: absolute; z-index: 1000; background-color: white; border: 1px solid #ccc; box-shadow: 2px 2px 5px rgba(0,0,0,0.2); border-radius: 4px; padding: 5px 0; }
        #context-menu ul { list-style: none; padding: 0; margin: 0; }
        #context-menu li { padding: 8px 15px; cursor: pointer; font-size: 0.9em; }
        #context-menu li:hover { background-color: #f0f0f0; }

        /* Modal Styles (Chung cho AI Response, Node Content, và Edit Node Text) */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 1001; padding: 15px; box-sizing: border-box;}
        .modal-content { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); width: 90%; max-width: 650px; max-height: 85vh; display: flex; flex-direction: column; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee; }
        .modal-header h4 { margin: 0; font-size: 1.2em; color: #333; }
        .modal-close-button { background: none; border: none; font-size: 1.6em; cursor: pointer; color: #777; line-height: 1; padding: 0 5px;}
        .modal-close-button:hover { color: #000; }
        .modal-body { overflow-y: auto; line-height: 1.6; font-size: 0.95em; }
        .modal-body p { margin-top:0; margin-bottom: 1em; }
        .modal-body strong { color: #1877f2; }
        .modal-body pre, .modal-body div[contenteditable="false"] {
            background-color: #f8f9fa;
            padding: 12px;
            border-radius: 5px;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 0.9em;
            border: 1px solid #e9ecef;
            max-height: 50vh;
            overflow-y: auto;
        }
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            padding-top: 15px;
            margin-top: 15px;
            border-top: 1px solid #eee;
        }
        .modal-footer button {
            margin-left: 8px;
        }
        .read-more-indicator {
            fill: #007bff;
            cursor: pointer;
            opacity: 0.7;
        }
        .read-more-indicator:hover {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="app-root">
        <section id="auth-section" class="container">
            <div id="login-form" class="form-container">
                <h3>Đăng nhập Sơ đồ tư duy</h3>
                <p id="login-error" class="error-message hidden"></p>
                <input type="email" id="login-email" placeholder="Email" required>
                <input type="password" id="login-password" placeholder="Mật khẩu" required>
                <button id="login-button">Đăng nhập</button>
                <p class="auth-toggle">Chưa có tài khoản? <a href="#" id="show-register-link">Đăng ký ngay</a></p>
            </div>
            <div id="register-form" class="form-container hidden">
                <h3>Đăng ký tài khoản</h3>
                <p id="register-error" class="error-message hidden"></p>
                <input type="email" id="register-email" placeholder="Email" required>
                <input type="password" id="register-password" placeholder="Mật khẩu (ít nhất 6 ký tự)" required>
                <button id="register-button">Đăng ký</button>
                <p class="auth-toggle">Đã có tài khoản? <a href="#" id="show-login-link">Đăng nhập</a></p>
            </div>
        </section>

        <section id="main-app-section" class="container hidden">
            <header>
                <h1 id="main-app-title">Bảng điều khiển</h1>
                <div id="user-info">
                    <span id="user-email-display"></span>
                    <button id="logout-button" class="secondary">Đăng xuất</button>
                </div>
            </header>

            <div id="mindmap-management-view">
                <h2>Quản lý Sơ đồ tư duy</h2>
                <div style="margin-bottom: 15px;">
                    <input type="text" id="new-mindmap-title-input" placeholder="Nhập tiêu đề sơ đồ mới...">
                    <button id="create-mindmap-button">Tạo Sơ đồ mới</button>
                </div>
                <div id="mindmap-list-container">
                    <h3>Danh sách sơ đồ của bạn:</h3>
                    <div id="mindmap-list-loading" class="loading-indicator hidden">Đang tải danh sách...</div>
                    <ul id="mindmap-list"></ul>
                </div>
            </div>

            <div id="canvas-view" class="hidden">
                <div id="canvas-toolbar">
                    <div class="toolbar-section">
                        <button id="back-to-maps-list-button" class="secondary" title="Quay lại danh sách">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-left-short" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M12 8a.5.5 0 0 1-.5.5H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H11.5a.5.5 0 0 1 .5.5z"/>
                            </svg>
                        </button>
                        <h2 id="current-mindmap-title-display"></h2>
                    </div>
                    <div class="toolbar-section">
                        <button id="add-child-node-button" title="Thêm nút con (Click)">Thêm Nút</button>
                        <button id="delete-node-button" class="danger" title="Xóa nút đã chọn (Delete/Backspace)">Xóa Nút</button>
                    </div>
                    <div class="toolbar-section">
                        <span style="font-size:0.9em; margin-right: 3px;">Zoom:</span>
                        <button id="zoom-in-button" class="secondary" title="Phóng to">+</button>
                        <button id="zoom-out-button" class="secondary" title="Thu nhỏ">-</button>
                        <button id="reset-zoom-button" class="secondary" title="Reset zoom">Reset</button>
                    </div>
                     <div id="node-style-panel" class="toolbar-section hidden">
                        <div class="style-group">
                            <label for="node-shape-select">Hình dạng:</label>
                            <select id="node-shape-select" title="Hình dạng nút">
                                <option value="rectangle">Chữ nhật</option>
                                <option value="ellipse">Elip</option>
                                <option value="roundedRectangle">Bo góc</option>
                            </select>
                        </div>
                         <div class="style-group">
                            <label for="node-font-family-select">Font:</label>
                            <select id="node-font-family-select" title="Font chữ nút">
                                <option value="Arial">Arial</option>
                                <option value="Verdana">Verdana</option>
                                <option value="Tahoma">Tahoma</option>
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Courier New">Courier New</option>
                            </select>
                        </div>
                        <div class="style-group">
                            <label for="node-font-size-input">Cỡ:</label>
                            <input type="number" id="node-font-size-input" min="8" max="72" title="Cỡ chữ nút">
                        </div>
                        <div class="style-group">
                            <label for="node-icon-select">Icon:</label>
                            <select id="node-icon-select" title="Biểu tượng nút">
                                <option value="">Không có</option>
                                <option value="⭐">⭐ Ngôi sao</option>
                                <option value="💡">💡 Bóng đèn</option>
                                <option value="✔️">✔️ Check</option>
                                <option value="❗">❗ Chú ý</option>
                                <option value="❓">❓ Hỏi</option>
                            </select>
                        </div>
                        <div class="style-group">
                            <label for="node-bg-color">Nền:</label>
                            <input type="color" id="node-bg-color" title="Màu nền nút">
                        </div>
                        <div class="style-group">
                            <label for="node-text-color">Chữ:</label>
                            <input type="color" id="node-text-color" title="Màu chữ nút">
                        </div>
                        <div class="style-group">
                             <label for="node-border-color">Viền:</label>
                            <input type="color" id="node-border-color" title="Màu viền nút">
                        </div>
                        <div class="style-group">
                            <label for="node-line-color">Màu đường:</label>
                            <input type="color" id="node-line-color" title="Màu đường nối từ nút này">
                        </div>
                         <div class="style-group">
                            <label for="node-line-dash-select">Kiểu đường:</label>
                            <select id="node-line-dash-select" title="Kiểu đường nối từ nút này">
                                <option value="solid">Liền</option>
                                <option value="dashed">Đứt</option>
                                <option value="dotted">Chấm</option>
                            </select>
                        </div>
                        <div class="style-group">
                            <label for="node-line-width">Dày:</label>
                            <input type="number" id="node-line-width" min="1" max="10" title="Độ dày đường nối từ nút này">
                        </div>
                    </div>
                </div>
                <div id="konva-container-loading" class="loading-indicator hidden">Đang tải sơ đồ...</div>
                <div id="konva-container"></div>
            </div>
        </section>

        <div id="context-menu" class="hidden">
            <ul>
                <li id="ctx-add-child">Thêm nút con (Tab)</li>
                <li id="ctx-edit-text">Sửa văn bản (Enter)</li>
                <li id="ctx-view-full-content">📄 Xem toàn bộ nội dung</li>
                <li id="ctx-suggest-children">✨ Gợi ý nút con (AI)</li>
                <li id="ctx-expand-node">🔍 Mở rộng ý tưởng (AI)</li>
                <li id="ctx-generate-examples">💡 AI Tạo Ví Dụ</li>
                <li id="ctx-ask-ai-node">💬 Hỏi AI về nút này...</li>
                <li id="ctx-summarize-branch">📄 AI Tóm tắt nhánh này</li>
                <li id="ctx-generate-action-plan">🚀 AI Tạo Kế hoạch Hành động</li>
                <li id="ctx-delete-node">Xóa nút & con (Delete)</li>
            </ul>
        </div>

        <div id="ai-loading-indicator" class="hidden">Đang xử lý AI...</div>

        <div id="ai-response-modal-overlay" class="modal-overlay hidden">
            <div class="modal-content">
                <div class="modal-header">
                    <h4 id="ai-response-modal-title">Phản hồi từ AI</h4>
                    <button id="ai-response-modal-close-button" class="modal-close-button">&times;</button>
                </div>
                <div class="modal-body" id="ai-response-modal-body"></div>
            </div>
        </div>

        <div id="node-content-modal-overlay" class="modal-overlay hidden">
            <div class="modal-content">
                <div class="modal-header">
                    <h4 id="node-content-modal-title">Nội dung đầy đủ của nút</h4>
                    <button id="node-content-modal-close-button" class="modal-close-button">&times;</button>
                </div>
                <div class="modal-body" id="node-content-modal-body">
                    </div>
            </div>
        </div>

        <div id="edit-node-text-modal-overlay" class="modal-overlay hidden">
            <div class="modal-content">
                <div class="modal-header">
                    <h4 id="edit-node-text-modal-title">Sửa nội dung nút</h4>
                    <button id="edit-node-text-modal-close-button" class="modal-close-button">&times;</button>
                </div>
                <div class="modal-body">
                    <textarea id="edit-node-textarea" style="width: 100%; min-height: 150px; box-sizing: border-box; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 1em; line-height: 1.5;" placeholder="Nhập nội dung cho nút..."></textarea>
                </div>
                <div class="modal-footer">
                    <button id="edit-node-text-modal-cancel-button" class="secondary">Hủy</button>
                    <button id="edit-node-text-modal-save-button">Lưu thay đổi</button>
                </div>
            </div>
        </div>

    </div>

    <script type="module">
        // --- FIREBASE SDK IMPORTS ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-app.js";
        import {
            getAuth,
            createUserWithEmailAndPassword,
            signInWithEmailAndPassword,
            signOut,
            onAuthStateChanged
        } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-auth.js";
        import {
            getFirestore,
            collection,
            addDoc,
            doc,
            getDoc,
            getDocs,
            updateDoc,
            deleteDoc,
            query,
            where,
            serverTimestamp,
            onSnapshot,
            writeBatch
        } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-firestore.js";
        import { getAI, getGenerativeModel, GoogleAIBackend } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-ai.js";


        // --- FIREBASE CONFIGURATION (Sử dụng giá trị từ file gốc của bạn) ---
        const firebaseConfig = {
            apiKey: "AIzaSyDLVuv2RGAJWUjhan-5oNCkGBwQZAN60aY",
            authDomain: "vocab-91599.firebaseapp.com",
            projectId: "vocab-91599",
            storageBucket: "vocab-91599.appspot.com",
            messagingSenderId: "918212044361",
            appId: "1:918212044361:web:50b7a065fe0b22b1924198"
        };

        // --- MODULE-SCOPED VARIABLES (Firebase, State, etc.) ---
        let app;
        let auth;
        let db;
        let ai;
        let generativeModel;

        let currentUser = null;
        let currentMindMapId = null;
        let currentKonvaStage = null;
        let currentKonvaLayer = null;
        let selectedKonvaNode = null;
        let mindmapNodesUnsubscribe = null;
        let allNodesDataForCurrentMap = [];
        let mindmapDataUnsubscribe = null;
        let tempCreationLine = null;
        let rightClickedKonvaNode = null;
        let isEditingText = false; // Used for modal editing state as well
        let editingNodeIdForModal = null; // Stores ID of node being edited in modal

        const DEFAULT_NODE_STYLE = {
            backgroundColor: "#e0e0e0", textColor: "#000000", borderColor: "#555555",
            shape: "rectangle",
            width: 150, minHeight: 50, padding: 10,
            cornerRadius: 5,
            fontSize: 14, fontFamily: 'Arial',
            icon: '',
            iconSize: 16,
            iconSpacing: 5,
            lineColor: "#888888", lineWidth: 3, lineDash: []
        };
        const MAX_DISPLAY_LINES_IN_NODE = 4;
        let contextMenuJustOpened = false;

        let potentiallyDraggedNode = null;
        let dragStartPointerPosition = null;
        const DRAG_THRESHOLD = 10;

        let longPressTimeoutId = null;
        let touchStartTargetNodeForContextMenu = null;
        let touchStartPointerPositionForContextMenu = null;
        const LONG_PRESS_DELAY = 750;
        const LONG_PRESS_MOVE_THRESHOLD = 10;
        let touchStartCoordsForLongPress = { x: 0, y: 0 };

        const HANDLE_RADIUS = 8;
        const HANDLE_FILL = 'rgba(0,180,0,0.7)';
        const HANDLE_STROKE = 'rgba(0,100,0,0.9)';
        const scaleBy = 1.1;


        // --- DOM ELEMENT VARIABLES ---
        let nodeStylePanel, nodeShapeSelect, nodeFontFamilySelect, nodeFontSizeInput, nodeIconSelect, nodeBgColorInput, nodeTextColorInput, nodeBorderColorInput, nodeLineColorInput, nodeLineDashSelect, nodeLineWidthInput;
        let contextMenu, ctxAddChildButton, ctxEditTextButton, ctxViewFullContentButton, ctxSuggestChildrenButton, ctxExpandNodeButton, ctxGenerateExamplesButton, ctxAskAiNodeButton, ctxSummarizeBranchButton, ctxGenerateActionPlanButton, ctxDeleteNodeButton;
        let aiLoadingIndicator, aiResponseModalOverlay, aiResponseModalTitle, aiResponseModalBody, aiResponseModalCloseButton;
        let nodeContentModalOverlay, nodeContentModalTitle, nodeContentModalBody, nodeContentModalCloseButton;
        let editNodeTextModalOverlay, editNodeTextModalTitle, editNodeTextarea, editNodeTextModalSaveButton, editNodeTextModalCancelButton, editNodeTextModalCloseButton; // NEW modal elements
        let authSection, loginForm, registerForm, loginEmailInput, loginPasswordInput, loginButton, showRegisterLink, registerEmailInput, registerPasswordInput, registerButton, showLoginLink, loginErrorMsg, registerErrorMsg;
        let mainAppSection, mainAppTitle, userEmailDisplay, logoutButton;
        let mindmapManagementView, newMindmapTitleInput, createMindmapButton, mindmapListUl, mindmapListLoading;
        let canvasView, backToMapsListButton, currentMindmapTitleDisplay, addChildNodeButton, deleteNodeButton, zoomInButton, zoomOutButton, resetZoomButton, konvaContainer, konvaContainerLoading;


        // --- UTILITY FUNCTIONS ---
        function showElement(el) { if(el) el.classList.remove('hidden'); }
        function hideElement(el) { if(el) el.classList.add('hidden'); }
        function displayAuthError(el, message) { if(el) { el.textContent = message; showElement(el); } }
        function clearAuthError(el) { if(el) { el.textContent = ''; hideElement(el); } }
        function showLoadingIndicator(message) { if (aiLoadingIndicator) { aiLoadingIndicator.textContent = message || "Đang xử lý AI..."; showElement(aiLoadingIndicator); } }
        function hideLoadingIndicator() { if (aiLoadingIndicator) { hideElement(aiLoadingIndicator); } }
        function hideContextMenu() { if(contextMenu) hideElement(contextMenu); contextMenuJustOpened = false; }

        function openAiResponseModal(title, userQuestion, aiAnswer) {
            if (aiResponseModalOverlay && aiResponseModalTitle && aiResponseModalBody) {
                aiResponseModalTitle.textContent = title || "Phản hồi từ AI";
                let contentHTML = '';
                if (userQuestion) {
                    const sanitizedUserQuestion = userQuestion.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    contentHTML += `<p><strong>Đầu vào cho AI (có thể đã được rút gọn):</strong></p><pre style="max-height: 150px; overflow-y: auto; background-color: #efefef; padding: 5px; border-radius: 3px; white-space: pre-wrap; word-wrap: break-word;">${sanitizedUserQuestion}</pre>`;
                }
                const formattedAiAnswer = aiAnswer.replace(/\n/g, '<br>');
                contentHTML += `<p><strong>AI trả lời:</strong></p><div style="background-color: #f9f9f9; padding: 10px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; font-size: 0.9em;">${formattedAiAnswer}</div>`;
                aiResponseModalBody.innerHTML = contentHTML;
                showElement(aiResponseModalOverlay);
                if (currentKonvaStage && currentKonvaStage.listening()) { currentKonvaStage.listening(false); }
            }
        }
        function closeAiResponseModal() {
            if (aiResponseModalOverlay) { hideElement(aiResponseModalOverlay); }
            if (currentKonvaStage && !currentKonvaStage.listening()) { currentKonvaStage.listening(true); }
        }
        function openNodeContentModal(nodeTitle, fullContent) {
            if (nodeContentModalOverlay && nodeContentModalTitle && nodeContentModalBody) {
                nodeContentModalTitle.textContent = `Nội dung: ${nodeTitle.substring(0, 30)}${nodeTitle.length > 30 ? '...' : ''}`;
                const formattedContent = fullContent.replace(/\n/g, '<br>');
                nodeContentModalBody.innerHTML = `<div contenteditable="false" style="white-space: pre-wrap;">${formattedContent}</div>`;
                showElement(nodeContentModalOverlay);
                if (currentKonvaStage && currentKonvaStage.listening()) { currentKonvaStage.listening(false); }
            }
        }
        function closeNodeContentModal() {
            if (nodeContentModalOverlay) { hideElement(nodeContentModalOverlay); }
            if (currentKonvaStage && !currentKonvaStage.listening()) { currentKonvaStage.listening(true); }
        }

        // --- AUTHENTICATION LOGIC ---
        async function handleRegister() {
            if (!auth) {
                 displayAuthError(registerErrorMsg, "Lỗi: Dịch vụ xác thực chưa sẵn sàng.");
                 return;
            }
            const email = registerEmailInput.value;
            const password = registerPasswordInput.value;
            clearAuthError(registerErrorMsg);
            try {
                await createUserWithEmailAndPassword(auth, email, password);
                // No need to manually call authStateChangedHandler, onAuthStateChanged will handle it
            } catch (error) {
                console.error("Register error:", error);
                displayAuthError(registerErrorMsg, "Lỗi đăng ký: " + error.code + " - " + error.message);
            }
        }
        async function handleLogin() {
            if (!auth) {
                 displayAuthError(loginErrorMsg, "Lỗi: Dịch vụ xác thực chưa sẵn sàng.");
                 return;
            }
            const email = loginEmailInput.value;
            const password = loginPasswordInput.value;
            clearAuthError(loginErrorMsg);
            try {
                await signInWithEmailAndPassword(auth, email, password);
                // No need to manually call authStateChangedHandler, onAuthStateChanged will handle it
            } catch (error) {
                console.error("Login error:", error);
                displayAuthError(loginErrorMsg, "Lỗi đăng nhập: " + error.code + " - " + error.message);
            }
        }
        async function handleLogout() {
            if (!auth) return;
            try {
                await signOut(auth);
                // onAuthStateChanged will handle UI changes
                currentMindMapId = null; // Reset current map ID
                if (mindmapNodesUnsubscribe) mindmapNodesUnsubscribe(); // Unsubscribe from node listeners
                if (mindmapDataUnsubscribe) mindmapDataUnsubscribe(); // Unsubscribe from map data listeners
                window.removeEventListener('keydown', handleGlobalKeyDown); // Remove global key listener
            } catch (error) {
                console.error("Logout error:", error);
            }
        }
        function authStateChangedHandler(user) {
            if (user) {
                currentUser = user;
                if(userEmailDisplay) userEmailDisplay.textContent = `Chào, ${user.email}`;
                hideElement(authSection);
                showElement(mainAppSection);
                showMindmapManagementView(); // Show the list of mind maps
                loadUserMindMaps(); // Load maps for the current user
            } else {
                currentUser = null;
                if(userEmailDisplay) userEmailDisplay.textContent = '';
                showElement(authSection);
                hideElement(mainAppSection);
                hideElement(canvasView); // Hide canvas if logged out
                if(nodeStylePanel) hideElement(nodeStylePanel);
                hideContextMenu();
                if(mindmapListUl) mindmapListUl.innerHTML = ''; // Clear mind map list
                window.removeEventListener('keydown', handleGlobalKeyDown);
            }
        }

        // --- UI VIEW MANAGEMENT ---
        function showMindmapManagementView() {
            if(mainAppTitle) mainAppTitle.textContent = "Bảng điều khiển";
            if(mindmapManagementView) showElement(mindmapManagementView);
            if(canvasView) hideElement(canvasView);
            if(nodeStylePanel) hideElement(nodeStylePanel);
            hideContextMenu();
            currentMindMapId = null;
            selectedKonvaNode = null;
            rightClickedKonvaNode = null;
            if (mindmapNodesUnsubscribe) {
                mindmapNodesUnsubscribe();
                mindmapNodesUnsubscribe = null;
            }
            if (mindmapDataUnsubscribe) {
                mindmapDataUnsubscribe();
                mindmapDataUnsubscribe = null;
            }
            if (currentKonvaStage) {
                currentKonvaStage.destroyChildren(); // Clear canvas
                currentKonvaLayer = null; // Reset layer
            }
            window.removeEventListener('keydown', handleGlobalKeyDown); // Remove key listener for canvas
        }
        async function showCanvasView(mapId, mapTitle) {
            if(mainAppTitle) mainAppTitle.textContent = "Sơ đồ tư duy";
            if(mindmapManagementView) hideElement(mindmapManagementView);
            if(canvasView) showElement(canvasView);
            if(currentMindmapTitleDisplay) currentMindmapTitleDisplay.textContent = mapTitle;
            currentMindMapId = mapId;
            initKonvaStage(); // Initialize Konva for the selected map
            // Listen for canvas state changes (zoom/pan)
            if (db && currentMindMapId) {
                const mapDocRef = doc(db, "mindmaps", currentMindMapId);
                if (mindmapDataUnsubscribe) mindmapDataUnsubscribe(); // Unsubscribe previous listener
                mindmapDataUnsubscribe = onSnapshot(mapDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const mapData = docSnap.data();
                        if (mapData.canvasState && currentKonvaStage) {
                            currentKonvaStage.scaleX(mapData.canvasState.scaleX || 1);
                            currentKonvaStage.scaleY(mapData.canvasState.scaleY || 1);
                            currentKonvaStage.x(mapData.canvasState.x || 0);
                            currentKonvaStage.y(mapData.canvasState.y || 0);
                            currentKonvaStage.batchDraw();
                        }
                    }
                }, (error) => {
                    console.error("Error listening to mindmap data:", error);
                });
            }
            if(nodeStylePanel) hideElement(nodeStylePanel); // Hide style panel initially
            hideContextMenu();
            window.addEventListener('keydown', handleGlobalKeyDown); // Add key listener for canvas
        }

        // --- NODE STYLE PANEL LOGIC ---
        function lineDashArrayToString(dashArray) {
            if (!dashArray || dashArray.length === 0) return 'solid';
            if (JSON.stringify(dashArray) === JSON.stringify([15, 8])) return 'dashed';
            if (JSON.stringify(dashArray) === JSON.stringify([3, 8])) return 'dotted';
            return 'solid'; // Default
        }
        function stringToLineDashArray(dashString) {
            if (dashString === 'dashed') return [15, 8];
            if (dashString === 'dotted') return [3, 8];
            return []; // Solid
        }
        function updateNodeStylePanel(nodeData) {
            if (!nodeData || !nodeData.style) {
                if(nodeStylePanel) hideElement(nodeStylePanel);
                return;
            }
            const style = nodeData.style;
            if(nodeShapeSelect) nodeShapeSelect.value = style.shape || DEFAULT_NODE_STYLE.shape;
            if(nodeFontFamilySelect) nodeFontFamilySelect.value = style.fontFamily || DEFAULT_NODE_STYLE.fontFamily;
            if(nodeFontSizeInput) nodeFontSizeInput.value = style.fontSize || DEFAULT_NODE_STYLE.fontSize;
            if(nodeIconSelect) nodeIconSelect.value = style.icon || '';
            if(nodeBgColorInput) nodeBgColorInput.value = style.backgroundColor || DEFAULT_NODE_STYLE.backgroundColor;
            if(nodeTextColorInput) nodeTextColorInput.value = style.textColor || DEFAULT_NODE_STYLE.textColor;
            if(nodeBorderColorInput) nodeBorderColorInput.value = style.borderColor || DEFAULT_NODE_STYLE.borderColor;
            if(nodeLineColorInput) nodeLineColorInput.value = style.lineColor || DEFAULT_NODE_STYLE.lineColor;
            if(nodeLineDashSelect) nodeLineDashSelect.value = lineDashArrayToString(style.lineDash);
            if(nodeLineWidthInput) nodeLineWidthInput.value = style.lineWidth || DEFAULT_NODE_STYLE.lineWidth;
            if(nodeStylePanel) showElement(nodeStylePanel);
        }
        async function handleNodeStyleChange(property, value) {
            if (!selectedKonvaNode || !db) return;
            const nodeId = selectedKonvaNode.id();
            let processedValue = value;
            if (property === 'lineWidth' || property === 'fontSize') {
                processedValue = parseInt(value, 10);
            } else if (property === 'lineDash') {
                processedValue = stringToLineDashArray(value);
            }
            try {
                const nodeRef = doc(db, "nodes", nodeId);
                const nodeSnap = await getDoc(nodeRef);
                if (nodeSnap.exists()) {
                    const existingData = nodeSnap.data();
                    const existingStyle = existingData.style || {};
                    let updatedStyle = { ...existingStyle, [property]: processedValue };

                    // Adjust cornerRadius based on shape
                    if (property === 'shape') {
                        if (processedValue === 'ellipse') {
                            // Ellipse doesn't use cornerRadius in Konva Rect, it's a separate shape
                        } else if (processedValue === 'rectangle' && !updatedStyle.cornerRadius) {
                            updatedStyle.cornerRadius = 0; // Default for sharp rectangle
                        } else if (processedValue === 'roundedRectangle' && (!updatedStyle.cornerRadius || updatedStyle.cornerRadius === 0) ) {
                            updatedStyle.cornerRadius = 5; // Default for rounded rectangle
                        }
                    }
                    await updateDoc(nodeRef, { style: updatedStyle });
                    // Real-time update will be handled by onSnapshot in renderNodesAndLines
                } else {
                    console.warn("Node not found for style update:", nodeId);
                }
            } catch (e) {
                console.error(`Error updating node style (${property}):`, e);
            }
        }
        function calculatePotentialFullHeight(text, styleConfig) {
            const style = { ...DEFAULT_NODE_STYLE, ...styleConfig };
            const textPadding = style.padding;
            let iconTextWidth = 0;
            if (style.icon && style.icon !== '') {
                const tempIconForCalc = new Konva.Text({ text: style.icon, fontSize: style.iconSize, fontFamily: style.fontFamily });
                iconTextWidth = tempIconForCalc.width() + style.iconSpacing;
            }
            const mainTextWidth = style.width - 2 * textPadding - iconTextWidth;

            // Create a temporary Konva.Text to measure actual height
            const tempText = new Konva.Text({
                text: text,
                fontSize: style.fontSize,
                fontFamily: style.fontFamily,
                width: mainTextWidth > 0 ? mainTextWidth : 0, // Ensure width is not negative
                align: 'center',
                lineHeight: 1.2 // Consistent line height
            });
            const actualTextContentHeight = tempText.height();
            // Ensure minHeight is respected and icon height is considered
            return Math.max(style.minHeight, actualTextContentHeight + 2 * textPadding, style.icon ? (style.iconSize + 2 * textPadding) : 0);
        }

        // --- FIRESTORE SERVICE LOGIC (Mind Maps) ---
        async function handleCreateMindmap() {
            if (!db) { alert("Lỗi: Dịch vụ cơ sở dữ liệu chưa sẵn sàng."); return; }
            const title = newMindmapTitleInput.value.trim();
            if (!title) { alert("Vui lòng nhập tiêu đề cho sơ đồ."); return; }
            if (!currentUser) { alert("Vui lòng đăng nhập để tạo sơ đồ."); return; }

            try {
                const mindMapData = {
                    userId: currentUser.uid,
                    title: title,
                    createdAt: serverTimestamp(),
                    lastModified: serverTimestamp(),
                    canvasState: { scaleX: 1, scaleY: 1, x: 0, y: 0 } // Initial canvas state
                };
                const mindMapDocRef = await addDoc(collection(db, "mindmaps"), mindMapData);

                // Create a default root node for the new mind map
                const rootNodeData = {
                    mapId: mindMapDocRef.id,
                    parentId: null, // Root node has no parent
                    text: "Ý tưởng trung tâm",
                    position: { x: (konvaContainer?.clientWidth || 800) / 2 - 75, y: 50 }, // Centered horizontally, near top
                    style: { ...DEFAULT_NODE_STYLE, backgroundColor: "#1877f2", textColor: "#ffffff", borderColor: "#0e5aab", shape: "ellipse", minHeight: 60 },
                    createdAt: serverTimestamp()
                };
                await addDoc(collection(db, "nodes"), rootNodeData);
                newMindmapTitleInput.value = ''; // Clear input field
            } catch (e) {
                console.error("Error creating new mind map: ", e);
                alert("Lỗi khi tạo sơ đồ: " + e.message);
            }
        }
        async function loadUserMindMaps() {
            if (!currentUser || !db) return;
            if(mindmapListLoading) showElement(mindmapListLoading);
            if(mindmapListUl) mindmapListUl.innerHTML = ''; // Clear previous list

            try {
                const q = query(collection(db, "mindmaps"), where("userId", "==", currentUser.uid));
                // Unsubscribe from any previous listener to prevent duplicates or outdated listeners
                if (typeof window.mindmapsListenerUnsubscribe === 'function') {
                    window.mindmapsListenerUnsubscribe();
                }
                window.mindmapsListenerUnsubscribe = onSnapshot(q, (querySnapshot) => {
                    if(mindmapListUl) mindmapListUl.innerHTML = ''; // Clear list on each update
                    if (querySnapshot.empty) {
                        if(mindmapListUl) mindmapListUl.innerHTML = '<li>Bạn chưa có sơ đồ nào. Hãy tạo một cái mới!</li>';
                    }
                    querySnapshot.forEach((docSnap) => {
                        const map = { id: docSnap.id, ...docSnap.data() };
                        const li = document.createElement('li');
                        li.textContent = map.title;
                        li.dataset.mapId = map.id;
                        li.dataset.mapTitle = map.title; // Store title for easy access

                        const deleteButton = document.createElement('button');
                        deleteButton.textContent = 'Xóa';
                        deleteButton.classList.add('danger', 'secondary'); // Use secondary for less prominent delete
                        deleteButton.style.fontSize = '0.8em';
                        deleteButton.style.padding = '5px 8px';
                        deleteButton.onclick = async (e) => {
                            e.stopPropagation(); // Prevent li click event
                            if (window.confirm(`Bạn có chắc muốn xóa sơ đồ "${map.title}" và tất cả các nút của nó?`)) {
                                await deleteMindMap(map.id);
                            }
                        };
                        li.appendChild(deleteButton);

                        li.addEventListener('click', () => {
                            showCanvasView(map.id, map.title);
                        });
                        if(mindmapListUl) mindmapListUl.appendChild(li);
                    });
                    if(mindmapListLoading) hideElement(mindmapListLoading);
                }, (error) => {
                    console.error("Error fetching user mind maps: ", error);
                    if(mindmapListUl) mindmapListUl.innerHTML = '<li>Lỗi khi tải danh sách sơ đồ.</li>';
                    if(mindmapListLoading) hideElement(mindmapListLoading);
                });
            } catch (e) {
                console.error("Error setting up mind map listener: ", e);
                if(mindmapListUl) mindmapListUl.innerHTML = '<li>Lỗi khi tải danh sách sơ đồ.</li>';
                if(mindmapListLoading) hideElement(mindmapListLoading);
            }
        }
        async function deleteMindMap(mapId) {
            if (!mapId || !db) return;
            try {
                // 1. Delete all nodes associated with this mind map
                const nodesQuery = query(collection(db, "nodes"), where("mapId", "==", mapId));
                const nodesSnapshot = await getDocs(nodesQuery);
                const batch = writeBatch(db);
                nodesSnapshot.forEach(nodeDoc => {
                    batch.delete(doc(db, "nodes", nodeDoc.id));
                });
                await batch.commit();

                // 2. Delete the mind map document itself
                await deleteDoc(doc(db, "mindmaps", mapId));
                // The onSnapshot listener for mind maps will automatically update the list
            } catch (error) {
                console.error("Error deleting mind map: ", error);
                alert("Lỗi khi xóa sơ đồ: " + error.message);
            }
        }

        // --- FIRESTORE SERVICE LOGIC (Nodes) & KONVA INTEGRATION ---
        // START: Pinch to Zoom Helper functions
        function getDistance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }
        function getCenter(p1, p2) {
            return {
                x: (p1.x + p2.x) / 2,
                y: (p1.y + p2.y) / 2,
            };
        }
        let lastCenter = null;
        let lastDist = 0;
        // END: Pinch to Zoom Helper functions

        function initKonvaStage() {
            // Clear previous stage and layer if they exist
            if (currentKonvaStage) {
                currentKonvaStage.off('dragstart dragmove dragend click tap wheel contextmenu touchstart touchend touchmove mousedown mousemove mouseup'); // Remove all event listeners
                currentKonvaStage.destroy();
                currentKonvaStage = null;
            }
            if (currentKonvaLayer) {
                currentKonvaLayer.destroy();
                currentKonvaLayer = null;
            }

            const container = document.getElementById('konva-container');
            if (!container) {
                console.error("Konva container not found!");
                return;
            }

            currentKonvaStage = new Konva.Stage({
                container: 'konva-container',
                width: container.clientWidth,
                height: container.clientHeight,
                draggable: true, // Stage itself is draggable for panning
            });
            currentKonvaLayer = new Konva.Layer();
            currentKonvaStage.add(currentKonvaLayer);
            selectedKonvaNode = null; // Reset selected node

            // Mousedown/Touchstart for pinch-zoom and potential drag start
            currentKonvaStage.on('mousedown touchstart', function(e_stage) {
                let hitShape = e_stage.target;
                let determinedTargetNodeGroup = null;

                // Pinch-to-zoom: Check for two touches
                const touches = e_stage.evt.touches;
                if (touches && touches.length === 2) {
                    e_stage.evt.preventDefault(); // Prevent default browser zoom/scroll
                    currentKonvaStage.draggable(false); // Disable stage dragging during pinch
                    const touch1 = touches[0];
                    const touch2 = touches[1];
                    lastCenter = getCenter({ x: touch1.clientX, y: touch1.clientY }, { x: touch2.clientX, y: touch2.clientY });
                    lastDist = getDistance({ x: touch1.clientX, y: touch1.clientY }, { x: touch2.clientX, y: touch2.clientY });
                    potentiallyDraggedNode = null; // Ensure no node dragging during pinch
                    return; // Stop further processing for mousedown/touchstart if it's a pinch start
                }


                if (hitShape === currentKonvaStage) { // Clicked on empty stage area
                    potentiallyDraggedNode = null;
                    currentKonvaStage.draggable(true); // Ensure stage is draggable
                    clearTimeout(longPressTimeoutId); // Clear any pending long press
                    touchStartTargetNodeForContextMenu = null;
                } else { // Clicked on a shape within the stage
                    // Traverse up to find the 'mindmapNodeGroup'
                    let currentShape = hitShape;
                    while (currentShape && currentShape !== currentKonvaStage) {
                        if (currentShape.hasName && currentShape.hasName('mindmapNodeGroup')) {
                            determinedTargetNodeGroup = currentShape;
                            break;
                        }
                        if (typeof currentShape.getParent !== 'function') { // Safety check
                            determinedTargetNodeGroup = null; break;
                        }
                        currentShape = currentShape.getParent();
                    }

                    if (determinedTargetNodeGroup) { // A mindmap node was hit
                        potentiallyDraggedNode = determinedTargetNodeGroup;
                        dragStartPointerPosition = currentKonvaStage.getPointerPosition();
                        if (currentKonvaStage.isDragging()) currentKonvaStage.stopDrag(); // Stop stage drag if active
                        currentKonvaStage.draggable(false); // Disable stage dragging when a node might be dragged

                        // Long press for context menu on touch devices
                        if (e_stage.type === 'touchstart') {
                            touchStartTargetNodeForContextMenu = determinedTargetNodeGroup;
                            const touch = e_stage.evt.touches && e_stage.evt.touches[0];
                            if (touch) {
                                touchStartCoordsForLongPress = { x: touch.pageX, y: touch.pageY };
                                touchStartPointerPositionForContextMenu = { x: touch.pageX, y: touch.pageY }; // Use pageX/Y for menu position
                            } else { // Fallback if touch object is not available (should not happen for touchstart)
                                const pointerPos = currentKonvaStage.getPointerPosition() || {x:0, y:0};
                                touchStartCoordsForLongPress = pointerPos;
                                touchStartPointerPositionForContextMenu = pointerPos;
                            }

                            clearTimeout(longPressTimeoutId); // Clear previous timeout
                            longPressTimeoutId = setTimeout(() => {
                                if (touchStartTargetNodeForContextMenu) { // If still the same target after delay
                                    rightClickedKonvaNode = touchStartTargetNodeForContextMenu;
                                    // Select the node if not already selected
                                    if (!selectedKonvaNode || selectedKonvaNode.id() !== rightClickedKonvaNode.id()) {
                                        if (selectedKonvaNode) { selectedKonvaNode.findOne('.nodeShape')?.strokeWidth(1); removeCreationHandle(selectedKonvaNode); }
                                        selectedKonvaNode = rightClickedKonvaNode;
                                        selectedKonvaNode.findOne('.nodeShape')?.strokeWidth(3);
                                        const shape = selectedKonvaNode.findOne('.nodeShape');
                                        if (shape) addCreationHandle(selectedKonvaNode, shape.height());
                                        const nodeData = allNodesDataForCurrentMap.find(n => n.id === selectedKonvaNode.id());
                                        if (nodeData) updateNodeStylePanel(nodeData);
                                        currentKonvaLayer.batchDraw();
                                    }
                                    // Show context menu at touch position
                                    if (contextMenu && touchStartPointerPositionForContextMenu) {
                                        contextMenu.style.top = touchStartPointerPositionForContextMenu.y + 'px';
                                        contextMenu.style.left = touchStartPointerPositionForContextMenu.x + 'px';
                                        showElement(contextMenu);
                                        contextMenuJustOpened = true;
                                    }
                                    touchStartTargetNodeForContextMenu = null; // Reset for next long press
                                    longPressTimeoutId = null;
                                }
                            }, LONG_PRESS_DELAY);
                        }
                    } else { // Clicked on something else (e.g., a line, or an unhandled shape)
                        potentiallyDraggedNode = null;
                        currentKonvaStage.draggable(true); // Ensure stage is draggable
                        clearTimeout(longPressTimeoutId);
                        touchStartTargetNodeForContextMenu = null;
                    }
                }
            });

            // Mousemove/Touchmove for pinch-zoom and node dragging
            currentKonvaStage.on('mousemove touchmove', function(e_stage) {
                const touches = e_stage.evt.touches;

                // Pinch-to-zoom logic
                if (touches && touches.length === 2 && lastDist > 0) { // If two touches and pinch has started
                    e_stage.evt.preventDefault();
                    const touch1 = touches[0];
                    const touch2 = touches[1];
                    const newCenter = getCenter({ x: touch1.clientX, y: touch1.clientY }, { x: touch2.clientX, y: touch2.clientY });
                    const newDist = getDistance({ x: touch1.clientX, y: touch1.clientY }, { x: touch2.clientX, y: touch2.clientY });

                    const pointTo = { // Calculate mouse pointer position relative to the stage
                        x: (newCenter.x - currentKonvaStage.x()) / currentKonvaStage.scaleX(),
                        y: (newCenter.y - currentKonvaStage.y()) / currentKonvaStage.scaleX(),
                    };

                    const newScale = currentKonvaStage.scaleX() * (newDist / lastDist); // Calculate new scale

                    currentKonvaStage.scale({ x: newScale, y: newScale });

                    // Calculate new position of the stage
                    const dx = newCenter.x - lastCenter.x;
                    const dy = newCenter.y - lastCenter.y;

                    const newPos = {
                        x: newCenter.x - pointTo.x * newScale + dx,
                        y: newCenter.y - pointTo.y * newScale + dy,
                    };
                    currentKonvaStage.position(newPos);
                    currentKonvaStage.batchDraw();

                    lastDist = newDist;
                    lastCenter = newCenter;
                    return; // Stop further processing for mousemove/touchmove if it's a pinch
                }


                // Cancel long press if finger moves too much
                if (touchStartTargetNodeForContextMenu && e_stage.type === 'touchmove') {
                    const touch = e_stage.evt.touches && e_stage.evt.touches[0];
                    if (touch) {
                        const deltaX = Math.abs(touch.pageX - touchStartCoordsForLongPress.x);
                        const deltaY = Math.abs(touch.pageY - touchStartCoordsForLongPress.y);
                        if (deltaX > LONG_PRESS_MOVE_THRESHOLD || deltaY > LONG_PRESS_MOVE_THRESHOLD) {
                            clearTimeout(longPressTimeoutId); // Cancel long press
                            touchStartTargetNodeForContextMenu = null;
                        }
                    }
                }

                // Node dragging logic
                if (!potentiallyDraggedNode || !dragStartPointerPosition) {
                    return; // Not a drag operation or drag hasn't started
                }
                // For mousemove, ensure primary button is pressed (for desktop)
                if (e_stage.type === 'mousemove' && e_stage.evt.buttons !== 1) {
                    return;
                }
                const currentPointerPosition = currentKonvaStage.getPointerPosition();
                if (!currentPointerPosition) return; // Safety check
                const dx = currentPointerPosition.x - dragStartPointerPosition.x;
                const dy = currentPointerPosition.y - dragStartPointerPosition.y;

                // Only start dragging if moved beyond threshold
                if (Math.sqrt(dx * dx + dy * dy) > DRAG_THRESHOLD) {
                    if (potentiallyDraggedNode.draggable() === false) { // If not already dragging
                        potentiallyDraggedNode.draggable(true); // Make it draggable
                        potentiallyDraggedNode.startDrag(e_stage.evt); // Start Konva drag
                    }
                    clearTimeout(longPressTimeoutId); // Cancel long press if dragging starts
                    touchStartTargetNodeForContextMenu = null;
                }
            });

            // Mouseup/Touchend to reset states
            currentKonvaStage.on('mouseup touchend', function(e_stage) {
                clearTimeout(longPressTimeoutId); // Clear any pending long press
                touchStartTargetNodeForContextMenu = null;
                potentiallyDraggedNode = null; // Reset potentially dragged node
                dragStartPointerPosition = null; // Reset drag start position

                // Reset pinch zoom state
                if (lastDist > 0) { // Was pinching
                    saveCanvasState(); // Save state after pinch zoom ends
                }
                lastDist = 0;
                lastCenter = null;

                currentKonvaStage.draggable(true); // Re-enable stage dragging
            });


            currentKonvaStage.on('dragend', saveCanvasState); // For stage drag
            currentKonvaStage.on('wheel', (e) => { // For mouse wheel zoom
                e.evt.preventDefault();
                const oldScale = currentKonvaStage.scaleX();
                const pointer = currentKonvaStage.getPointerPosition();
                if (!pointer) return; // Safety check

                const mousePointTo = {
                    x: (pointer.x - currentKonvaStage.x()) / oldScale,
                    y: (pointer.y - currentKonvaStage.y()) / oldScale,
                };
                const direction = e.evt.deltaY > 0 ? -1 : 1; // Corrected direction for standard wheel behavior (up = zoom in, down = zoom out)
                let newScale;
                if (direction > 0) { // Zoom in
                     newScale = oldScale * scaleBy;
                } else { // Zoom out
                     newScale = oldScale / scaleBy;
                }

                currentKonvaStage.scale({ x: newScale, y: newScale });
                const newPos = {
                    x: pointer.x - mousePointTo.x * newScale,
                    y: pointer.y - mousePointTo.y * newScale,
                };
                currentKonvaStage.position(newPos);
                currentKonvaStage.batchDraw();
                saveCanvasState(); // Save state after zoom
            });

            currentKonvaStage.on('click tap', function(e) {
                if (e.target === currentKonvaStage) { // Clicked on empty stage area
                    if (selectedKonvaNode) { // Deselect any currently selected node
                        selectedKonvaNode.findOne('.nodeShape')?.strokeWidth(1); // Reset stroke
                        removeCreationHandle(selectedKonvaNode); // Remove creation handle
                        selectedKonvaNode = null;
                        if(nodeStylePanel) hideElement(nodeStylePanel); // Hide style panel
                        currentKonvaLayer.batchDraw();
                    }
                    hideContextMenu(); // Hide context menu if open
                }
                // Node click/tap is handled by the group's event listener
            });

            currentKonvaStage.on('contextmenu', function(e_context) {
                e_context.evt.preventDefault(); // Prevent default browser context menu
                if (e_context.evt.pointerType === 'touch') { // Ignore contextmenu from touch (handled by long press)
                    return;
                }

                let hitShape = e_context.target;
                let targetNodeGroupForContextMenu = null;
                // Traverse up to find the 'mindmapNodeGroup'
                let currentShape = hitShape;
                while (currentShape && currentShape !== currentKonvaStage) {
                    if (currentShape.hasName && currentShape.hasName('mindmapNodeGroup')) {
                        targetNodeGroupForContextMenu = currentShape;
                        break;
                    }
                    if (typeof currentShape.getParent !== 'function') { // Safety check
                        targetNodeGroupForContextMenu = null; break;
                    }
                    currentShape = currentShape.getParent();
                }

                if (targetNodeGroupForContextMenu) { // A mindmap node was right-clicked
                    rightClickedKonvaNode = targetNodeGroupForContextMenu;
                    // Select the node if not already selected
                    if (!selectedKonvaNode || selectedKonvaNode.id() !== rightClickedKonvaNode.id()) {
                        if (selectedKonvaNode) { selectedKonvaNode.findOne('.nodeShape')?.strokeWidth(1); removeCreationHandle(selectedKonvaNode); }
                        selectedKonvaNode = rightClickedKonvaNode;
                        selectedKonvaNode.findOne('.nodeShape')?.strokeWidth(3); // Highlight
                        const shape = selectedKonvaNode.findOne('.nodeShape');
                         if (shape) addCreationHandle(selectedKonvaNode, shape.height()); // Add creation handle
                        const nodeData = allNodesDataForCurrentMap.find(n => n.id === selectedKonvaNode.id());
                        if (nodeData) updateNodeStylePanel(nodeData); // Update style panel
                        currentKonvaLayer.batchDraw();
                    }
                    // Show context menu at mouse position
                    if(contextMenu) {
                        contextMenu.style.top = e_context.evt.pageY + 'px';
                        contextMenu.style.left = e_context.evt.pageX + 'px';
                        showElement(contextMenu);
                        contextMenuJustOpened = true; // Flag to prevent immediate deselection on click
                    }
                } else { // Right-clicked on empty area or non-node element
                    rightClickedKonvaNode = null;
                    hideContextMenu();
                }
            });
            loadAndListenNodesForCurrentMap(); // Load nodes for the current map
        }
        async function saveCanvasState() {
            if (!currentKonvaStage || !currentMindMapId || !db || !currentUser) return;
            try {
                const mapRef = doc(db, "mindmaps", currentMindMapId);
                await updateDoc(mapRef, {
                    "canvasState.scaleX": currentKonvaStage.scaleX(),
                    "canvasState.scaleY": currentKonvaStage.scaleY(),
                    "canvasState.x": currentKonvaStage.x(),
                    "canvasState.y": currentKonvaStage.y(),
                    lastModified: serverTimestamp() // Update last modified timestamp
                });
            } catch (error) {
                console.error("Error saving canvas state:", error);
            }
        }
        function loadAndListenNodesForCurrentMap() {
            if (!currentMindMapId || !currentKonvaLayer || !db) {
                console.warn("Cannot load nodes: Missing mapId, layer, or db connection.");
                return;
            }
            if(konvaContainerLoading) showElement(konvaContainerLoading);
            if(currentKonvaLayer) currentKonvaLayer.destroyChildren(); // Clear previous nodes
            if(currentKonvaLayer) currentKonvaLayer.draw(); // Redraw empty layer
             allNodesDataForCurrentMap = []; // Reset local cache

            const q = query(collection(db, "nodes"), where("mapId", "==", currentMindMapId));
            if (mindmapNodesUnsubscribe) mindmapNodesUnsubscribe(); // Unsubscribe from previous listener

            mindmapNodesUnsubscribe = onSnapshot(q, (querySnapshot) => {
                const nodesFromDb = [];
                querySnapshot.forEach((docSnap) => {
                    nodesFromDb.push({ id: docSnap.id, ...docSnap.data() });
                });
                allNodesDataForCurrentMap = nodesFromDb; // Update local cache
                renderNodesAndLines(allNodesDataForCurrentMap); // Re-render all nodes and lines
                if(konvaContainerLoading) hideElement(konvaContainerLoading);
            }, (error) => {
                console.error(`Error listening to nodes for map ${currentMindMapId}:`, error);
                alert("Lỗi khi tải các nút của sơ đồ: " + error.message);
                if(konvaContainerLoading) hideElement(konvaContainerLoading);
            });
        }

        function renderNodesAndLines(nodesData) {
            if (!currentKonvaLayer) return;
            currentKonvaLayer.destroyChildren(); // Clear existing shapes
            const konvaNodeObjects = {}; // To store Konva group objects for linking

            nodesData.forEach(nodeData => {
                // Basic validation for node data
                if (!nodeData.position || typeof nodeData.position.x !== 'number' || typeof nodeData.position.y !== 'number') {
                    console.warn("Node data missing valid position, skipping:", nodeData);
                    return;
                }

                const style = { ...DEFAULT_NODE_STYLE, ...(nodeData.style || {}) };
                const fullText = nodeData.text || "";

                // Calculate available width for text considering padding and icon
                let iconWidthForCalc = 0;
                if (style.icon && style.icon !== '') {
                    const tempIcon = new Konva.Text({ text: style.icon, fontSize: style.iconSize, fontFamily: style.fontFamily });
                    iconWidthForCalc = tempIcon.width() + style.iconSpacing;
                }
                const textRenderWidth = style.width - (2 * style.padding) - iconWidthForCalc;

                // Determine text display height and if truncation is needed
                const tempTextObj = new Konva.Text({
                    text: fullText,
                    fontSize: style.fontSize,
                    fontFamily: style.fontFamily,
                    width: textRenderWidth > 0 ? textRenderWidth : 0, // Prevent negative width
                    lineHeight: 1.2, // Consistent line height for calculation
                    align: 'center'
                });
                const fullTextActualHeight = tempTextObj.height(); // Actual height of the full text

                const estimatedLineHeight = style.fontSize * 1.2;
                const maxVisibleTextHeightInNode = estimatedLineHeight * MAX_DISPLAY_LINES_IN_NODE;
                const isTextTruncated = fullTextActualHeight > maxVisibleTextHeightInNode;
                const textDisplayHeight = isTextTruncated ? maxVisibleTextHeightInNode : fullTextActualHeight;

                // Calculate shape height based on text, minHeight, and "Read more" indicator
                let shapeRenderHeight = Math.max(style.minHeight, textDisplayHeight + (2 * style.padding));

                if (isTextTruncated) {
                    const readMoreIndicatorHeight = estimatedLineHeight * 0.8; // Approximate height for "Xem thêm"
                    // Ensure shape is tall enough for text + padding + "Read more"
                    shapeRenderHeight = Math.max(shapeRenderHeight, textDisplayHeight + (2 * style.padding) + readMoreIndicatorHeight + style.padding * 0.5);
                }

                // Create Konva Group for the node
                const group = new Konva.Group({
                    x: nodeData.position.x,
                    y: nodeData.position.y,
                    draggable: false, // Will be enabled on drag start after threshold
                    id: nodeData.id,
                    name: 'mindmapNodeGroup',
                    fullTextData: fullText // Store full text in an attribute for easy access
                });

                // Create the main shape (rectangle, ellipse, etc.)
                let shape;
                if (style.shape === 'ellipse') {
                    shape = new Konva.Ellipse({
                        x: style.width / 2, y: shapeRenderHeight / 2, // Center of ellipse
                        radiusX: style.width / 2, radiusY: shapeRenderHeight / 2,
                        fill: style.backgroundColor, stroke: style.borderColor, strokeWidth: 1, name: 'nodeShape'
                    });
                } else if (style.shape === 'roundedRectangle') {
                    shape = new Konva.Rect({
                        width: style.width, height: shapeRenderHeight,
                        fill: style.backgroundColor, stroke: style.borderColor, strokeWidth: 1,
                        cornerRadius: style.cornerRadius || 10, name: 'nodeShape' // Default cornerRadius if not specified
                    });
                } else { // Default to rectangle
                    shape = new Konva.Rect({
                        width: style.width, height: shapeRenderHeight,
                        fill: style.backgroundColor, stroke: style.borderColor, strokeWidth: 1,
                        cornerRadius: 0, name: 'nodeShape' // No corner radius for plain rectangle
                    });
                }
                group.add(shape);
                shape.moveToBottom(); // Ensure shape is behind text and icon

                // Add icon if specified
                if (style.icon && style.icon !== '') {
                    const iconObject = new Konva.Text({
                        text: style.icon, fontSize: style.iconSize, fontFamily: style.fontFamily, fill: style.textColor,
                        x: style.padding, // Position icon with padding
                        y: (shapeRenderHeight - style.iconSize) / 2, // Vertically center icon
                        listening: false, // Icon itself shouldn't capture events
                        name: 'nodeIcon'
                    });
                    group.add(iconObject);
                }

                // Create text object for display (potentially truncated)
                const textToRender = new Konva.Text({
                    text: fullText, // Initially set to full text, clipping will handle display
                    fontSize: style.fontSize, fontFamily: style.fontFamily, fill: style.textColor,
                    width: textRenderWidth > 0 ? textRenderWidth : 0, // Ensure width is not negative
                    height: textDisplayHeight, // Set to calculated display height
                    x: style.padding + iconWidthForCalc, // Position text after icon and padding
                    y: style.padding, // Position text with padding from top
                    align: 'center', // Center align text
                    verticalAlign: 'top', // Align text to the top of its bounding box
                    lineHeight: 1.2, // Consistent line height
                    listening: true, // Text should be clickable/tappable
                    name: 'nodeTextContent'
                });

                // Apply clipping if text is truncated
                if (isTextTruncated) {
                    if (typeof textToRender.clip === 'function') { // Check if clip method exists (Konva versions)
                         textToRender.clip({
                            x: 0, y: 0, // Clip relative to the text object's position
                            width: textRenderWidth, height: textDisplayHeight
                        });
                    } else { // Fallback for older Konva or if .clip() is not a function
                        console.warn(`textToRender.clip is not a function for node ${nodeData.id}. Attempting to set clip as an attribute.`);
                        try {
                            textToRender.setAttr('clip', { x: 0, y: 0, width: textRenderWidth, height: textDisplayHeight });
                        } catch (clipAttrError) {
                            console.error("Failed to set clip as attribute:", clipAttrError);
                        }
                    }

                    // Add "Read more" indicator
                     const readMoreText = new Konva.Text({
                        x: style.padding + iconWidthForCalc, // Align with main text
                        y: style.padding + textDisplayHeight + style.padding * 0.2, // Position below truncated text
                        text: '... Xem thêm',
                        fontSize: style.fontSize * 0.8, // Smaller font for indicator
                        fill: '#007bff', // Link-like color
                        fontStyle: 'italic',
                        name: 'readMoreIndicator',
                        width: textRenderWidth, // Same width as text block for alignment
                        align: 'right' // Align to the right
                    });
                    group.add(readMoreText);
                    // Event listener for "Read more"
                    readMoreText.on('click tap', (ev) => {
                        const isPrimaryInteraction = (ev.evt.button === 0 && ev.type === 'click') || ev.type === 'tap';
                        if (isPrimaryInteraction && !contextMenuJustOpened) { // Avoid conflict with context menu
                            openNodeContentModal(nodeData.text.substring(0,30)+"...", fullText);
                        } else if (contextMenuJustOpened) {
                            contextMenuJustOpened = false; // Reset flag if context menu was just opened
                        }
                        ev.evt.cancelBubble = true; // Prevent event bubbling to the group
                    });
                }
                group.add(textToRender);

                // If text is truncated, clicking the text area itself (not just "read more") should also open the modal
                if (isTextTruncated) {
                    textToRender.on('click tap', (ev) => {
                        const isPrimaryInteraction = (ev.evt.button === 0 && ev.type === 'click') || ev.type === 'tap';
                        if (isPrimaryInteraction && !contextMenuJustOpened) {
                            openNodeContentModal(nodeData.text.substring(0,30)+"...", fullText);
                        } else if (contextMenuJustOpened) {
                            contextMenuJustOpened = false;
                        }
                        ev.evt.cancelBubble = true;
                    });
                }

                // Event listener for node drag end
                group.on('dragend', async function() {
                    if(!db) return;
                    try {
                        await updateDoc(doc(db, "nodes", this.id()), { position: { x: this.x(), y: this.y() } });
                    } catch (e) {
                        console.error("Error updating node position:", e);
                    }
                    this.draggable(false); // Disable draggable after drag ends (re-enabled on mousedown if needed)
                });

                // Event listener for node click/tap (selection)
                group.on('click tap', function(e) {
                    e.evt.cancelBubble = true; // Prevent event bubbling to the stage
                    if (isEditingText) return; // Prevent selection if modal is open
                    if (e.target.name() === 'readMoreIndicator') return; // Handled by its own listener
                    if (this.isDragging && this.isDragging()) { return; } // Don't select if it was a drag operation

                    const isPrimaryInteraction = (e.evt.button === 0 && e.type === 'click') || e.type === 'tap';

                    if (isPrimaryInteraction) {
                        if (contextMenuJustOpened) { // If context menu was just opened by this click/tap (e.g., long press)
                            contextMenuJustOpened = false; // Reset the flag
                        } else { // If it's a normal click/tap not related to context menu opening
                            const fullTextFromAttr = this.getAttr('fullTextData');
                            const hasReadMore = this.findOne('.readMoreIndicator');
                            // If node has "Read more" and the click was on the text or shape (not the indicator itself)
                            if (hasReadMore && (e.target.name() === 'nodeTextContent' || e.target.name() === 'nodeShape' || e.target === this ) ) {
                                if (e.target.name() !== 'nodeTextContent' && e.target.name() !== 'readMoreIndicator') { // Avoid double-opening if text itself was clicked
                                     openNodeContentModal(fullTextFromAttr.substring(0,30)+"...", fullTextFromAttr);
                                }
                            }
                        }
                    }

                    // Node selection logic
                    if (selectedKonvaNode && selectedKonvaNode !== this) { // Deselect previous node
                        selectedKonvaNode.findOne('.nodeShape')?.strokeWidth(1);
                        removeCreationHandle(selectedKonvaNode);
                    }
                    selectedKonvaNode = this; // Select current node
                    const shapeNode = this.findOne('.nodeShape');
                    if (shapeNode) {
                      shapeNode.strokeWidth(3); // Highlight selected node
                      addCreationHandle(this, shapeNode.height()); // Add creation handle
                    }

                    const clickedNodeData = allNodesDataForCurrentMap.find(n => n.id === this.id());
                    if (clickedNodeData) updateNodeStylePanel(clickedNodeData); // Update style panel
                    currentKonvaLayer.batchDraw(); // Redraw layer

                    // Hide context menu if a primary click occurs outside of it
                    if (isPrimaryInteraction && contextMenu && !contextMenu.classList.contains('hidden')) {
                        if (!contextMenu.contains(e.evt.target)) { // If click is outside context menu
                             hideContextMenu();
                        }
                    }
                });
                // UPDATED: Call new editTextOnKonvaNode for dblclick/dbltap
                group.on('dblclick dbltap', function() {
                    editTextOnKonvaNode(this); // Pass the group directly
                    hideContextMenu(); // Hide context menu if open
                });

                konvaNodeObjects[nodeData.id] = group; // Store Konva group for line drawing
                currentKonvaLayer.add(group);

                // If this node was previously selected, re-apply selected state
                if (selectedKonvaNode && selectedKonvaNode.id() === nodeData.id) {
                    shape.strokeWidth(3);
                    addCreationHandle(group, shape.height());
                }
            });

            // Draw lines between parent and child nodes
            nodesData.forEach(nodeData => {
                if (nodeData.parentId && konvaNodeObjects[nodeData.parentId] && konvaNodeObjects[nodeData.id]) {
                    const parentKonvaNode = konvaNodeObjects[nodeData.parentId];
                    const childKonvaNode = konvaNodeObjects[nodeData.id];
                    const parentNodeFromData = allNodesDataForCurrentMap.find(n=>n.id === nodeData.parentId); // Get parent's full data for style

                    const parentRenderedShape = parentKonvaNode.findOne('.nodeShape');
                    const childRenderedShape = childKonvaNode.findOne('.nodeShape');

                    // Ensure shapes exist before trying to get dimensions
                    if (!parentRenderedShape || !childRenderedShape) {
                        console.warn("Skipping line: parent or child shape not found for line between", nodeData.parentId, "and", nodeData.id);
                        return;
                    }

                    const parentActualHeight = parentRenderedShape.height();
                    const childActualHeight = childRenderedShape.height();
                    const parentActualWidth = parentRenderedShape.width();
                    const childActualWidth = childRenderedShape.width();

                    const parentStyle = { ...DEFAULT_NODE_STYLE, ...(parentNodeFromData?.style || {}) }; // Use parent's line style

                    const line = new Konva.Line({
                        points: [
                            parentKonvaNode.x() + parentActualWidth / 2, parentKonvaNode.y() + parentActualHeight / 2, // Center of parent
                            childKonvaNode.x() + childActualWidth / 2, childKonvaNode.y() + childActualHeight / 2    // Center of child
                        ],
                        stroke: parentStyle.lineColor,
                        strokeWidth: parentStyle.lineWidth,
                        dash: parentStyle.lineDash,
                        lineCap: 'round',
                        lineJoin: 'round',
                        name: 'connectionLine'
                    });
                    currentKonvaLayer.add(line);
                    line.moveToBottom(); // Draw lines behind nodes
                }
            });
            currentKonvaLayer.batchDraw(); // Redraw the layer with all nodes and lines
        }
        function addCreationHandle(parentNodeGroup, parentCurrentShapeHeight) {
            if (!parentNodeGroup || parentNodeGroup.findOne('.creationHandle')) return; // Don't add if exists

            const parentShapeInitial = parentNodeGroup.findOne('.nodeShape');
            if (!parentShapeInitial) {
                console.error("addCreationHandle: parentShapeInitial is undefined. Cannot add handle to node:", parentNodeGroup.id());
                return;
            }
            const shapeWidth = parentShapeInitial.width();
            // Position handle at the bottom-center of the shape
            let handleX = shapeWidth / 2;
            let handleY = parentCurrentShapeHeight; // Use the passed current height
            // Adjust for ellipse if needed (though typically a rect/roundedRect is better for this handle)
            if (parentShapeInitial.getClassName() === 'Ellipse') {
                handleX = parentShapeInitial.x(); // Ellipse x is center
                handleY = parentShapeInitial.y() + parentShapeInitial.radiusY(); // Bottom edge of ellipse
            }

            const handle = new Konva.Circle({
                x: handleX, y: handleY, radius: HANDLE_RADIUS, fill: HANDLE_FILL,
                stroke: HANDLE_STROKE, strokeWidth: 1, draggable: true, name: 'creationHandle',
                dragDistance: 3, // Minimum distance to start drag
                dragBoundFunc: function(pos) { // Keep handle within parent's local coordinate system
                    const parentAbsPos = parentNodeGroup.getAbsolutePosition();
                    return {
                        x: pos.x - parentAbsPos.x, // Convert absolute pos to relative
                        y: pos.y - parentAbsPos.y,
                    };
                }
            });
            parentNodeGroup.add(handle);
            parentNodeGroup.creationHandle = handle; // Store reference

            handle.on('dragstart', function(e) {
                e.evt.cancelBubble = true;
                if (!currentKonvaLayer || !parentNodeGroup) {
                    console.error("dragstart: currentKonvaLayer or parentNodeGroup is missing");
                    return;
                }
                const currentParentShape = parentNodeGroup.findOne('.nodeShape');
                if (!currentParentShape) {
                    console.error("dragstart: currentParentShape is undefined. parentNodeGroup ID:", parentNodeGroup.id());
                    return;
                }
                const parentNodeData = allNodesDataForCurrentMap.find(n => n.id === parentNodeGroup.id());
                const parentStyle = { ...DEFAULT_NODE_STYLE, ...(parentNodeData?.style || {}) };

                const lineColor = parentStyle.lineColor || DEFAULT_NODE_STYLE.lineColor;
                const lineWidth = parentStyle.lineWidth || DEFAULT_NODE_STYLE.lineWidth;
                let startX = currentParentShape.width() / 2;
                let startY = currentParentShape.height() / 2;
                if (currentParentShape.getClassName() === 'Ellipse') { // Adjust for ellipse center
                    startX = currentParentShape.x();
                    startY = currentParentShape.y();
                }
                tempCreationLine = new Konva.Line({
                    points: [ startX, startY, this.x(), this.y() ], // Line from parent center to handle
                    stroke: lineColor, strokeWidth: lineWidth, dash: parentStyle.lineDash || []
                });
                parentNodeGroup.add(tempCreationLine); // Add line to the same group as the handle
                currentKonvaLayer.batchDraw();
            });
            handle.on('dragmove', function(e) {
                e.evt.cancelBubble = true;
                if (tempCreationLine) {
                    const points = tempCreationLine.points();
                    points[2] = this.x(); // Update end point of the line to handle's current position
                    points[3] = this.y();
                    tempCreationLine.points(points);
                    currentKonvaLayer.batchDraw();
                }
            });
            handle.on('dragend', async function(e) {
                e.evt.cancelBubble = true;
                if (tempCreationLine) { tempCreationLine.destroy(); tempCreationLine = null; }

                if (!parentNodeGroup) {
                     console.error("dragend: parentNodeGroup is missing");
                     // Attempt to reset handle position even if parent is gone (though unlikely)
                     this.position({ x: (this.getStage()?.width() || 0) / 2, y: (this.getStage()?.height() || 0) / 2 });
                     currentKonvaLayer.batchDraw();
                     return;
                }
                const currentParentShapeForReset = parentNodeGroup.findOne('.nodeShape');
                if (!currentParentShapeForReset) {
                    console.error("dragend: currentParentShapeForReset is undefined. parentNodeGroup ID:", parentNodeGroup.id());
                    // Fallback reset position if shape is gone
                    const groupWidth = parentNodeGroup.width() || DEFAULT_NODE_STYLE.width;
                    const groupHeight = parentNodeGroup.height() || DEFAULT_NODE_STYLE.minHeight; // Use group height if shape height unknown
                    this.position({ x: groupWidth / 2, y: groupHeight });
                    currentKonvaLayer.batchDraw();
                    return;
                }

                // Calculate new node's absolute position based on handle's final position
                const handleFinalRelativeX = this.x();
                const handleFinalRelativeY = this.y();
                const parentAbsPos = parentNodeGroup.getAbsolutePosition();
                const newNodeAbsX = parentAbsPos.x + handleFinalRelativeX;
                const newNodeAbsY = parentAbsPos.y + handleFinalRelativeY;

                // Reset handle to its original position at the bottom of the parent
                let resetHandleX = currentParentShapeForReset.width() / 2;
                let resetHandleY = currentParentShapeForReset.height();
                if (currentParentShapeForReset.getClassName() === 'Ellipse') {
                    resetHandleX = currentParentShapeForReset.x();
                    resetHandleY = currentParentShapeForReset.y() + currentParentShapeForReset.radiusY();
                }
                this.position({ x: resetHandleX, y: resetHandleY });

                // Create the new child node in Firestore
                if (currentMindMapId && db && parentNodeGroup) {
                    const defaultChildWidth = 120;
                    const defaultChildMinHeight = 40;
                    const defaultChildPadding = 10;
                    const newNodeData = {
                        mapId: currentMindMapId,
                        parentId: parentNodeGroup.id(),
                        text: "Nút mới (kéo)",
                        position: { // Position the new node centered at the handle's drop location
                            x: newNodeAbsX - defaultChildWidth / 2,
                            y: newNodeAbsY - defaultChildMinHeight / 2
                        },
                        style: { ...DEFAULT_NODE_STYLE, backgroundColor: "#f9f9f9", textColor: "#333333", borderColor: "#cccccc", width: defaultChildWidth, minHeight: defaultChildMinHeight, padding: defaultChildPadding, cornerRadius: 3, shape: "rectangle", icon: '' },
                        createdAt: serverTimestamp()
                    };
                    try { await addDoc(collection(db, "nodes"), newNodeData); }
                    catch (err) { console.error("Error creating child node by dragging:", err); alert("Lỗi khi tạo nút con: " + err.message); }
                }
                currentKonvaLayer.batchDraw();
            });
            currentKonvaLayer.batchDraw();
        }
        function removeCreationHandle(parentNodeGroup) {
            if (parentNodeGroup && parentNodeGroup.creationHandle) {
                parentNodeGroup.creationHandle.destroy();
                parentNodeGroup.creationHandle = null; // Clear reference
                currentKonvaLayer.batchDraw();
            }
        }

        // --- REVISED: Node Text Editing Logic (Using Modal) ---
        function editTextOnKonvaNode(konvaGroup) {
            if (!konvaGroup || isEditingText || !editNodeTextModalOverlay || !editNodeTextarea) {
                // console.warn("editTextOnKonvaNode: called with invalid params or already editing.");
                return;
            }

            const fullTextData = konvaGroup.getAttr('fullTextData') || "";
            const nodeShortText = (fullTextData.substring(0, 25) + (fullTextData.length > 25 ? "..." : "")) || "Nút không tên";

            editingNodeIdForModal = konvaGroup.id(); // Store the ID of the node being edited

            if(editNodeTextModalTitle) editNodeTextModalTitle.textContent = `Sửa nội dung: ${nodeShortText}`;
            if(editNodeTextarea) {
                editNodeTextarea.value = fullTextData;
                // Dynamically adjust textarea height based on content
                const lineCount = (fullTextData.match(/\n/g) || []).length + 1; // Count newlines + 1
                const calculatedHeight = lineCount * 20 + 20; // Approx 20px per line + 20px padding/buffer
                const newTextareaHeight = Math.min(Math.max(calculatedHeight, 150), 400); // Clamp height between 150px and 400px
                editNodeTextarea.style.height = `${newTextareaHeight}px`;
                editNodeTextarea.focus();
                // editNodeTextarea.select(); // Optional: select all text when modal opens
            }

            showElement(editNodeTextModalOverlay);

            if (currentKonvaStage && currentKonvaStage.listening()) {
                currentKonvaStage.listening(false); // Disable stage interaction while modal is open
            }
            isEditingText = true; // Set editing flag
        }

        function closeEditNodeModal() {
            if (editNodeTextModalOverlay) {
                hideElement(editNodeTextModalOverlay);
            }
            if (currentKonvaStage && !currentKonvaStage.listening()) {
                currentKonvaStage.listening(true); // Re-enable stage interaction
            }
            editingNodeIdForModal = null; // Clear stored node ID
            isEditingText = false; // Reset editing flag
        }

        async function handleSaveNodeTextFromModal() {
            if (!editingNodeIdForModal || !editNodeTextarea || !db) {
                alert("Lỗi: Không thể lưu nội dung nút. Dữ liệu cần thiết bị thiếu.");
                closeEditNodeModal();
                return;
            }
            const newFullText = editNodeTextarea.value;
            try {
                await updateDoc(doc(db, "nodes", editingNodeIdForModal), { text: newFullText });
                // Firestore onSnapshot in renderNodesAndLines will automatically trigger re-render of the node on canvas
            } catch (e) {
                console.error("Error updating node text from modal:", e);
                alert("Lỗi khi cập nhật nội dung nút: " + e.message);
            } finally {
                closeEditNodeModal(); // Close modal whether save succeeds or fails
            }
        }


        // --- HÀM THU THẬP DỮ LIỆU NHÁNH ---
        function collectBranchDataRecursive(nodeId, allNodes, level, collectedTexts) {
            const node = allNodes.find(n => n.id === nodeId);
            if (!node) {
                return; // Node not found, stop recursion for this path
            }
            const indent = '    '.repeat(level); // Use spaces for indentation
            collectedTexts.push(indent + (node.text || "").trim()); // Add current node's text

            const children = allNodes.filter(n => n.parentId === nodeId); // Find direct children
            for (const child of children) {
                collectBranchDataRecursive(child.id, allNodes, level + 1, collectedTexts); // Recurse for each child
            }
        }


        // --- AI LOGIC FUNCTIONS (Function definitions) ---
        async function suggestChildNodesWithAI(parentNodeKonva) {
            if (!generativeModel || !parentNodeKonva || !currentMindMapId || !currentUser || !db) {
                alert("Chức năng AI chưa sẵn sàng hoặc thiếu thông tin cần thiết.");
                hideContextMenu(); return;
            }
            const parentNodeId = parentNodeKonva.id();
            const parentNodeData = allNodesDataForCurrentMap.find(n => n.id === parentNodeId);
            if (!parentNodeData) { alert("Không tìm thấy dữ liệu nút cha."); hideContextMenu(); return; }

            const parentText = parentNodeData.text;
            const prompt = `Cho một nút sơ đồ tư duy với nội dung là "${parentText}", hãy gợi ý 3 ý tưởng ngắn gọn (khoảng 2-5 từ mỗi ý tưởng) cho các nút con liên quan trực tiếp. Mỗi ý tưởng trên một dòng riêng biệt. Không sử dụng đánh số, gạch đầu dòng hay bất kỳ ký tự đặc biệt nào ở đầu dòng.`;

            showLoadingIndicator("AI đang tạo gợi ý...");
            hideContextMenu();
            try {
                const result = await generativeModel.generateContent(prompt);
                const response = result.response;
                const suggestionsText = response.text();
                const suggestions = suggestionsText.split('\n').map(s => s.trim()).filter(s => s.length > 0 && s.length < 50); // Filter and trim suggestions

                if (suggestions.length > 0) {
                    const batch = writeBatch(db);
                    let startX = parentNodeKonva.x();
                    let startY = parentNodeKonva.y();
                    const parentShape = parentNodeKonva.findOne('.nodeShape');
                    const parentWidth = parentShape?.width() || DEFAULT_NODE_STYLE.width;
                    const parentHeight = parentShape?.height() || DEFAULT_NODE_STYLE.minHeight;

                    // Position new nodes below and slightly offset from parent
                    startX += parentWidth / 4; // Offset a bit to the right
                    startY += parentHeight + 30; // Below the parent
                    const yOffsetIncrement = (DEFAULT_NODE_STYLE.minHeight || 50) + 20; // Spacing between new nodes

                    suggestions.slice(0, 5).forEach((suggestion, index) => { // Limit to 5 suggestions
                        const newNodeId = doc(collection(db, "nodes")).id; // Generate new ID locally
                        const newNodeData = {
                            mapId: currentMindMapId,
                            parentId: parentNodeId,
                            text: suggestion,
                            position: { x: startX, y: startY + (index * yOffsetIncrement) },
                            style: { ...DEFAULT_NODE_STYLE, backgroundColor: "#E3F2FD", textColor: "#0D47A1", borderColor: "#90CAF9", shape: "roundedRectangle", cornerRadius: 8, width: 130, minHeight: 40, fontSize: 13, icon: '' },
                            createdAt: serverTimestamp()
                        };
                        const nodeRef = doc(db, "nodes", newNodeId);
                        batch.set(nodeRef, newNodeData);
                    });
                    await batch.commit();
                } else {
                    alert("AI không thể đưa ra gợi ý nào phù hợp vào lúc này.");
                }
            } catch (error) {
                console.error("Error calling Gemini API (suggestChildNodesWithAI):", error);
                let userMessage = "Lỗi khi AI gợi ý nút con: " + error.message;
                if (error.message?.includes("API key not valid")) { userMessage += "\nVui lòng kiểm tra lại thiết lập API Key trong Firebase Console cho Gemini API."; }
                else if (error.message?.includes("429") || error.message?.toLowerCase().includes("quota")) { userMessage = "Bạn đã gửi quá nhiều yêu cầu tới AI hoặc đã hết hạn ngạch. Vui lòng thử lại sau ít phút."; }
                else if (error.message?.toLowerCase().includes("billing")){ userMessage = "Có vấn đề với cài đặt thanh toán cho dự án Firebase của bạn. Vui lòng kiểm tra trong Google Cloud Console."; }
                else if (error.message?.toLowerCase().includes("model not found")){ userMessage = "Model AI không được tìm thấy. Vui lòng kiểm tra lại tên model đã cấu hình.";}
                else if (error.message?.toLowerCase().includes("candidate.safetyRatings")){ userMessage = "Phản hồi từ AI bị chặn do vấn đề an toàn nội dung.";}
                alert(userMessage);
            } finally {
                hideLoadingIndicator();
            }
        }
        async function expandNodeWithAI(targetNodeKonva) {
            if (!generativeModel || !targetNodeKonva || !currentMindMapId || !currentUser || !db) {
                alert("Chức năng AI chưa sẵn sàng hoặc thiếu thông tin nút.");
                hideContextMenu(); return;
            }
            const targetNodeId = targetNodeKonva.id();
            const targetNodeData = allNodesDataForCurrentMap.find(n => n.id === targetNodeId);
            if (!targetNodeData) { alert("Không tìm thấy dữ liệu cho nút đã chọn."); hideContextMenu(); return; }

            const currentText = targetNodeData.text;
            const prompt = `Với ý tưởng chính là "${currentText}", hãy viết một đoạn văn bản chi tiết hơn (khoảng 3-5 câu) để giải thích, làm rõ hoặc mở rộng ý tưởng này. Giữ văn phong mạch lạc và tập trung vào chủ đề.`;

            showLoadingIndicator("AI đang mở rộng ý tưởng...");
            hideContextMenu();
            try {
                const result = await generativeModel.generateContent(prompt);
                const response = result.response;
                const expandedText = response.text().trim();

                if (expandedText && expandedText !== currentText) {
                    const nodeRef = doc(db, "nodes", targetNodeId);
                    await updateDoc(nodeRef, { text: expandedText });
                    // Firestore onSnapshot will re-render the node
                } else if (expandedText === currentText) {
                    alert("AI không tìm thấy cách mở rộng thêm cho ý tưởng này.");
                }
                else {
                    alert("AI không thể mở rộng ý tưởng vào lúc này.");
                }
            } catch (error) {
                console.error("Error calling Gemini API (expandNodeWithAI):", error);
                let userMessage = "Lỗi khi AI mở rộng ý tưởng: " + error.message;
                if (error.message?.includes("API key not valid")) { userMessage += "\nVui lòng kiểm tra lại thiết lập API Key trong Firebase Console cho Gemini API."; }
                else if (error.message?.includes("429") || error.message?.toLowerCase().includes("quota")) { userMessage = "Bạn đã gửi quá nhiều yêu cầu tới AI hoặc đã hết hạn ngạch. Vui lòng thử lại sau ít phút."; }
                else if (error.message?.toLowerCase().includes("billing")){ userMessage = "Có vấn đề với cài đặt thanh toán cho dự án Firebase của bạn. Vui lòng kiểm tra trong Google Cloud Console."; }
                else if (error.message?.toLowerCase().includes("model not found")){ userMessage = "Model AI không được tìm thấy. Vui lòng kiểm tra lại tên model đã cấu hình.";}
                else if (error.message?.toLowerCase().includes("candidate.safetyRatings")){ userMessage = "Phản hồi từ AI bị chặn do vấn đề an toàn nội dung.";}
                alert(userMessage);
            } finally {
                hideLoadingIndicator();
            }
        }
        async function generateExamplesWithAI(targetNodeKonva) {
             if (!generativeModel || !targetNodeKonva || !currentMindMapId || !currentUser || !db) {
                alert("Chức năng AI chưa sẵn sàng hoặc thiếu thông tin nút.");
                hideContextMenu(); return;
            }
            const targetNodeId = targetNodeKonva.id();
            const targetNodeData = allNodesDataForCurrentMap.find(n => n.id === targetNodeId);
            if (!targetNodeData) { alert("Không tìm thấy dữ liệu cho nút đã chọn."); hideContextMenu(); return; }

            const currentText = targetNodeData.text;
            const prompt = `Cho chủ đề sau: "${currentText}", hãy tạo ra 2 hoặc 3 ví dụ cụ thể để minh họa cho chủ đề này. Mỗi ví dụ trên một dòng riêng biệt. Không dùng đánh số hay gạch đầu dòng. Các ví dụ nên ngắn gọn và dễ hiểu.`;

            showLoadingIndicator("AI đang tạo ví dụ...");
            hideContextMenu();
            try {
                const result = await generativeModel.generateContent(prompt);
                const response = result.response;
                const examplesText = response.text().trim();
                const examples = examplesText.split('\n').map(ex => ex.trim()).filter(ex => ex.length > 0 && ex.length < 150); // Filter and trim examples

                if (examples.length > 0) {
                    const batch = writeBatch(db);
                    let startX = targetNodeKonva.x();
                    let startY = targetNodeKonva.y();
                    const parentShape = targetNodeKonva.findOne('.nodeShape');
                    const parentWidth = parentShape?.width() || DEFAULT_NODE_STYLE.width;
                    const parentHeight = parentShape?.height() || DEFAULT_NODE_STYLE.minHeight;

                    startX += parentWidth / 3; // Offset for new example nodes
                    startY += parentHeight + 35;
                    const yOffsetIncrement = (DEFAULT_NODE_STYLE.minHeight || 50) + 20;

                    examples.slice(0, 3).forEach((example, index) => { // Limit to 3 examples
                        const newNodeId = doc(collection(db, "nodes")).id;
                        const exampleNodeStyle = { ...DEFAULT_NODE_STYLE, backgroundColor: "#E8F5E9", textColor: "#2E7D32", borderColor: "#A5D6A7", shape: "roundedRectangle", cornerRadius: 7, width: 160, minHeight: 40, fontSize: 13, icon: '💡' };
                        const newNodeData = {
                            mapId: currentMindMapId,
                            parentId: targetNodeId,
                            text: `Ví dụ: ${example}`,
                            position: { x: startX + (index * 10), y: startY + (index * yOffsetIncrement) }, // Stagger positions slightly
                            style: exampleNodeStyle,
                            createdAt: serverTimestamp()
                        };
                        const nodeRef = doc(db, "nodes", newNodeId);
                        batch.set(nodeRef, newNodeData);
                    });
                    await batch.commit();
                } else {
                    alert("AI không thể tạo ví dụ nào phù hợp vào lúc này.");
                }
            } catch (error) {
                console.error("Error calling Gemini API (generateExamplesWithAI):", error);
                let userMessage = "Lỗi khi AI tạo ví dụ: " + error.message;
                if (error.message?.includes("API key not valid")) { userMessage += "\nVui lòng kiểm tra lại thiết lập API Key trong Firebase Console cho Gemini API."; }
                else if (error.message?.includes("429") || error.message?.toLowerCase().includes("quota")) { userMessage = "Bạn đã gửi quá nhiều yêu cầu tới AI hoặc đã hết hạn ngạch. Vui lòng thử lại sau ít phút."; }
                else if (error.message?.toLowerCase().includes("billing")){ userMessage = "Có vấn đề với cài đặt thanh toán cho dự án Firebase của bạn. Vui lòng kiểm tra trong Google Cloud Console."; }
                else if (error.message?.toLowerCase().includes("model not found")){ userMessage = "Model AI không được tìm thấy. Vui lòng kiểm tra lại tên model đã cấu hình.";}
                else if (error.message?.toLowerCase().includes("candidate.safetyRatings")){ userMessage = "Phản hồi từ AI bị chặn do vấn đề an toàn nội dung.";}
                alert(userMessage);
            } finally {
                hideLoadingIndicator();
            }
        }
        async function askAIAboutNode(targetNodeKonva) {
            if (!generativeModel || !targetNodeKonva || !currentMindMapId || !currentUser || !db) {
                alert("Chức năng AI chưa sẵn sàng hoặc thiếu thông tin nút.");
                hideContextMenu(); return;
            }
            const targetNodeId = targetNodeKonva.id();
            const targetNodeData = allNodesDataForCurrentMap.find(n => n.id === targetNodeId);
            if (!targetNodeData) { alert("Không tìm thấy dữ liệu cho nút đã chọn."); hideContextMenu(); return; }

            const nodeTextContext = targetNodeData.text;
            const userQuestion = window.prompt(`Hỏi AI về nội dung của nút: "${nodeTextContext}"\nNhập câu hỏi của bạn:`, "");

            if (!userQuestion || userQuestion.trim() === "") {
                hideContextMenu(); return; // User cancelled or entered nothing
            }

            const prompt = `Nội dung của một nút trong sơ đồ tư duy là: "${nodeTextContext}".\n\nNgười dùng có câu hỏi sau về nút này: "${userQuestion.trim()}"\n\nHãy trả lời câu hỏi đó một cách ngắn gọn và súc tích, tập trung vào ngữ cảnh được cung cấp từ nút.`;
            showLoadingIndicator("AI đang trả lời câu hỏi...");
            hideContextMenu();
            try {
                const result = await generativeModel.generateContent(prompt);
                const response = result.response;
                const aiAnswer = response.text().trim();

                if (aiAnswer) {
                    openAiResponseModal(`Hỏi AI về: "${nodeTextContext.substring(0,30)}..."`, userQuestion.trim(), aiAnswer);
                }
                else {
                    openAiResponseModal(`Hỏi AI về: "${nodeTextContext.substring(0,30)}..."`, userQuestion.trim(), "AI không thể đưa ra câu trả lời vào lúc này.");
                }
            } catch (error) {
                console.error("Error calling Gemini API (askAIAboutNode):", error);
                let userMessage = "Lỗi khi AI trả lời câu hỏi: " + error.message;
                if (error.message?.includes("API key not valid")) { userMessage += "\nVui lòng kiểm tra lại thiết lập API Key trong Firebase Console cho Gemini API."; }
                else if (error.message?.includes("429") || error.message?.toLowerCase().includes("quota")) { userMessage = "Bạn đã gửi quá nhiều yêu cầu tới AI hoặc đã hết hạn ngạch. Vui lòng thử lại sau ít phút."; }
                else if (error.message?.toLowerCase().includes("billing")){ userMessage = "Có vấn đề với cài đặt thanh toán cho dự án Firebase của bạn. Vui lòng kiểm tra trong Google Cloud Console."; }
                else if (error.message?.toLowerCase().includes("model not found")){ userMessage = "Model AI không được tìm thấy. Vui lòng kiểm tra lại tên model đã cấu hình.";}
                else if (error.message?.toLowerCase().includes("candidate.safetyRatings")){ userMessage = "Phản hồi từ AI bị chặn do vấn đề an toàn nội dung.";}
                openAiResponseModal("Lỗi AI", userQuestion.trim(), userMessage);
            } finally {
                hideLoadingIndicator();
            }
        }

        async function summarizeBranchWithAI(targetNodeKonva) {
            if (!generativeModel || !targetNodeKonva || !currentMindMapId || !currentUser || !db) {
                alert("Chức năng AI chưa sẵn sàng hoặc không có nút nào được chọn.");
                hideContextMenu(); return;
            }
            const rootNodeId = targetNodeKonva.id();
            const rootNodeData = allNodesDataForCurrentMap.find(n => n.id === rootNodeId);
            if (!rootNodeData) {
                alert("Không tìm thấy dữ liệu cho nút gốc của nhánh.");
                hideContextMenu(); return;
            }

            showLoadingIndicator("AI đang chuẩn bị dữ liệu để tóm tắt...");
            hideContextMenu();

            const branchTextsArray = [];
            collectBranchDataRecursive(rootNodeId, allNodesDataForCurrentMap, 0, branchTextsArray);

            if (branchTextsArray.length === 0) {
                alert("Không có dữ liệu văn bản trong nhánh này để tóm tắt.");
                hideLoadingIndicator(); return;
            }

            const branchContentForPrompt = branchTextsArray.join('\n');
            const maxContentLength = 15000; // Adjust as needed, consider token limits for the model
            let truncatedContent = branchContentForPrompt;
            let isTruncated = false;
            if (branchContentForPrompt.length > maxContentLength) {
                console.warn("Nội dung nhánh quá dài, đã được cắt bớt để gửi cho AI.");
                truncatedContent = branchContentForPrompt.substring(0, maxContentLength) + "\n... (nội dung đã được cắt bớt do quá dài)";
                isTruncated = true;
            }

            const prompt = `Bạn là một trợ lý AI xuất sắc, chuyên về phân tích và tóm tắt thông tin từ sơ đồ tư duy.
Dưới đây là nội dung của một nhánh trong sơ đồ tư duy, được trình bày theo cấu trúc phân cấp (các mục con được thụt đầu dòng tương ứng với cấp độ của chúng trong sơ đồ):
---
${truncatedContent}
---
${isTruncated ? "\LƯU Ý: Nội dung trên có thể đã được rút gọn do giới hạn độ dài.\n" : ""}
Nhiệm vụ của bạn là tạo một bản tóm tắt mạch lạc, súc tích và chính xác (khoảng 3 đến 7 câu văn, hoặc nhiều hơn một chút nếu cần thiết để bao quát ý chính) về nhánh sơ đồ tư duy này. Bản tóm tắt cần:
1. Nêu bật được ý tưởng hoặc chủ đề chính của nút gốc.
2. Đề cập đến các chủ đề con hoặc các khía cạnh quan trọng nhất được phát triển trong nhánh.
3. Chỉ ra được mối quan hệ logic chính yếu hoặc dòng chảy ý tưởng trong nhánh (nếu có).
4. Sử dụng ngôn ngữ rõ ràng, dễ hiểu.
Hãy cung cấp bản tóm tắt dưới dạng một đoạn văn bản duy nhất.`;

            showLoadingIndicator("AI đang tóm tắt nhánh...");
            try {
                const result = await generativeModel.generateContent(prompt);
                const response = result.response;
                const summaryText = response.text().trim();
                const rootNodeTextPreview = (rootNodeData.text || "Không có tiêu đề").substring(0, 30) + ((rootNodeData.text || "").length > 30 ? "..." : "");

                if (summaryText) {
                    // Create a new node as a child of the summarized node to display the summary
                    const parentShape = targetNodeKonva.findOne('.nodeShape');
                    const parentHeight = parentShape ? parentShape.height() : DEFAULT_NODE_STYLE.minHeight;
                    const parentWidth = parentShape ? parentShape.width() : DEFAULT_NODE_STYLE.width;


                    const newNodeData = {
                        mapId: currentMindMapId,
                        parentId: rootNodeId, // Child of the node that was summarized
                        text: `📄 Tóm tắt nhánh:\n${summaryText}`,
                        position: {
                            x: targetNodeKonva.x() + parentWidth / 4 + 10, // Position it near the parent
                            y: targetNodeKonva.y() + parentHeight + 35
                        },
                        style: {
                            ...DEFAULT_NODE_STYLE,
                            backgroundColor: "#FFFDE7", // Light yellow for summary
                            textColor: "#4E342E", // Dark brown text
                            borderColor: "#FFD54F", // Amber border
                            shape: "roundedRectangle",
                            cornerRadius: 6,
                            width: 250, // Wider for summary
                            minHeight: 70,
                            fontSize: 13,
                            icon: '📄'
                        },
                        createdAt: serverTimestamp()
                    };
                    await addDoc(collection(db, "nodes"), newNodeData);
                    alert(`AI đã tạo một nút tóm tắt con cho nhánh "${rootNodeTextPreview}".`);

                } else {
                     openAiResponseModal(
                        `AI Tóm tắt nhánh: "${rootNodeTextPreview}"`,
                        truncatedContent, // Show what was sent to AI
                        "AI không thể tạo tóm tắt cho nhánh này vào lúc này. Vui lòng thử lại hoặc kiểm tra nội dung nhánh."
                    );
                }
            } catch (error) {
                console.error("Error calling Gemini API (summarizeBranchWithAI):", error);
                let userMessage = "Lỗi khi AI tóm tắt nhánh: " + error.message;
                 if (error.message?.includes("API key not valid")) { userMessage += "\nVui lòng kiểm tra lại thiết lập API Key trong Firebase Console cho Gemini API."; }
                else if (error.message?.includes("429") || error.message?.toLowerCase().includes("quota")) { userMessage = "Bạn đã gửi quá nhiều yêu cầu tới AI hoặc đã hết hạn ngạch. Vui lòng thử lại sau ít phút."; }
                else if (error.message?.toLowerCase().includes("billing")){ userMessage = "Có vấn đề với cài đặt thanh toán cho dự án Firebase của bạn. Vui lòng kiểm tra trong Google Cloud Console."; }
                else if (error.message?.toLowerCase().includes("model not found")){ userMessage = "Model AI không được tìm thấy. Vui lòng kiểm tra lại tên model đã cấu hình.";}
                else if (error.message?.toLowerCase().includes("candidate.safetyRatings")){ userMessage = "Phản hồi từ AI bị chặn do vấn đề an toàn nội dung. Nội dung nhánh có thể chứa từ khóa nhạy cảm.";}
                openAiResponseModal( `Lỗi AI khi tóm tắt nhánh`, truncatedContent, userMessage );
            } finally {
                hideLoadingIndicator();
            }
        }
        async function generateActionPlanWithAI(targetNodeKonva) {
            if (!generativeModel || !targetNodeKonva || !currentMindMapId || !currentUser || !db) {
                alert("Chức năng AI chưa sẵn sàng hoặc không có nút nào được chọn.");
                hideContextMenu(); return;
            }
            const targetNodeId = targetNodeKonva.id();
            const targetNodeData = allNodesDataForCurrentMap.find(n => n.id === targetNodeId);
            if (!targetNodeData || !targetNodeData.text || targetNodeData.text.trim() === "") {
                alert("Nút được chọn không có nội dung hoặc nội dung không hợp lệ để tạo kế hoạch hành động.");
                hideContextMenu(); return;
            }

            const nodeContent = targetNodeData.text.trim();
            const nodeContentPreview = nodeContent.substring(0, 30) + (nodeContent.length > 30 ? "..." : "");

            showLoadingIndicator("AI đang tạo kế hoạch hành động...");
            hideContextMenu();

            const prompt = `Bạn là một trợ lý AI chuyên nghiệp trong việc lập kế hoạch và đề xuất chiến lược hành động.
Dựa trên mục tiêu hoặc vấn đề được mô tả dưới đây:
"${nodeContent}"

Hãy đề xuất một kế hoạch hành động sơ bộ, bao gồm từ 3 đến 5 bước cụ thể, rõ ràng và có tính khả thi cao để đạt được mục tiêu hoặc giải quyết vấn đề đã nêu. Mỗi bước nên:
1. Bắt đầu bằng một động từ hành động mạnh mẽ (ví dụ: Phân tích, Xác định, Thiết kế, Xây dựng, Triển khai, Kiểm tra, Đánh giá, Tối ưu hóa).
2. Mô tả ngắn gọn nhưng đầy đủ về hành động cần thực hiện.
3. Có thể được thực hiện một cách độc lập hoặc theo trình tự logic.
Vui lòng trình bày toàn bộ kế hoạch dưới dạng một khối văn bản, với mỗi bước hành động trên một dòng riêng biệt, bắt đầu bằng số thứ tự (ví dụ: 1. ..., 2. ...).`;

            try {
                const result = await generativeModel.generateContent(prompt);
                const response = result.response;
                const actionPlanText = response.text().trim();

                if (actionPlanText) {
                    const parentShape = targetNodeKonva.findOne('.nodeShape');
                    const parentHeight = parentShape ? parentShape.height() : DEFAULT_NODE_STYLE.minHeight;
                    const parentWidth = parentShape ? parentShape.width() : DEFAULT_NODE_STYLE.width;

                    const newNodeData = {
                        mapId: currentMindMapId,
                        parentId: targetNodeId, // Child of the node the plan is for
                        text: `🚀 Kế hoạch hành động:\n${actionPlanText}`,
                        position: {
                            x: targetNodeKonva.x() + parentWidth / 4 + 10,
                            y: targetNodeKonva.y() + parentHeight + 35 // Similar positioning to summary node
                        },
                        style: {
                            ...DEFAULT_NODE_STYLE,
                            backgroundColor: "#E3F2FD", // Light blue for action plan
                            textColor: "#0D47A1", // Dark blue text
                            borderColor: "#90CAF9", // Lighter blue border
                            shape: "roundedRectangle",
                            cornerRadius: 4,
                            width: 280, // Wider for action plan
                            minHeight: 80,
                            fontSize: 13,
                            icon: '🚀'
                        },
                        createdAt: serverTimestamp()
                    };
                    await addDoc(collection(db, "nodes"), newNodeData);
                    alert(`AI đã tạo một nút kế hoạch hành động cho "${nodeContentPreview}".`);

                } else {
                    openAiResponseModal(
                        `Kế hoạch hành động cho: "${nodeContentPreview}"`,
                        `Mục tiêu/Vấn đề: ${nodeContent}`,
                        "AI không thể tạo kế hoạch hành động cho mục tiêu này vào lúc này. Vui lòng thử lại."
                    );
                }
            } catch (error) {
                console.error("Error calling Gemini API (generateActionPlanWithAI):", error);
                let userMessage = "Lỗi khi AI tạo kế hoạch hành động: " + error.message;
                if (error.message?.includes("API key not valid")) { userMessage += "\nVui lòng kiểm tra lại thiết lập API Key trong Firebase Console cho Gemini API."; }
                else if (error.message?.includes("429") || error.message?.toLowerCase().includes("quota")) { userMessage = "Bạn đã gửi quá nhiều yêu cầu tới AI hoặc đã hết hạn ngạch. Vui lòng thử lại sau ít phút."; }
                else if (error.message?.toLowerCase().includes("billing")){ userMessage = "Có vấn đề với cài đặt thanh toán cho dự án Firebase của bạn. Vui lòng kiểm tra trong Google Cloud Console."; }
                else if (error.message?.toLowerCase().includes("model not found")){ userMessage = "Model AI không được tìm thấy. Vui lòng kiểm tra lại tên model đã cấu hình.";}
                else if (error.message?.toLowerCase().includes("candidate.safetyRatings")){ userMessage = "Phản hồi từ AI bị chặn do vấn đề an toàn nội dung. Nội dung của nút có thể chứa từ khóa nhạy cảm.";}
                openAiResponseModal(
                    `Lỗi AI khi tạo kế hoạch hành động`,
                    `Mục tiêu/Vấn đề: ${nodeContent}`,
                    userMessage
                );
            } finally {
                hideLoadingIndicator();
            }
        }

        // --- TOOLBAR BUTTON ACTIONS & KEYBOARD SHORTCUTS & ZOOM ---
        async function addChildNodeLogic(parentNode) {
            if (!parentNode || !currentMindMapId || !db) return;
            const parentShape = parentNode.findOne('.nodeShape');
            if (!parentShape) {
                console.error("addChildNodeLogic: Could not find '.nodeShape' in parentNode:", parentNode.id());
                alert("Lỗi: Không tìm thấy hình dạng của nút cha để thêm nút con.");
                return;
            }
            const parentWidth = parentShape.width();
            const parentHeight = parentShape.height();

            const defaultChildStyle = { ...DEFAULT_NODE_STYLE, backgroundColor: "#f9f9f9", textColor: "#333333", borderColor: "#cccccc", shape: "rectangle", cornerRadius: 3, icon: '' };
            const newNodeData = {
                mapId: currentMindMapId,
                parentId: parentNode.id(),
                text: "Nút con mới",
                position: { // Position below and slightly to the right of parent
                    x: parentNode.x() + parentWidth / 4,
                    y: parentNode.y() + parentHeight + 30
                },
                style: defaultChildStyle,
                createdAt: serverTimestamp()
            };
            try {
                await addDoc(collection(db, "nodes"), newNodeData);
                // Firestore onSnapshot will handle re-rendering
            }
            catch (e) {
                console.error("Error adding child node:", e);
                alert("Lỗi khi thêm nút con: " + e.message);
            }
        }
        function findAllDescendantNodeIds(parentNodeId, allNodes) {
            let descendantIds = [];
            const directChildren = allNodes.filter(node => node.parentId === parentNodeId);
            for (const child of directChildren) {
                descendantIds.push(child.id);
                descendantIds = descendantIds.concat(findAllDescendantNodeIds(child.id, allNodes)); // Recursively find children of children
            }
            return descendantIds;
        }
        async function deleteNodeLogic(nodeToDelete) {
            if (!nodeToDelete || !currentMindMapId || !db) return;
            const nodeId = nodeToDelete.id();
            const konvaTextNode = nodeToDelete.findOne('.nodeTextContent');
            const nodeText = konvaTextNode ? (nodeToDelete.getAttr('fullTextData') || "Nút không tên") : "Nút không tên"; // Use full text for confirm
            const nodeTextPreview = nodeText.substring(0,30) + (nodeText.length > 30 ? "..." : "");

            if (window.confirm(`Bạn có chắc muốn xóa nút "${nodeTextPreview}" và TẤT CẢ các nút con của nó không? Hành động này không thể hoàn tác.`)) {
                try {
                    const descendantIds = findAllDescendantNodeIds(nodeId, allNodesDataForCurrentMap);
                    const allIdsToDelete = [nodeId, ...descendantIds];

                    const batch = writeBatch(db);
                    allIdsToDelete.forEach(id => {
                        batch.delete(doc(db, "nodes", id));
                    });
                    await batch.commit();

                    // Reset selection if the deleted node or one of its descendants was selected
                    if (selectedKonvaNode && allIdsToDelete.includes(selectedKonvaNode.id())) {
                        selectedKonvaNode = null;
                        if(nodeStylePanel) hideElement(nodeStylePanel);
                    }
                    if (rightClickedKonvaNode && allIdsToDelete.includes(rightClickedKonvaNode.id())) {
                        rightClickedKonvaNode = null;
                    }
                    // Firestore onSnapshot will handle re-rendering
                } catch (e) {
                    console.error("Error deleting node and descendants:", e);
                    alert("Lỗi khi xóa nút: " + e.message);
                }
            }
        }
        function handleGlobalKeyDown(e) {
            if (isEditingText) return; // Prevent global key actions if a modal (like edit node) is active

            // If context menu is open, Escape should close it
            if (contextMenu && !contextMenu.classList.contains('hidden')) {
                if (e.key === 'Escape') {
                    hideContextMenu();
                }
                return; // Don't process other keys if context menu is open
            }

            // If no node is selected, only allow arrow keys for stage panning
            if (!selectedKonvaNode && !['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                // Allow these keys even if no node is selected for other potential global shortcuts (none currently)
                if (e.key === 'Tab' || e.key === 'Enter' || e.key === 'Delete' || e.key === 'Backspace') return;
            }

            const KEYBOARD_MOVE_STEP = 10; // Pixels to move node/stage per key press
            switch (e.key) {
                case 'Tab': // Add child to selected node
                    if (selectedKonvaNode) {
                        e.preventDefault(); // Prevent default tab behavior
                        addChildNodeLogic(selectedKonvaNode);
                    }
                    break;
                case 'Enter': // Edit selected node
                    if (selectedKonvaNode) {
                        e.preventDefault();
                        editTextOnKonvaNode(selectedKonvaNode); // UPDATED call to use modal
                    }
                    break;
                case 'Delete':
                case 'Backspace': // Delete selected node and its children
                    if (selectedKonvaNode) {
                        e.preventDefault();
                        deleteNodeLogic(selectedKonvaNode);
                    }
                    break;
                case 'ArrowUp':
                case 'ArrowDown':
                case 'ArrowLeft':
                case 'ArrowRight':
                    e.preventDefault(); // Prevent page scrolling
                    if (selectedKonvaNode) { // Move selected node
                        let newX = selectedKonvaNode.x();
                        let newY = selectedKonvaNode.y();
                        if (e.key === 'ArrowUp') newY -= KEYBOARD_MOVE_STEP;
                        else if (e.key === 'ArrowDown') newY += KEYBOARD_MOVE_STEP;
                        else if (e.key === 'ArrowLeft') newX -= KEYBOARD_MOVE_STEP;
                        else if (e.key === 'ArrowRight') newX += KEYBOARD_MOVE_STEP;
                        selectedKonvaNode.position({ x: newX, y: newY });
                        currentKonvaLayer.batchDraw();
                        // Debounce Firestore update or update on dragend equivalent for keyboard
                        if (db) {
                            updateDoc(doc(db, "nodes", selectedKonvaNode.id()), { position: { x: newX, y: newY } })
                                .catch(err => console.error("Error updating node position via keyboard:", err));
                        }
                    } else if (currentKonvaStage) { // Pan the stage if no node is selected
                        let stageX = currentKonvaStage.x();
                        let stageY = currentKonvaStage.y();
                        // Invert direction for intuitive panning
                        if (e.key === 'ArrowUp') stageY += KEYBOARD_MOVE_STEP * 2; // Pan view up = move stage content down
                        else if (e.key === 'ArrowDown') stageY -= KEYBOARD_MOVE_STEP * 2;
                        else if (e.key === 'ArrowLeft') stageX += KEYBOARD_MOVE_STEP * 2;
                        else if (e.key === 'ArrowRight') stageX -= KEYBOARD_MOVE_STEP * 2;
                        currentKonvaStage.position({x: stageX, y: stageY });
                        currentKonvaStage.batchDraw();
                        saveCanvasState(); // Save new stage position
                    }
                    break;
            }
        }

        // --- MAIN SCRIPT EXECUTION AFTER DOM IS LOADED ---
        window.addEventListener('DOMContentLoaded', () => {
            // Initialize Firebase services
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                // Initialize Firebase AI (Gemini)
                if (typeof getAI === 'function' && typeof GoogleAIBackend === 'function' && typeof getGenerativeModel === 'function') {
                    ai = getAI(app, { backend: new GoogleAIBackend() }); // Using default backend
                    generativeModel = getGenerativeModel(ai, { model: "gemini-1.5-flash-latest" }); // Specify your desired model
                    // console.log("Firebase initialized successfully with AI Logic SDK!");
                } else {
                    console.error("Firebase AI SDK components not found. AI features will be disabled.");
                    alert("Lỗi: Không thể tải các thành phần AI của Firebase. Các tính năng AI sẽ bị vô hiệu hóa.");
                }
            } catch (error) {
                console.error("Firebase initialization error:", error);
                alert("Lỗi nghiêm trọng: Không thể khởi tạo Firebase hoặc AI SDK. Chi tiết: " + error.message + "\nHãy chắc chắn bạn đã thay thế các giá trị placeholder trong firebaseConfig bằng thông tin dự án Firebase của bạn.");
            }

            // Assign DOM elements
            nodeStylePanel = document.getElementById('node-style-panel');
            nodeShapeSelect = document.getElementById('node-shape-select');
            nodeFontFamilySelect = document.getElementById('node-font-family-select');
            nodeFontSizeInput = document.getElementById('node-font-size-input');
            nodeIconSelect = document.getElementById('node-icon-select');
            nodeBgColorInput = document.getElementById('node-bg-color');
            nodeTextColorInput = document.getElementById('node-text-color');
            nodeBorderColorInput = document.getElementById('node-border-color');
            nodeLineColorInput = document.getElementById('node-line-color');
            nodeLineDashSelect = document.getElementById('node-line-dash-select');
            nodeLineWidthInput = document.getElementById('node-line-width');

            contextMenu = document.getElementById('context-menu');
            ctxAddChildButton = document.getElementById('ctx-add-child');
            ctxEditTextButton = document.getElementById('ctx-edit-text');
            ctxViewFullContentButton = document.getElementById('ctx-view-full-content');
            ctxSuggestChildrenButton = document.getElementById('ctx-suggest-children');
            ctxExpandNodeButton = document.getElementById('ctx-expand-node');
            ctxGenerateExamplesButton = document.getElementById('ctx-generate-examples');
            ctxAskAiNodeButton = document.getElementById('ctx-ask-ai-node');
            ctxSummarizeBranchButton = document.getElementById('ctx-summarize-branch');
            ctxGenerateActionPlanButton = document.getElementById('ctx-generate-action-plan');
            ctxDeleteNodeButton = document.getElementById('ctx-delete-node');

            aiLoadingIndicator = document.getElementById('ai-loading-indicator');
            aiResponseModalOverlay = document.getElementById('ai-response-modal-overlay');
            aiResponseModalTitle = document.getElementById('ai-response-modal-title');
            aiResponseModalBody = document.getElementById('ai-response-modal-body');
            aiResponseModalCloseButton = document.getElementById('ai-response-modal-close-button');

            nodeContentModalOverlay = document.getElementById('node-content-modal-overlay');
            nodeContentModalTitle = document.getElementById('node-content-modal-title');
            nodeContentModalBody = document.getElementById('node-content-modal-body');
            nodeContentModalCloseButton = document.getElementById('node-content-modal-close-button');

            // NEW: Assign Edit Node Text Modal elements
            editNodeTextModalOverlay = document.getElementById('edit-node-text-modal-overlay');
            editNodeTextModalTitle = document.getElementById('edit-node-text-modal-title');
            editNodeTextarea = document.getElementById('edit-node-textarea');
            editNodeTextModalSaveButton = document.getElementById('edit-node-text-modal-save-button');
            editNodeTextModalCancelButton = document.getElementById('edit-node-text-modal-cancel-button');
            editNodeTextModalCloseButton = document.getElementById('edit-node-text-modal-close-button');


            authSection = document.getElementById('auth-section');
            loginForm = document.getElementById('login-form');
            registerForm = document.getElementById('register-form');
            loginEmailInput = document.getElementById('login-email');
            loginPasswordInput = document.getElementById('login-password');
            loginButton = document.getElementById('login-button');
            showRegisterLink = document.getElementById('show-register-link');
            registerEmailInput = document.getElementById('register-email');
            registerPasswordInput = document.getElementById('register-password');
            registerButton = document.getElementById('register-button');
            showLoginLink = document.getElementById('show-login-link');
            loginErrorMsg = document.getElementById('login-error');
            registerErrorMsg = document.getElementById('register-error');


            mainAppSection = document.getElementById('main-app-section');
            mainAppTitle = document.getElementById('main-app-title');
            userEmailDisplay = document.getElementById('user-email-display');
            logoutButton = document.getElementById('logout-button');


            mindmapManagementView = document.getElementById('mindmap-management-view');
            newMindmapTitleInput = document.getElementById('new-mindmap-title-input');
            createMindmapButton = document.getElementById('create-mindmap-button');
            mindmapListUl = document.getElementById('mindmap-list');
            mindmapListLoading = document.getElementById('mindmap-list-loading');


            canvasView = document.getElementById('canvas-view');
            backToMapsListButton = document.getElementById('back-to-maps-list-button');
            currentMindmapTitleDisplay = document.getElementById('current-mindmap-title-display');
            addChildNodeButton = document.getElementById('add-child-node-button');
            deleteNodeButton = document.getElementById('delete-node-button');
            zoomInButton = document.getElementById('zoom-in-button');
            zoomOutButton = document.getElementById('zoom-out-button');
            resetZoomButton = document.getElementById('reset-zoom-button');
            konvaContainer = document.getElementById('konva-container');
            konvaContainerLoading = document.getElementById('konva-container-loading');


            // Setup event listeners
            if (aiResponseModalCloseButton) { aiResponseModalCloseButton.addEventListener('click', closeAiResponseModal); }
            if (aiResponseModalOverlay) { aiResponseModalOverlay.addEventListener('click', function(event) { if (event.target === aiResponseModalOverlay) closeAiResponseModal(); }); }
            if (nodeContentModalCloseButton) { nodeContentModalCloseButton.addEventListener('click', closeNodeContentModal); }
            if (nodeContentModalOverlay) { nodeContentModalOverlay.addEventListener('click', function(event) { if (event.target === nodeContentModalOverlay) closeNodeContentModal(); });}

            // NEW: Event listeners for Edit Node Text Modal
            if (editNodeTextModalSaveButton) { editNodeTextModalSaveButton.addEventListener('click', handleSaveNodeTextFromModal); }
            if (editNodeTextModalCancelButton) { editNodeTextModalCancelButton.addEventListener('click', closeEditNodeModal); }
            if (editNodeTextModalCloseButton) { editNodeTextModalCloseButton.addEventListener('click', closeEditNodeModal); }
            if (editNodeTextarea) { // Allow Ctrl+Enter to save, Enter for new line
                editNodeTextarea.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && e.ctrlKey) { // Ctrl+Enter to save
                        e.preventDefault();
                        handleSaveNodeTextFromModal();
                    } else if (e.key === 'Escape') { // Allow Esc from textarea to close modal
                        e.preventDefault();
                        closeEditNodeModal();
                    }
                    // Default Enter behavior (new line) is allowed if Ctrl is not pressed
                });
            }


            if (showRegisterLink) { showRegisterLink.addEventListener('click', (e) => { e.preventDefault(); hideElement(loginForm); showElement(registerForm); clearAuthError(loginErrorMsg); }); }
            if (showLoginLink) { showLoginLink.addEventListener('click', (e) => { e.preventDefault(); hideElement(registerForm); showElement(loginForm); clearAuthError(registerErrorMsg); }); }
            if (registerButton) { registerButton.addEventListener('click', handleRegister); }
            if (loginButton) { loginButton.addEventListener('click', handleLogin); }
            if (logoutButton) { logoutButton.addEventListener('click', handleLogout); }

            if (auth) { onAuthStateChanged(auth, authStateChangedHandler); }

            if (backToMapsListButton) { backToMapsListButton.addEventListener('click', showMindmapManagementView); }

            // Node Style Panel Listeners
            if (nodeShapeSelect) nodeShapeSelect.addEventListener('change', (e) => handleNodeStyleChange('shape', e.target.value));
            if (nodeFontFamilySelect) nodeFontFamilySelect.addEventListener('change', (e) => handleNodeStyleChange('fontFamily', e.target.value));
            if (nodeFontSizeInput) nodeFontSizeInput.addEventListener('input', (e) => handleNodeStyleChange('fontSize', e.target.value)); // Use input for live changes
            if (nodeIconSelect) nodeIconSelect.addEventListener('change', (e) => handleNodeStyleChange('icon', e.target.value));
            if (nodeBgColorInput) nodeBgColorInput.addEventListener('input', (e) => handleNodeStyleChange('backgroundColor', e.target.value));
            if (nodeTextColorInput) nodeTextColorInput.addEventListener('input', (e) => handleNodeStyleChange('textColor', e.target.value));
            if (nodeBorderColorInput) nodeBorderColorInput.addEventListener('input', (e) => handleNodeStyleChange('borderColor', e.target.value));
            if (nodeLineColorInput) nodeLineColorInput.addEventListener('input', (e) => handleNodeStyleChange('lineColor', e.target.value));
            if (nodeLineDashSelect) nodeLineDashSelect.addEventListener('change', (e) => handleNodeStyleChange('lineDash', e.target.value));
            if (nodeLineWidthInput) nodeLineWidthInput.addEventListener('input', (e) => handleNodeStyleChange('lineWidth', e.target.value));


            if (createMindmapButton) { createMindmapButton.addEventListener('click', handleCreateMindmap); }

            // Context Menu item listeners
            if (ctxAddChildButton) {
                ctxAddChildButton.addEventListener('click', async () => {
                    let targetNode = rightClickedKonvaNode || selectedKonvaNode;
                    if (!targetNode || !currentMindMapId || !db) {
                        alert("Không thể thêm nút con. Vui lòng thử lại.");
                        hideContextMenu(); return;
                    }
                    await addChildNodeLogic(targetNode);
                    hideContextMenu();
                });
            }
            if (ctxEditTextButton) {
                ctxEditTextButton.addEventListener('click', () => {
                    let targetNode = rightClickedKonvaNode || selectedKonvaNode;
                    if (targetNode) {
                        editTextOnKonvaNode(targetNode); // UPDATED call
                    }
                    hideContextMenu();
                });
            }
            if (ctxViewFullContentButton) {
                ctxViewFullContentButton.addEventListener('click', () => {
                    const targetNode = rightClickedKonvaNode || selectedKonvaNode;
                    if (targetNode) {
                        const fullText = targetNode.getAttr('fullTextData');
                        if (fullText) { openNodeContentModal(fullText.substring(0,30)+"...", fullText); }
                        else { alert("Không có nội dung đầy đủ để hiển thị."); }
                    } else { alert("Vui lòng chọn một nút để xem nội dung."); }
                    hideContextMenu();
                });
            }
            if (ctxSuggestChildrenButton) {
                ctxSuggestChildrenButton.addEventListener('click', async () => {
                    let targetNodeForAI = rightClickedKonvaNode || selectedKonvaNode;
                    if (targetNodeForAI) { await suggestChildNodesWithAI(targetNodeForAI); }
                    else { alert("Vui lòng chọn một nút cha để AI gợi ý nút con."); hideContextMenu(); }
                });
            }
            if (ctxExpandNodeButton) {
                ctxExpandNodeButton.addEventListener('click', async () => {
                    let targetNodeForAI = rightClickedKonvaNode || selectedKonvaNode;
                    if (targetNodeForAI) { await expandNodeWithAI(targetNodeForAI); }
                    else { alert("Vui lòng chọn một nút để AI mở rộng ý tưởng."); hideContextMenu(); }
                });
            }
            if (ctxGenerateExamplesButton) {
                ctxGenerateExamplesButton.addEventListener('click', async () => {
                    let targetNodeForAI = rightClickedKonvaNode || selectedKonvaNode;
                    if (targetNodeForAI) { await generateExamplesWithAI(targetNodeForAI); }
                    else { alert("Vui lòng chọn một nút để AI tạo ví dụ."); hideContextMenu(); }
                });
            }
            if (ctxAskAiNodeButton) {
                ctxAskAiNodeButton.addEventListener('click', async () => {
                    let targetNodeForAI = rightClickedKonvaNode || selectedKonvaNode;
                    if (targetNodeForAI) { await askAIAboutNode(targetNodeForAI); }
                    else { alert("Vui lòng chọn một nút để đặt câu hỏi cho AI."); hideContextMenu(); }
                });
            }
            if (ctxSummarizeBranchButton) {
                ctxSummarizeBranchButton.addEventListener('click', async () => {
                    let targetNodeForSummarize = rightClickedKonvaNode || selectedKonvaNode;
                    if (targetNodeForSummarize) { await summarizeBranchWithAI(targetNodeForSummarize); }
                    else { alert("Vui lòng chọn một nút gốc của nhánh để AI tóm tắt."); hideContextMenu(); }
                });
            }
            if (ctxGenerateActionPlanButton) {
                ctxGenerateActionPlanButton.addEventListener('click', async () => {
                    let targetNodeForPlan = rightClickedKonvaNode || selectedKonvaNode;
                    if (targetNodeForPlan) { await generateActionPlanWithAI(targetNodeForPlan); }
                    else { alert("Vui lòng chọn một nút để AI tạo kế hoạch hành động."); hideContextMenu(); }
                });
            }
            if (ctxDeleteNodeButton) {
                ctxDeleteNodeButton.addEventListener('click', async () => {
                    let targetNode = rightClickedKonvaNode || selectedKonvaNode;
                    if (!targetNode || !currentMindMapId || !db) {
                         alert("Không thể xóa nút. Vui lòng thử lại."); hideContextMenu(); return;
                    }
                    await deleteNodeLogic(targetNode);
                    hideContextMenu();
                });
            }


            // Global click listener to hide context menu if clicked outside
            document.addEventListener('click', function (e) {
                if (contextMenu && !contextMenu.classList.contains('hidden')) {
                    // Check if the click is outside the context menu and not on a Konva node (which might open it again)
                    if (!contextMenu.contains(e.target) && e.target !== currentKonvaStage && !e.target.hasName?.('mindmapNodeGroup') && !e.target.getParent?.()?.hasName?.('mindmapNodeGroup')) {
                         hideContextMenu();
                    }
                }
            });

            // Toolbar button listeners
             if (addChildNodeButton) {
                addChildNodeButton.addEventListener('click', async () => {
                    if (!selectedKonvaNode) { alert("Vui lòng chọn một nút cha để thêm nút con."); return; }
                    await addChildNodeLogic(selectedKonvaNode);
                });
            }
            if (deleteNodeButton) {
                deleteNodeButton.addEventListener('click', async () => {
                    if (!selectedKonvaNode) { alert("Vui lòng chọn một nút để xóa."); return; }
                    await deleteNodeLogic(selectedKonvaNode);
                });
            }
            if(zoomInButton) { zoomInButton.addEventListener('click', () => { if (!currentKonvaStage) return; const oldScale = currentKonvaStage.scaleX(); currentKonvaStage.scale({ x: oldScale * scaleBy, y: oldScale * scaleBy }); currentKonvaStage.batchDraw(); saveCanvasState(); }); }
            if(zoomOutButton) { zoomOutButton.addEventListener('click', () => { if (!currentKonvaStage) return; const oldScale = currentKonvaStage.scaleX(); currentKonvaStage.scale({ x: oldScale / scaleBy, y: oldScale / scaleBy }); currentKonvaStage.batchDraw(); saveCanvasState(); }); }
            if(resetZoomButton) { resetZoomButton.addEventListener('click', () => { if (!currentKonvaStage) return; currentKonvaStage.scale({ x: 1, y: 1 }); currentKonvaStage.position({ x: 0, y: 0 }); currentKonvaStage.batchDraw(); saveCanvasState(); }); }


            // Resize Konva stage when window resizes
            window.addEventListener('resize', () => {
                if (currentKonvaStage && konvaContainer && konvaContainer.offsetParent !== null) { // Check if canvas is visible
                    const newWidth = konvaContainer.clientWidth;
                    const newHeight = konvaContainer.clientHeight;
                    currentKonvaStage.width(newWidth);
                    currentKonvaStage.height(newHeight);
                    // No need to redraw everything, Konva handles it or next batchDraw will.
                }
            });

        }); // End of DOMContentLoaded

    </script>
</body>
</html>
