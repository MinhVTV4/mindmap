<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S∆° ƒë·ªì t∆∞ duy MVP - Firebase AI</title>
    <script src="https://unpkg.com/konva@9.3.6/konva.min.js"></script>
    <style>
        html, body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
            color: #1c1e21;
            height: 100%;
            overflow: hidden;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #app-root {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        .container {
            width: 100%;
            padding: 0;
            background-color: #fff;
            box-shadow: none;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        #auth-section {
            padding: 20px;
            max-width: 450px;
            margin: auto;
            flex-grow: 0;
        }
        .form-container {
            max-width: 400px;
            margin: 20px auto;
            padding: 20px;
            border: 1px solid #dddfe2;
            border-radius: 8px;
        }
        .form-container h3 {
            text-align: center;
            color: #1877f2;
            margin-bottom: 20px;
        }
        input[type="email"], input[type="password"], input[type="text"] {
            width: calc(100% - 22px);
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #dddfe2;
            border-radius: 6px;
            font-size: 16px;
        }
        input[type="number"] {
            width: 50px;
            padding: 6px;
            margin-left: 3px;
            margin-right: 10px;
            border: 1px solid #dddfe2;
            border-radius: 4px;
            font-size: 13px;
            text-align: center;
        }
        select {
            padding: 6px;
            margin-left: 3px;
            margin-right: 10px;
            border: 1px solid #dddfe2;
            border-radius: 4px;
            font-size: 13px;
            background-color: white;
        }
        button {
            padding: 8px 12px;
            font-size: 14px;
            font-weight: bold;
            background-color: #1877f2;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 6px;
            transition: background-color 0.3s;
        }
        button:hover { background-color: #166fe5; }
        button.secondary { background-color: #e4e6eb; color: #4b4f56; }
        button.secondary:hover { background-color: #ccd0d5; }
        button.danger { background-color: #fa3e3e; }
        button.danger:hover { background-color: #e03030; }
        .auth-toggle { text-align: center; margin-top: 15px; }
        .auth-toggle a { color: #1877f2; text-decoration: none; font-weight: bold; }
        .auth-toggle a:hover { text-decoration: underline; }
        .error-message { color: #fa3e3e; font-size: 0.9em; margin-bottom: 10px; text-align: center; }
        #main-app-section { display: flex; flex-direction: column; height: 100%; padding: 8px; box-sizing: border-box; }
        header { display: flex; justify-content: space-between; align-items: center; padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid #dddfe2; flex-shrink: 0; }
        header h1 { color: #1c1e21; font-size: 18px; margin: 0; }
        #user-info span { margin-right: 8px; font-size: 0.85em; }
        #mindmap-management-view { display: flex; flex-direction: column; }
        #mindmap-management, #canvas-view { margin-bottom: 8px; }
        #mindmap-list-container{ flex-grow: 1; overflow-y: auto; }
        #mindmap-list { list-style: none; padding: 0; }
        #mindmap-list li { padding: 8px; border: 1px solid #dddfe2; margin-bottom: 4px; cursor: pointer; border-radius: 6px; display: flex; justify-content: space-between; align-items: center; transition: background-color 0.2s; }
        #mindmap-list li:hover { background-color: #f0f2f5; }
        #canvas-view { flex-grow: 1; display: flex; flex-direction: column; overflow: hidden; }
        #canvas-toolbar { display: flex; align-items: center; flex-wrap: wrap; padding: 6px 5px; margin-bottom: 5px; border-bottom: 1px solid #ccd0d5; flex-shrink: 0; }
        #canvas-toolbar .toolbar-section { display: flex; align-items: center; margin-right: 15px; margin-bottom: 5px; }
        #canvas-toolbar .toolbar-section:last-child { margin-right: 0; }
        #canvas-toolbar h2 { margin: 0 10px 0 0; font-size: 16px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 150px; }
        #back-to-maps-list-button { padding: 6px 8px; font-size: 18px; line-height: 1; }
        #konva-container { width: 100%; flex-grow: 1; background-color: #f7f7f7; border: 1px solid #ccd0d5; border-radius: 6px; position: relative; overflow: hidden; }
        .hidden { display: none !important; }
        .loading-indicator { text-align: center; padding: 20px; font-style: italic; color: #555; }
        #ai-loading-indicator { position: fixed; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); color: white; display: flex; justify-content: center; align-items: center; z-index: 2000; font-size: 1.2em; text-shadow: 1px 1px 2px black; }
        #node-style-panel { padding: 5px; background-color: #f9f9f9; border: 1px solid #e0e0e0; border-radius: 4px; box-sizing: border-box; display: flex; align-items: center; flex-wrap: wrap; }
        #node-style-panel h5 { margin: 0 5px 0 0; font-size: 0.85em; color: #606770; white-space: nowrap; }
        #node-style-panel label { margin-right: 2px; font-size: 0.8em; vertical-align: middle; white-space: nowrap; }
        #node-style-panel input[type="color"] { width: 22px; height: 22px; padding: 0; border: 1px solid #ccc; border-radius: 3px; vertical-align: middle; margin-right: 5px; }
        #node-style-panel input[type="number"], #node-style-panel select { width: auto; min-width: 60px; padding: 4px; font-size: 0.8em; }
        .style-group { margin-bottom: 0; display: flex; align-items: center; margin-right: 8px; }
        .style-group:last-child { margin-right: 0; }
        #context-menu { position: absolute; z-index: 1000; background-color: white; border: 1px solid #ccc; box-shadow: 2px 2px 5px rgba(0,0,0,0.2); border-radius: 4px; padding: 5px 0; }
        #context-menu ul { list-style: none; padding: 0; margin: 0; }
        #context-menu li { padding: 8px 15px; cursor: pointer; font-size: 0.9em; }
        #context-menu li:hover { background-color: #f0f0f0; }

        /* Modal Styles (Chung cho AI Response, Node Content, v√† Edit Node Text) */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 1001; padding: 15px; box-sizing: border-box;}
        .modal-content { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); width: 90%; max-width: 650px; max-height: 85vh; display: flex; flex-direction: column; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #eee; }
        .modal-header h4 { margin: 0; font-size: 1.2em; color: #333; }
        .modal-close-button { background: none; border: none; font-size: 1.6em; cursor: pointer; color: #777; line-height: 1; padding: 0 5px;}
        .modal-close-button:hover { color: #000; }
        .modal-body { overflow-y: auto; line-height: 1.6; font-size: 0.95em; }
        .modal-body p { margin-top:0; margin-bottom: 1em; }
        .modal-body strong { color: #1877f2; }
        .modal-body pre, .modal-body div[contenteditable="false"] {
            background-color: #f8f9fa;
            padding: 12px;
            border-radius: 5px;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 0.9em;
            border: 1px solid #e9ecef;
            max-height: 50vh;
            overflow-y: auto;
        }
        .modal-footer {
            display: flex;
            justify-content: flex-end;
            padding-top: 15px;
            margin-top: 15px;
            border-top: 1px solid #eee;
        }
        .modal-footer button {
            margin-left: 8px;
        }
        .read-more-indicator {
            fill: #007bff;
            cursor: pointer;
            opacity: 0.7;
        }
        .read-more-indicator:hover {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="app-root">
        <section id="auth-section" class="container">
            <div id="login-form" class="form-container">
                <h3>ƒêƒÉng nh·∫≠p S∆° ƒë·ªì t∆∞ duy</h3>
                <p id="login-error" class="error-message hidden"></p>
                <input type="email" id="login-email" placeholder="Email" required>
                <input type="password" id="login-password" placeholder="M·∫≠t kh·∫©u" required>
                <button id="login-button">ƒêƒÉng nh·∫≠p</button>
                <p class="auth-toggle">Ch∆∞a c√≥ t√†i kho·∫£n? <a href="#" id="show-register-link">ƒêƒÉng k√Ω ngay</a></p>
            </div>
            <div id="register-form" class="form-container hidden">
                <h3>ƒêƒÉng k√Ω t√†i kho·∫£n</h3>
                <p id="register-error" class="error-message hidden"></p>
                <input type="email" id="register-email" placeholder="Email" required>
                <input type="password" id="register-password" placeholder="M·∫≠t kh·∫©u (√≠t nh·∫•t 6 k√Ω t·ª±)" required>
                <button id="register-button">ƒêƒÉng k√Ω</button>
                <p class="auth-toggle">ƒê√£ c√≥ t√†i kho·∫£n? <a href="#" id="show-login-link">ƒêƒÉng nh·∫≠p</a></p>
            </div>
        </section>

        <section id="main-app-section" class="container hidden">
            <header>
                <h1 id="main-app-title">B·∫£ng ƒëi·ªÅu khi·ªÉn</h1>
                <div id="user-info">
                    <span id="user-email-display"></span>
                    <button id="logout-button" class="secondary">ƒêƒÉng xu·∫•t</button>
                </div>
            </header>

            <div id="mindmap-management-view">
                <h2>Qu·∫£n l√Ω S∆° ƒë·ªì t∆∞ duy</h2>
                <div style="margin-bottom: 15px;">
                    <input type="text" id="new-mindmap-title-input" placeholder="Nh·∫≠p ti√™u ƒë·ªÅ s∆° ƒë·ªì m·ªõi...">
                    <button id="create-mindmap-button">T·∫°o S∆° ƒë·ªì m·ªõi</button>
                </div>
                <div id="mindmap-list-container">
                    <h3>Danh s√°ch s∆° ƒë·ªì c·ªßa b·∫°n:</h3>
                    <div id="mindmap-list-loading" class="loading-indicator hidden">ƒêang t·∫£i danh s√°ch...</div>
                    <ul id="mindmap-list"></ul>
                </div>
            </div>

            <div id="canvas-view" class="hidden">
                <div id="canvas-toolbar">
                    <div class="toolbar-section">
                        <button id="back-to-maps-list-button" class="secondary" title="Quay l·∫°i danh s√°ch">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-left-short" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M12 8a.5.5 0 0 1-.5.5H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H11.5a.5.5 0 0 1 .5.5z"/>
                            </svg>
                        </button>
                        <h2 id="current-mindmap-title-display"></h2>
                    </div>
                    <div class="toolbar-section">
                        <button id="add-child-node-button" title="Th√™m n√∫t con (Click)">Th√™m N√∫t</button>
                        <button id="delete-node-button" class="danger" title="X√≥a n√∫t ƒë√£ ch·ªçn (Delete/Backspace)">X√≥a N√∫t</button>
                    </div>
                    <div class="toolbar-section">
                        <span style="font-size:0.9em; margin-right: 3px;">Zoom:</span>
                        <button id="zoom-in-button" class="secondary" title="Ph√≥ng to">+</button>
                        <button id="zoom-out-button" class="secondary" title="Thu nh·ªè">-</button>
                        <button id="reset-zoom-button" class="secondary" title="Reset zoom">Reset</button>
                    </div>
                     <div id="node-style-panel" class="toolbar-section hidden">
                        <div class="style-group">
                            <label for="node-shape-select">H√¨nh d·∫°ng:</label>
                            <select id="node-shape-select" title="H√¨nh d·∫°ng n√∫t">
                                <option value="rectangle">Ch·ªØ nh·∫≠t</option>
                                <option value="ellipse">Elip</option>
                                <option value="roundedRectangle">Bo g√≥c</option>
                            </select>
                        </div>
                         <div class="style-group">
                            <label for="node-font-family-select">Font:</label>
                            <select id="node-font-family-select" title="Font ch·ªØ n√∫t">
                                <option value="Arial">Arial</option>
                                <option value="Verdana">Verdana</option>
                                <option value="Tahoma">Tahoma</option>
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Courier New">Courier New</option>
                            </select>
                        </div>
                        <div class="style-group">
                            <label for="node-font-size-input">C·ª°:</label>
                            <input type="number" id="node-font-size-input" min="8" max="72" title="C·ª° ch·ªØ n√∫t">
                        </div>
                        <div class="style-group">
                            <label for="node-icon-select">Icon:</label>
                            <select id="node-icon-select" title="Bi·ªÉu t∆∞·ª£ng n√∫t">
                                <option value="">Kh√¥ng c√≥</option>
                                <option value="‚≠ê">‚≠ê Ng√¥i sao</option>
                                <option value="üí°">üí° B√≥ng ƒë√®n</option>
                                <option value="‚úîÔ∏è">‚úîÔ∏è Check</option>
                                <option value="‚ùó">‚ùó Ch√∫ √Ω</option>
                                <option value="‚ùì">‚ùì H·ªèi</option>
                            </select>
                        </div>
                        <div class="style-group">
                            <label for="node-bg-color">N·ªÅn:</label>
                            <input type="color" id="node-bg-color" title="M√†u n·ªÅn n√∫t">
                        </div>
                        <div class="style-group">
                            <label for="node-text-color">Ch·ªØ:</label>
                            <input type="color" id="node-text-color" title="M√†u ch·ªØ n√∫t">
                        </div>
                        <div class="style-group">
                             <label for="node-border-color">Vi·ªÅn:</label>
                            <input type="color" id="node-border-color" title="M√†u vi·ªÅn n√∫t">
                        </div>
                        <div class="style-group">
                            <label for="node-line-color">M√†u ƒë∆∞·ªùng:</label>
                            <input type="color" id="node-line-color" title="M√†u ƒë∆∞·ªùng n·ªëi t·ª´ n√∫t n√†y">
                        </div>
                         <div class="style-group">
                            <label for="node-line-dash-select">Ki·ªÉu ƒë∆∞·ªùng:</label>
                            <select id="node-line-dash-select" title="Ki·ªÉu ƒë∆∞·ªùng n·ªëi t·ª´ n√∫t n√†y">
                                <option value="solid">Li·ªÅn</option>
                                <option value="dashed">ƒê·ª©t</option>
                                <option value="dotted">Ch·∫•m</option>
                            </select>
                        </div>
                        <div class="style-group">
                            <label for="node-line-width">D√†y:</label>
                            <input type="number" id="node-line-width" min="1" max="10" title="ƒê·ªô d√†y ƒë∆∞·ªùng n·ªëi t·ª´ n√∫t n√†y">
                        </div>
                    </div>
                </div>
                <div id="konva-container-loading" class="loading-indicator hidden">ƒêang t·∫£i s∆° ƒë·ªì...</div>
                <div id="konva-container"></div>
            </div>
        </section>

        <div id="context-menu" class="hidden">
            <ul>
                <li id="ctx-add-child">Th√™m n√∫t con (Tab)</li>
                <li id="ctx-edit-text">S·ª≠a vƒÉn b·∫£n (Enter)</li>
                <li id="ctx-view-full-content">üìÑ Xem to√†n b·ªô n·ªôi dung</li>
                <li id="ctx-suggest-children">‚ú® G·ª£i √Ω n√∫t con (AI)</li>
                <li id="ctx-expand-node">üîç M·ªü r·ªông √Ω t∆∞·ªüng (AI)</li>
                <li id="ctx-generate-examples">üí° AI T·∫°o V√≠ D·ª•</li>
                <li id="ctx-ask-ai-node">üí¨ H·ªèi AI v·ªÅ n√∫t n√†y...</li>
                <li id="ctx-summarize-branch">üìÑ AI T√≥m t·∫Øt nh√°nh n√†y</li>
                <li id="ctx-generate-action-plan">üöÄ AI T·∫°o K·∫ø ho·∫°ch H√†nh ƒë·ªông</li>
                <li id="ctx-delete-node">X√≥a n√∫t & con (Delete)</li>
            </ul>
        </div>

        <div id="ai-loading-indicator" class="hidden">ƒêang x·ª≠ l√Ω AI...</div>

        <div id="ai-response-modal-overlay" class="modal-overlay hidden">
            <div class="modal-content">
                <div class="modal-header">
                    <h4 id="ai-response-modal-title">Ph·∫£n h·ªìi t·ª´ AI</h4>
                    <button id="ai-response-modal-close-button" class="modal-close-button">&times;</button>
                </div>
                <div class="modal-body" id="ai-response-modal-body"></div>
            </div>
        </div>

        <div id="node-content-modal-overlay" class="modal-overlay hidden">
            <div class="modal-content">
                <div class="modal-header">
                    <h4 id="node-content-modal-title">N·ªôi dung ƒë·∫ßy ƒë·ªß c·ªßa n√∫t</h4>
                    <button id="node-content-modal-close-button" class="modal-close-button">&times;</button>
                </div>
                <div class="modal-body" id="node-content-modal-body">
                    </div>
            </div>
        </div>

        <div id="edit-node-text-modal-overlay" class="modal-overlay hidden">
            <div class="modal-content">
                <div class="modal-header">
                    <h4 id="edit-node-text-modal-title">S·ª≠a n·ªôi dung n√∫t</h4>
                    <button id="edit-node-text-modal-close-button" class="modal-close-button">&times;</button>
                </div>
                <div class="modal-body">
                    <textarea id="edit-node-textarea" style="width: 100%; min-height: 150px; box-sizing: border-box; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 1em; line-height: 1.5;" placeholder="Nh·∫≠p n·ªôi dung cho n√∫t..."></textarea>
                </div>
                <div class="modal-footer">
                    <button id="edit-node-text-modal-cancel-button" class="secondary">H·ªßy</button>
                    <button id="edit-node-text-modal-save-button">L∆∞u thay ƒë·ªïi</button>
                </div>
            </div>
        </div>

    </div>

    <script type="module">
        // --- FIREBASE SDK IMPORTS ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-app.js";
        import {
            getAuth,
            createUserWithEmailAndPassword,
            signInWithEmailAndPassword,
            signOut,
            onAuthStateChanged
        } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-auth.js";
        import {
            getFirestore,
            collection,
            addDoc,
            doc,
            getDoc,
            getDocs,
            updateDoc,
            deleteDoc,
            query,
            where,
            serverTimestamp,
            onSnapshot,
            writeBatch
        } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-firestore.js";
        import { getAI, getGenerativeModel, GoogleAIBackend } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-ai.js";


        // --- FIREBASE CONFIGURATION (S·ª≠ d·ª•ng gi√° tr·ªã t·ª´ file g·ªëc c·ªßa b·∫°n) ---
        const firebaseConfig = {
            apiKey: "AIzaSyDLVuv2RGAJWUjhan-5oNCkGBwQZAN60aY",
            authDomain: "vocab-91599.firebaseapp.com",
            projectId: "vocab-91599",
            storageBucket: "vocab-91599.appspot.com",
            messagingSenderId: "918212044361",
            appId: "1:918212044361:web:50b7a065fe0b22b1924198"
        };

        // --- MODULE-SCOPED VARIABLES (Firebase, State, etc.) ---
        let app;
        let auth;
        let db;
        let ai;
        let generativeModel;

        let currentUser = null;
        let currentMindMapId = null;
        let currentKonvaStage = null;
        let currentKonvaLayer = null;
        let selectedKonvaNode = null;
        let mindmapNodesUnsubscribe = null;
        let allNodesDataForCurrentMap = [];
        let mindmapDataUnsubscribe = null;
        let tempCreationLine = null;
        let rightClickedKonvaNode = null;
        let isEditingText = false; // Used for modal editing state as well
        let editingNodeIdForModal = null; // Stores ID of node being edited in modal

        const DEFAULT_NODE_STYLE = {
            backgroundColor: "#e0e0e0", textColor: "#000000", borderColor: "#555555",
            shape: "rectangle",
            width: 150, minHeight: 50, padding: 10,
            cornerRadius: 5,
            fontSize: 14, fontFamily: 'Arial',
            icon: '',
            iconSize: 16,
            iconSpacing: 5,
            lineColor: "#888888", lineWidth: 3, lineDash: []
        };
        const MAX_DISPLAY_LINES_IN_NODE = 4;
        let contextMenuJustOpened = false;

        let potentiallyDraggedNode = null;
        let dragStartPointerPosition = null;
        const DRAG_THRESHOLD = 10;

        let longPressTimeoutId = null;
        let touchStartTargetNodeForContextMenu = null;
        let touchStartPointerPositionForContextMenu = null;
        const LONG_PRESS_DELAY = 750;
        const LONG_PRESS_MOVE_THRESHOLD = 10;
        let touchStartCoordsForLongPress = { x: 0, y: 0 };

        const HANDLE_RADIUS = 8;
        const HANDLE_FILL = 'rgba(0,180,0,0.7)';
        const HANDLE_STROKE = 'rgba(0,100,0,0.9)';
        const scaleBy = 1.1;


        // --- DOM ELEMENT VARIABLES ---
        let nodeStylePanel, nodeShapeSelect, nodeFontFamilySelect, nodeFontSizeInput, nodeIconSelect, nodeBgColorInput, nodeTextColorInput, nodeBorderColorInput, nodeLineColorInput, nodeLineDashSelect, nodeLineWidthInput;
        let contextMenu, ctxAddChildButton, ctxEditTextButton, ctxViewFullContentButton, ctxSuggestChildrenButton, ctxExpandNodeButton, ctxGenerateExamplesButton, ctxAskAiNodeButton, ctxSummarizeBranchButton, ctxGenerateActionPlanButton, ctxDeleteNodeButton;
        let aiLoadingIndicator, aiResponseModalOverlay, aiResponseModalTitle, aiResponseModalBody, aiResponseModalCloseButton;
        let nodeContentModalOverlay, nodeContentModalTitle, nodeContentModalBody, nodeContentModalCloseButton;
        let editNodeTextModalOverlay, editNodeTextModalTitle, editNodeTextarea, editNodeTextModalSaveButton, editNodeTextModalCancelButton, editNodeTextModalCloseButton; // NEW modal elements
        let authSection, loginForm, registerForm, loginEmailInput, loginPasswordInput, loginButton, showRegisterLink, registerEmailInput, registerPasswordInput, registerButton, showLoginLink, loginErrorMsg, registerErrorMsg;
        let mainAppSection, mainAppTitle, userEmailDisplay, logoutButton;
        let mindmapManagementView, newMindmapTitleInput, createMindmapButton, mindmapListUl, mindmapListLoading;
        let canvasView, backToMapsListButton, currentMindmapTitleDisplay, addChildNodeButton, deleteNodeButton, zoomInButton, zoomOutButton, resetZoomButton, konvaContainer, konvaContainerLoading;


        // --- UTILITY FUNCTIONS ---
        function showElement(el) { if(el) el.classList.remove('hidden'); }
        function hideElement(el) { if(el) el.classList.add('hidden'); }
        function displayAuthError(el, message) { if(el) { el.textContent = message; showElement(el); } }
        function clearAuthError(el) { if(el) { el.textContent = ''; hideElement(el); } }
        function showLoadingIndicator(message) { if (aiLoadingIndicator) { aiLoadingIndicator.textContent = message || "ƒêang x·ª≠ l√Ω AI..."; showElement(aiLoadingIndicator); } }
        function hideLoadingIndicator() { if (aiLoadingIndicator) { hideElement(aiLoadingIndicator); } }
        function hideContextMenu() { if(contextMenu) hideElement(contextMenu); contextMenuJustOpened = false; }

        function openAiResponseModal(title, userQuestion, aiAnswer) {
            if (aiResponseModalOverlay && aiResponseModalTitle && aiResponseModalBody) {
                aiResponseModalTitle.textContent = title || "Ph·∫£n h·ªìi t·ª´ AI";
                let contentHTML = '';
                if (userQuestion) {
                    const sanitizedUserQuestion = userQuestion.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                    contentHTML += `<p><strong>ƒê·∫ßu v√†o cho AI (c√≥ th·ªÉ ƒë√£ ƒë∆∞·ª£c r√∫t g·ªçn):</strong></p><pre style="max-height: 150px; overflow-y: auto; background-color: #efefef; padding: 5px; border-radius: 3px; white-space: pre-wrap; word-wrap: break-word;">${sanitizedUserQuestion}</pre>`;
                }
                const formattedAiAnswer = aiAnswer.replace(/\n/g, '<br>');
                contentHTML += `<p><strong>AI tr·∫£ l·ªùi:</strong></p><div style="background-color: #f9f9f9; padding: 10px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; font-size: 0.9em;">${formattedAiAnswer}</div>`;
                aiResponseModalBody.innerHTML = contentHTML;
                showElement(aiResponseModalOverlay);
                if (currentKonvaStage && currentKonvaStage.listening()) { currentKonvaStage.listening(false); }
            }
        }
        function closeAiResponseModal() {
            if (aiResponseModalOverlay) { hideElement(aiResponseModalOverlay); }
            if (currentKonvaStage && !currentKonvaStage.listening()) { currentKonvaStage.listening(true); }
        }
        function openNodeContentModal(nodeTitle, fullContent) {
            if (nodeContentModalOverlay && nodeContentModalTitle && nodeContentModalBody) {
                nodeContentModalTitle.textContent = `N·ªôi dung: ${nodeTitle.substring(0, 30)}${nodeTitle.length > 30 ? '...' : ''}`;
                const formattedContent = fullContent.replace(/\n/g, '<br>');
                nodeContentModalBody.innerHTML = `<div contenteditable="false" style="white-space: pre-wrap;">${formattedContent}</div>`;
                showElement(nodeContentModalOverlay);
                if (currentKonvaStage && currentKonvaStage.listening()) { currentKonvaStage.listening(false); }
            }
        }
        function closeNodeContentModal() {
            if (nodeContentModalOverlay) { hideElement(nodeContentModalOverlay); }
            if (currentKonvaStage && !currentKonvaStage.listening()) { currentKonvaStage.listening(true); }
        }

        // --- AUTHENTICATION LOGIC ---
        async function handleRegister() {
            if (!auth) {
                 displayAuthError(registerErrorMsg, "L·ªói: D·ªãch v·ª• x√°c th·ª±c ch∆∞a s·∫µn s√†ng.");
                 return;
            }
            const email = registerEmailInput.value;
            const password = registerPasswordInput.value;
            clearAuthError(registerErrorMsg);
            try {
                await createUserWithEmailAndPassword(auth, email, password);
                // No need to manually call authStateChangedHandler, onAuthStateChanged will handle it
            } catch (error) {
                console.error("Register error:", error);
                displayAuthError(registerErrorMsg, "L·ªói ƒëƒÉng k√Ω: " + error.code + " - " + error.message);
            }
        }
        async function handleLogin() {
            if (!auth) {
                 displayAuthError(loginErrorMsg, "L·ªói: D·ªãch v·ª• x√°c th·ª±c ch∆∞a s·∫µn s√†ng.");
                 return;
            }
            const email = loginEmailInput.value;
            const password = loginPasswordInput.value;
            clearAuthError(loginErrorMsg);
            try {
                await signInWithEmailAndPassword(auth, email, password);
                // No need to manually call authStateChangedHandler, onAuthStateChanged will handle it
            } catch (error) {
                console.error("Login error:", error);
                displayAuthError(loginErrorMsg, "L·ªói ƒëƒÉng nh·∫≠p: " + error.code + " - " + error.message);
            }
        }
        async function handleLogout() {
            if (!auth) return;
            try {
                await signOut(auth);
                // onAuthStateChanged will handle UI changes
                currentMindMapId = null; // Reset current map ID
                if (mindmapNodesUnsubscribe) mindmapNodesUnsubscribe(); // Unsubscribe from node listeners
                if (mindmapDataUnsubscribe) mindmapDataUnsubscribe(); // Unsubscribe from map data listeners
                window.removeEventListener('keydown', handleGlobalKeyDown); // Remove global key listener
            } catch (error) {
                console.error("Logout error:", error);
            }
        }
        function authStateChangedHandler(user) {
            if (user) {
                currentUser = user;
                if(userEmailDisplay) userEmailDisplay.textContent = `Ch√†o, ${user.email}`;
                hideElement(authSection);
                showElement(mainAppSection);
                showMindmapManagementView(); // Show the list of mind maps
                loadUserMindMaps(); // Load maps for the current user
            } else {
                currentUser = null;
                if(userEmailDisplay) userEmailDisplay.textContent = '';
                showElement(authSection);
                hideElement(mainAppSection);
                hideElement(canvasView); // Hide canvas if logged out
                if(nodeStylePanel) hideElement(nodeStylePanel);
                hideContextMenu();
                if(mindmapListUl) mindmapListUl.innerHTML = ''; // Clear mind map list
                window.removeEventListener('keydown', handleGlobalKeyDown);
            }
        }

        // --- UI VIEW MANAGEMENT ---
        function showMindmapManagementView() {
            if(mainAppTitle) mainAppTitle.textContent = "B·∫£ng ƒëi·ªÅu khi·ªÉn";
            if(mindmapManagementView) showElement(mindmapManagementView);
            if(canvasView) hideElement(canvasView);
            if(nodeStylePanel) hideElement(nodeStylePanel);
            hideContextMenu();
            currentMindMapId = null;
            selectedKonvaNode = null;
            rightClickedKonvaNode = null;
            if (mindmapNodesUnsubscribe) {
                mindmapNodesUnsubscribe();
                mindmapNodesUnsubscribe = null;
            }
            if (mindmapDataUnsubscribe) {
                mindmapDataUnsubscribe();
                mindmapDataUnsubscribe = null;
            }
            if (currentKonvaStage) {
                currentKonvaStage.destroyChildren(); // Clear canvas
                currentKonvaLayer = null; // Reset layer
            }
            window.removeEventListener('keydown', handleGlobalKeyDown); // Remove key listener for canvas
        }
        async function showCanvasView(mapId, mapTitle) {
            if(mainAppTitle) mainAppTitle.textContent = "S∆° ƒë·ªì t∆∞ duy";
            if(mindmapManagementView) hideElement(mindmapManagementView);
            if(canvasView) showElement(canvasView);
            if(currentMindmapTitleDisplay) currentMindmapTitleDisplay.textContent = mapTitle;
            currentMindMapId = mapId;
            initKonvaStage(); // Initialize Konva for the selected map
            // Listen for canvas state changes (zoom/pan)
            if (db && currentMindMapId) {
                const mapDocRef = doc(db, "mindmaps", currentMindMapId);
                if (mindmapDataUnsubscribe) mindmapDataUnsubscribe(); // Unsubscribe previous listener
                mindmapDataUnsubscribe = onSnapshot(mapDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const mapData = docSnap.data();
                        if (mapData.canvasState && currentKonvaStage) {
                            currentKonvaStage.scaleX(mapData.canvasState.scaleX || 1);
                            currentKonvaStage.scaleY(mapData.canvasState.scaleY || 1);
                            currentKonvaStage.x(mapData.canvasState.x || 0);
                            currentKonvaStage.y(mapData.canvasState.y || 0);
                            currentKonvaStage.batchDraw();
                        }
                    }
                }, (error) => {
                    console.error("Error listening to mindmap data:", error);
                });
            }
            if(nodeStylePanel) hideElement(nodeStylePanel); // Hide style panel initially
            hideContextMenu();
            window.addEventListener('keydown', handleGlobalKeyDown); // Add key listener for canvas
        }

        // --- NODE STYLE PANEL LOGIC ---
        function lineDashArrayToString(dashArray) {
            if (!dashArray || dashArray.length === 0) return 'solid';
            if (JSON.stringify(dashArray) === JSON.stringify([15, 8])) return 'dashed';
            if (JSON.stringify(dashArray) === JSON.stringify([3, 8])) return 'dotted';
            return 'solid'; // Default
        }
        function stringToLineDashArray(dashString) {
            if (dashString === 'dashed') return [15, 8];
            if (dashString === 'dotted') return [3, 8];
            return []; // Solid
        }
        function updateNodeStylePanel(nodeData) {
            if (!nodeData || !nodeData.style) {
                if(nodeStylePanel) hideElement(nodeStylePanel);
                return;
            }
            const style = nodeData.style;
            if(nodeShapeSelect) nodeShapeSelect.value = style.shape || DEFAULT_NODE_STYLE.shape;
            if(nodeFontFamilySelect) nodeFontFamilySelect.value = style.fontFamily || DEFAULT_NODE_STYLE.fontFamily;
            if(nodeFontSizeInput) nodeFontSizeInput.value = style.fontSize || DEFAULT_NODE_STYLE.fontSize;
            if(nodeIconSelect) nodeIconSelect.value = style.icon || '';
            if(nodeBgColorInput) nodeBgColorInput.value = style.backgroundColor || DEFAULT_NODE_STYLE.backgroundColor;
            if(nodeTextColorInput) nodeTextColorInput.value = style.textColor || DEFAULT_NODE_STYLE.textColor;
            if(nodeBorderColorInput) nodeBorderColorInput.value = style.borderColor || DEFAULT_NODE_STYLE.borderColor;
            if(nodeLineColorInput) nodeLineColorInput.value = style.lineColor || DEFAULT_NODE_STYLE.lineColor;
            if(nodeLineDashSelect) nodeLineDashSelect.value = lineDashArrayToString(style.lineDash);
            if(nodeLineWidthInput) nodeLineWidthInput.value = style.lineWidth || DEFAULT_NODE_STYLE.lineWidth;
            if(nodeStylePanel) showElement(nodeStylePanel);
        }
        async function handleNodeStyleChange(property, value) {
            if (!selectedKonvaNode || !db) return;
            const nodeId = selectedKonvaNode.id();
            let processedValue = value;
            if (property === 'lineWidth' || property === 'fontSize') {
                processedValue = parseInt(value, 10);
            } else if (property === 'lineDash') {
                processedValue = stringToLineDashArray(value);
            }
            try {
                const nodeRef = doc(db, "nodes", nodeId);
                const nodeSnap = await getDoc(nodeRef);
                if (nodeSnap.exists()) {
                    const existingData = nodeSnap.data();
                    const existingStyle = existingData.style || {};
                    let updatedStyle = { ...existingStyle, [property]: processedValue };

                    // Adjust cornerRadius based on shape
                    if (property === 'shape') {
                        if (processedValue === 'ellipse') {
                            // Ellipse doesn't use cornerRadius in Konva Rect, it's a separate shape
                        } else if (processedValue === 'rectangle' && !updatedStyle.cornerRadius) {
                            updatedStyle.cornerRadius = 0; // Default for sharp rectangle
                        } else if (processedValue === 'roundedRectangle' && (!updatedStyle.cornerRadius || updatedStyle.cornerRadius === 0) ) {
                            updatedStyle.cornerRadius = 5; // Default for rounded rectangle
                        }
                    }
                    await updateDoc(nodeRef, { style: updatedStyle });
                    // Real-time update will be handled by onSnapshot in renderNodesAndLines
                } else {
                    console.warn("Node not found for style update:", nodeId);
                }
            } catch (e) {
                console.error(`Error updating node style (${property}):`, e);
            }
        }
        function calculatePotentialFullHeight(text, styleConfig) {
            const style = { ...DEFAULT_NODE_STYLE, ...styleConfig };
            const textPadding = style.padding;
            let iconTextWidth = 0;
            if (style.icon && style.icon !== '') {
                const tempIconForCalc = new Konva.Text({ text: style.icon, fontSize: style.iconSize, fontFamily: style.fontFamily });
                iconTextWidth = tempIconForCalc.width() + style.iconSpacing;
            }
            const mainTextWidth = style.width - 2 * textPadding - iconTextWidth;

            // Create a temporary Konva.Text to measure actual height
            const tempText = new Konva.Text({
                text: text,
                fontSize: style.fontSize,
                fontFamily: style.fontFamily,
                width: mainTextWidth > 0 ? mainTextWidth : 0, // Ensure width is not negative
                align: 'center',
                lineHeight: 1.2 // Consistent line height
            });
            const actualTextContentHeight = tempText.height();
            // Ensure minHeight is respected and icon height is considered
            return Math.max(style.minHeight, actualTextContentHeight + 2 * textPadding, style.icon ? (style.iconSize + 2 * textPadding) : 0);
        }

        // --- FIRESTORE SERVICE LOGIC (Mind Maps) ---
        async function handleCreateMindmap() {
            if (!db) { alert("L·ªói: D·ªãch v·ª• c∆° s·ªü d·ªØ li·ªáu ch∆∞a s·∫µn s√†ng."); return; }
            const title = newMindmapTitleInput.value.trim();
            if (!title) { alert("Vui l√≤ng nh·∫≠p ti√™u ƒë·ªÅ cho s∆° ƒë·ªì."); return; }
            if (!currentUser) { alert("Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ t·∫°o s∆° ƒë·ªì."); return; }

            try {
                const mindMapData = {
                    userId: currentUser.uid,
                    title: title,
                    createdAt: serverTimestamp(),
                    lastModified: serverTimestamp(),
                    canvasState: { scaleX: 1, scaleY: 1, x: 0, y: 0 } // Initial canvas state
                };
                const mindMapDocRef = await addDoc(collection(db, "mindmaps"), mindMapData);

                // Create a default root node for the new mind map
                const rootNodeData = {
                    mapId: mindMapDocRef.id,
                    parentId: null, // Root node has no parent
                    text: "√ù t∆∞·ªüng trung t√¢m",
                    position: { x: (konvaContainer?.clientWidth || 800) / 2 - 75, y: 50 }, // Centered horizontally, near top
                    style: { ...DEFAULT_NODE_STYLE, backgroundColor: "#1877f2", textColor: "#ffffff", borderColor: "#0e5aab", shape: "ellipse", minHeight: 60 },
                    createdAt: serverTimestamp()
                };
                await addDoc(collection(db, "nodes"), rootNodeData);
                newMindmapTitleInput.value = ''; // Clear input field
            } catch (e) {
                console.error("Error creating new mind map: ", e);
                alert("L·ªói khi t·∫°o s∆° ƒë·ªì: " + e.message);
            }
        }
        async function loadUserMindMaps() {
            if (!currentUser || !db) return;
            if(mindmapListLoading) showElement(mindmapListLoading);
            if(mindmapListUl) mindmapListUl.innerHTML = ''; // Clear previous list

            try {
                const q = query(collection(db, "mindmaps"), where("userId", "==", currentUser.uid));
                // Unsubscribe from any previous listener to prevent duplicates or outdated listeners
                if (typeof window.mindmapsListenerUnsubscribe === 'function') {
                    window.mindmapsListenerUnsubscribe();
                }
                window.mindmapsListenerUnsubscribe = onSnapshot(q, (querySnapshot) => {
                    if(mindmapListUl) mindmapListUl.innerHTML = ''; // Clear list on each update
                    if (querySnapshot.empty) {
                        if(mindmapListUl) mindmapListUl.innerHTML = '<li>B·∫°n ch∆∞a c√≥ s∆° ƒë·ªì n√†o. H√£y t·∫°o m·ªôt c√°i m·ªõi!</li>';
                    }
                    querySnapshot.forEach((docSnap) => {
                        const map = { id: docSnap.id, ...docSnap.data() };
                        const li = document.createElement('li');
                        li.textContent = map.title;
                        li.dataset.mapId = map.id;
                        li.dataset.mapTitle = map.title; // Store title for easy access

                        const deleteButton = document.createElement('button');
                        deleteButton.textContent = 'X√≥a';
                        deleteButton.classList.add('danger', 'secondary'); // Use secondary for less prominent delete
                        deleteButton.style.fontSize = '0.8em';
                        deleteButton.style.padding = '5px 8px';
                        deleteButton.onclick = async (e) => {
                            e.stopPropagation(); // Prevent li click event
                            if (window.confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a s∆° ƒë·ªì "${map.title}" v√† t·∫•t c·∫£ c√°c n√∫t c·ªßa n√≥?`)) {
                                await deleteMindMap(map.id);
                            }
                        };
                        li.appendChild(deleteButton);

                        li.addEventListener('click', () => {
                            showCanvasView(map.id, map.title);
                        });
                        if(mindmapListUl) mindmapListUl.appendChild(li);
                    });
                    if(mindmapListLoading) hideElement(mindmapListLoading);
                }, (error) => {
                    console.error("Error fetching user mind maps: ", error);
                    if(mindmapListUl) mindmapListUl.innerHTML = '<li>L·ªói khi t·∫£i danh s√°ch s∆° ƒë·ªì.</li>';
                    if(mindmapListLoading) hideElement(mindmapListLoading);
                });
            } catch (e) {
                console.error("Error setting up mind map listener: ", e);
                if(mindmapListUl) mindmapListUl.innerHTML = '<li>L·ªói khi t·∫£i danh s√°ch s∆° ƒë·ªì.</li>';
                if(mindmapListLoading) hideElement(mindmapListLoading);
            }
        }
        async function deleteMindMap(mapId) {
            if (!mapId || !db) return;
            try {
                // 1. Delete all nodes associated with this mind map
                const nodesQuery = query(collection(db, "nodes"), where("mapId", "==", mapId));
                const nodesSnapshot = await getDocs(nodesQuery);
                const batch = writeBatch(db);
                nodesSnapshot.forEach(nodeDoc => {
                    batch.delete(doc(db, "nodes", nodeDoc.id));
                });
                await batch.commit();

                // 2. Delete the mind map document itself
                await deleteDoc(doc(db, "mindmaps", mapId));
                // The onSnapshot listener for mind maps will automatically update the list
            } catch (error) {
                console.error("Error deleting mind map: ", error);
                alert("L·ªói khi x√≥a s∆° ƒë·ªì: " + error.message);
            }
        }

        // --- FIRESTORE SERVICE LOGIC (Nodes) & KONVA INTEGRATION ---
        // START: Pinch to Zoom Helper functions
        function getDistance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }
        function getCenter(p1, p2) {
            return {
                x: (p1.x + p2.x) / 2,
                y: (p1.y + p2.y) / 2,
            };
        }
        let lastCenter = null;
        let lastDist = 0;
        // END: Pinch to Zoom Helper functions

        function initKonvaStage() {
            // Clear previous stage and layer if they exist
            if (currentKonvaStage) {
                currentKonvaStage.off('dragstart dragmove dragend click tap wheel contextmenu touchstart touchend touchmove mousedown mousemove mouseup'); // Remove all event listeners
                currentKonvaStage.destroy();
                currentKonvaStage = null;
            }
            if (currentKonvaLayer) {
                currentKonvaLayer.destroy();
                currentKonvaLayer = null;
            }

            const container = document.getElementById('konva-container');
            if (!container) {
                console.error("Konva container not found!");
                return;
            }

            currentKonvaStage = new Konva.Stage({
                container: 'konva-container',
                width: container.clientWidth,
                height: container.clientHeight,
                draggable: true, // Stage itself is draggable for panning
            });
            currentKonvaLayer = new Konva.Layer();
            currentKonvaStage.add(currentKonvaLayer);
            selectedKonvaNode = null; // Reset selected node

            // Mousedown/Touchstart for pinch-zoom and potential drag start
            currentKonvaStage.on('mousedown touchstart', function(e_stage) {
                let hitShape = e_stage.target;
                let determinedTargetNodeGroup = null;

                // Pinch-to-zoom: Check for two touches
                const touches = e_stage.evt.touches;
                if (touches && touches.length === 2) {
                    e_stage.evt.preventDefault(); // Prevent default browser zoom/scroll
                    currentKonvaStage.draggable(false); // Disable stage dragging during pinch
                    const touch1 = touches[0];
                    const touch2 = touches[1];
                    lastCenter = getCenter({ x: touch1.clientX, y: touch1.clientY }, { x: touch2.clientX, y: touch2.clientY });
                    lastDist = getDistance({ x: touch1.clientX, y: touch1.clientY }, { x: touch2.clientX, y: touch2.clientY });
                    potentiallyDraggedNode = null; // Ensure no node dragging during pinch
                    return; // Stop further processing for mousedown/touchstart if it's a pinch start
                }


                if (hitShape === currentKonvaStage) { // Clicked on empty stage area
                    potentiallyDraggedNode = null;
                    currentKonvaStage.draggable(true); // Ensure stage is draggable
                    clearTimeout(longPressTimeoutId); // Clear any pending long press
                    touchStartTargetNodeForContextMenu = null;
                } else { // Clicked on a shape within the stage
                    // Traverse up to find the 'mindmapNodeGroup'
                    let currentShape = hitShape;
                    while (currentShape && currentShape !== currentKonvaStage) {
                        if (currentShape.hasName && currentShape.hasName('mindmapNodeGroup')) {
                            determinedTargetNodeGroup = currentShape;
                            break;
                        }
                        if (typeof currentShape.getParent !== 'function') { // Safety check
                            determinedTargetNodeGroup = null; break;
                        }
                        currentShape = currentShape.getParent();
                    }

                    if (determinedTargetNodeGroup) { // A mindmap node was hit
                        potentiallyDraggedNode = determinedTargetNodeGroup;
                        dragStartPointerPosition = currentKonvaStage.getPointerPosition();
                        if (currentKonvaStage.isDragging()) currentKonvaStage.stopDrag(); // Stop stage drag if active
                        currentKonvaStage.draggable(false); // Disable stage dragging when a node might be dragged

                        // Long press for context menu on touch devices
                        if (e_stage.type === 'touchstart') {
                            touchStartTargetNodeForContextMenu = determinedTargetNodeGroup;
                            const touch = e_stage.evt.touches && e_stage.evt.touches[0];
                            if (touch) {
                                touchStartCoordsForLongPress = { x: touch.pageX, y: touch.pageY };
                                touchStartPointerPositionForContextMenu = { x: touch.pageX, y: touch.pageY }; // Use pageX/Y for menu position
                            } else { // Fallback if touch object is not available (should not happen for touchstart)
                                const pointerPos = currentKonvaStage.getPointerPosition() || {x:0, y:0};
                                touchStartCoordsForLongPress = pointerPos;
                                touchStartPointerPositionForContextMenu = pointerPos;
                            }

                            clearTimeout(longPressTimeoutId); // Clear previous timeout
                            longPressTimeoutId = setTimeout(() => {
                                if (touchStartTargetNodeForContextMenu) { // If still the same target after delay
                                    rightClickedKonvaNode = touchStartTargetNodeForContextMenu;
                                    // Select the node if not already selected
                                    if (!selectedKonvaNode || selectedKonvaNode.id() !== rightClickedKonvaNode.id()) {
                                        if (selectedKonvaNode) { selectedKonvaNode.findOne('.nodeShape')?.strokeWidth(1); removeCreationHandle(selectedKonvaNode); }
                                        selectedKonvaNode = rightClickedKonvaNode;
                                        selectedKonvaNode.findOne('.nodeShape')?.strokeWidth(3);
                                        const shape = selectedKonvaNode.findOne('.nodeShape');
                                        if (shape) addCreationHandle(selectedKonvaNode, shape.height());
                                        const nodeData = allNodesDataForCurrentMap.find(n => n.id === selectedKonvaNode.id());
                                        if (nodeData) updateNodeStylePanel(nodeData);
                                        currentKonvaLayer.batchDraw();
                                    }
                                    // Show context menu at touch position
                                    if (contextMenu && touchStartPointerPositionForContextMenu) {
                                        contextMenu.style.top = touchStartPointerPositionForContextMenu.y + 'px';
                                        contextMenu.style.left = touchStartPointerPositionForContextMenu.x + 'px';
                                        showElement(contextMenu);
                                        contextMenuJustOpened = true;
                                    }
                                    touchStartTargetNodeForContextMenu = null; // Reset for next long press
                                    longPressTimeoutId = null;
                                }
                            }, LONG_PRESS_DELAY);
                        }
                    } else { // Clicked on something else (e.g., a line, or an unhandled shape)
                        potentiallyDraggedNode = null;
                        currentKonvaStage.draggable(true); // Ensure stage is draggable
                        clearTimeout(longPressTimeoutId);
                        touchStartTargetNodeForContextMenu = null;
                    }
                }
            });

            // Mousemove/Touchmove for pinch-zoom and node dragging
            currentKonvaStage.on('mousemove touchmove', function(e_stage) {
                const touches = e_stage.evt.touches;

                // Pinch-to-zoom logic
                if (touches && touches.length === 2 && lastDist > 0) { // If two touches and pinch has started
                    e_stage.evt.preventDefault();
                    const touch1 = touches[0];
                    const touch2 = touches[1];
                    const newCenter = getCenter({ x: touch1.clientX, y: touch1.clientY }, { x: touch2.clientX, y: touch2.clientY });
                    const newDist = getDistance({ x: touch1.clientX, y: touch1.clientY }, { x: touch2.clientX, y: touch2.clientY });

                    const pointTo = { // Calculate mouse pointer position relative to the stage
                        x: (newCenter.x - currentKonvaStage.x()) / currentKonvaStage.scaleX(),
                        y: (newCenter.y - currentKonvaStage.y()) / currentKonvaStage.scaleX(),
                    };

                    const newScale = currentKonvaStage.scaleX() * (newDist / lastDist); // Calculate new scale

                    currentKonvaStage.scale({ x: newScale, y: newScale });

                    // Calculate new position of the stage
                    const dx = newCenter.x - lastCenter.x;
                    const dy = newCenter.y - lastCenter.y;

                    const newPos = {
                        x: newCenter.x - pointTo.x * newScale + dx,
                        y: newCenter.y - pointTo.y * newScale + dy,
                    };
                    currentKonvaStage.position(newPos);
                    currentKonvaStage.batchDraw();

                    lastDist = newDist;
                    lastCenter = newCenter;
                    return; // Stop further processing for mousemove/touchmove if it's a pinch
                }


                // Cancel long press if finger moves too much
                if (touchStartTargetNodeForContextMenu && e_stage.type === 'touchmove') {
                    const touch = e_stage.evt.touches && e_stage.evt.touches[0];
                    if (touch) {
                        const deltaX = Math.abs(touch.pageX - touchStartCoordsForLongPress.x);
                        const deltaY = Math.abs(touch.pageY - touchStartCoordsForLongPress.y);
                        if (deltaX > LONG_PRESS_MOVE_THRESHOLD || deltaY > LONG_PRESS_MOVE_THRESHOLD) {
                            clearTimeout(longPressTimeoutId); // Cancel long press
                            touchStartTargetNodeForContextMenu = null;
                        }
                    }
                }

                // Node dragging logic
                if (!potentiallyDraggedNode || !dragStartPointerPosition) {
                    return; // Not a drag operation or drag hasn't started
                }
                // For mousemove, ensure primary button is pressed (for desktop)
                if (e_stage.type === 'mousemove' && e_stage.evt.buttons !== 1) {
                    return;
                }
                const currentPointerPosition = currentKonvaStage.getPointerPosition();
                if (!currentPointerPosition) return; // Safety check
                const dx = currentPointerPosition.x - dragStartPointerPosition.x;
                const dy = currentPointerPosition.y - dragStartPointerPosition.y;

                // Only start dragging if moved beyond threshold
                if (Math.sqrt(dx * dx + dy * dy) > DRAG_THRESHOLD) {
                    if (potentiallyDraggedNode.draggable() === false) { // If not already dragging
                        potentiallyDraggedNode.draggable(true); // Make it draggable
                        potentiallyDraggedNode.startDrag(e_stage.evt); // Start Konva drag
                    }
                    clearTimeout(longPressTimeoutId); // Cancel long press if dragging starts
                    touchStartTargetNodeForContextMenu = null;
                }
            });

            // Mouseup/Touchend to reset states
            currentKonvaStage.on('mouseup touchend', function(e_stage) {
                clearTimeout(longPressTimeoutId); // Clear any pending long press
                touchStartTargetNodeForContextMenu = null;
                potentiallyDraggedNode = null; // Reset potentially dragged node
                dragStartPointerPosition = null; // Reset drag start position

                // Reset pinch zoom state
                if (lastDist > 0) { // Was pinching
                    saveCanvasState(); // Save state after pinch zoom ends
                }
                lastDist = 0;
                lastCenter = null;

                currentKonvaStage.draggable(true); // Re-enable stage dragging
            });


            currentKonvaStage.on('dragend', saveCanvasState); // For stage drag
            currentKonvaStage.on('wheel', (e) => { // For mouse wheel zoom
                e.evt.preventDefault();
                const oldScale = currentKonvaStage.scaleX();
                const pointer = currentKonvaStage.getPointerPosition();
                if (!pointer) return; // Safety check

                const mousePointTo = {
                    x: (pointer.x - currentKonvaStage.x()) / oldScale,
                    y: (pointer.y - currentKonvaStage.y()) / oldScale,
                };
                const direction = e.evt.deltaY > 0 ? -1 : 1; // Corrected direction for standard wheel behavior (up = zoom in, down = zoom out)
                let newScale;
                if (direction > 0) { // Zoom in
                     newScale = oldScale * scaleBy;
                } else { // Zoom out
                     newScale = oldScale / scaleBy;
                }

                currentKonvaStage.scale({ x: newScale, y: newScale });
                const newPos = {
                    x: pointer.x - mousePointTo.x * newScale,
                    y: pointer.y - mousePointTo.y * newScale,
                };
                currentKonvaStage.position(newPos);
                currentKonvaStage.batchDraw();
                saveCanvasState(); // Save state after zoom
            });

            currentKonvaStage.on('click tap', function(e) {
                if (e.target === currentKonvaStage) { // Clicked on empty stage area
                    if (selectedKonvaNode) { // Deselect any currently selected node
                        selectedKonvaNode.findOne('.nodeShape')?.strokeWidth(1); // Reset stroke
                        removeCreationHandle(selectedKonvaNode); // Remove creation handle
                        selectedKonvaNode = null;
                        if(nodeStylePanel) hideElement(nodeStylePanel); // Hide style panel
                        currentKonvaLayer.batchDraw();
                    }
                    hideContextMenu(); // Hide context menu if open
                }
                // Node click/tap is handled by the group's event listener
            });

            currentKonvaStage.on('contextmenu', function(e_context) {
                e_context.evt.preventDefault(); // Prevent default browser context menu
                if (e_context.evt.pointerType === 'touch') { // Ignore contextmenu from touch (handled by long press)
                    return;
                }

                let hitShape = e_context.target;
                let targetNodeGroupForContextMenu = null;
                // Traverse up to find the 'mindmapNodeGroup'
                let currentShape = hitShape;
                while (currentShape && currentShape !== currentKonvaStage) {
                    if (currentShape.hasName && currentShape.hasName('mindmapNodeGroup')) {
                        targetNodeGroupForContextMenu = currentShape;
                        break;
                    }
                    if (typeof currentShape.getParent !== 'function') { // Safety check
                        targetNodeGroupForContextMenu = null; break;
                    }
                    currentShape = currentShape.getParent();
                }

                if (targetNodeGroupForContextMenu) { // A mindmap node was right-clicked
                    rightClickedKonvaNode = targetNodeGroupForContextMenu;
                    // Select the node if not already selected
                    if (!selectedKonvaNode || selectedKonvaNode.id() !== rightClickedKonvaNode.id()) {
                        if (selectedKonvaNode) { selectedKonvaNode.findOne('.nodeShape')?.strokeWidth(1); removeCreationHandle(selectedKonvaNode); }
                        selectedKonvaNode = rightClickedKonvaNode;
                        selectedKonvaNode.findOne('.nodeShape')?.strokeWidth(3); // Highlight
                        const shape = selectedKonvaNode.findOne('.nodeShape');
                         if (shape) addCreationHandle(selectedKonvaNode, shape.height()); // Add creation handle
                        const nodeData = allNodesDataForCurrentMap.find(n => n.id === selectedKonvaNode.id());
                        if (nodeData) updateNodeStylePanel(nodeData); // Update style panel
                        currentKonvaLayer.batchDraw();
                    }
                    // Show context menu at mouse position
                    if(contextMenu) {
                        contextMenu.style.top = e_context.evt.pageY + 'px';
                        contextMenu.style.left = e_context.evt.pageX + 'px';
                        showElement(contextMenu);
                        contextMenuJustOpened = true; // Flag to prevent immediate deselection on click
                    }
                } else { // Right-clicked on empty area or non-node element
                    rightClickedKonvaNode = null;
                    hideContextMenu();
                }
            });
            loadAndListenNodesForCurrentMap(); // Load nodes for the current map
        }
        async function saveCanvasState() {
            if (!currentKonvaStage || !currentMindMapId || !db || !currentUser) return;
            try {
                const mapRef = doc(db, "mindmaps", currentMindMapId);
                await updateDoc(mapRef, {
                    "canvasState.scaleX": currentKonvaStage.scaleX(),
                    "canvasState.scaleY": currentKonvaStage.scaleY(),
                    "canvasState.x": currentKonvaStage.x(),
                    "canvasState.y": currentKonvaStage.y(),
                    lastModified: serverTimestamp() // Update last modified timestamp
                });
            } catch (error) {
                console.error("Error saving canvas state:", error);
            }
        }
        function loadAndListenNodesForCurrentMap() {
            if (!currentMindMapId || !currentKonvaLayer || !db) {
                console.warn("Cannot load nodes: Missing mapId, layer, or db connection.");
                return;
            }
            if(konvaContainerLoading) showElement(konvaContainerLoading);
            if(currentKonvaLayer) currentKonvaLayer.destroyChildren(); // Clear previous nodes
            if(currentKonvaLayer) currentKonvaLayer.draw(); // Redraw empty layer
             allNodesDataForCurrentMap = []; // Reset local cache

            const q = query(collection(db, "nodes"), where("mapId", "==", currentMindMapId));
            if (mindmapNodesUnsubscribe) mindmapNodesUnsubscribe(); // Unsubscribe from previous listener

            mindmapNodesUnsubscribe = onSnapshot(q, (querySnapshot) => {
                const nodesFromDb = [];
                querySnapshot.forEach((docSnap) => {
                    nodesFromDb.push({ id: docSnap.id, ...docSnap.data() });
                });
                allNodesDataForCurrentMap = nodesFromDb; // Update local cache
                renderNodesAndLines(allNodesDataForCurrentMap); // Re-render all nodes and lines
                if(konvaContainerLoading) hideElement(konvaContainerLoading);
            }, (error) => {
                console.error(`Error listening to nodes for map ${currentMindMapId}:`, error);
                alert("L·ªói khi t·∫£i c√°c n√∫t c·ªßa s∆° ƒë·ªì: " + error.message);
                if(konvaContainerLoading) hideElement(konvaContainerLoading);
            });
        }

        function renderNodesAndLines(nodesData) {
            if (!currentKonvaLayer) return;
            currentKonvaLayer.destroyChildren(); // Clear existing shapes
            const konvaNodeObjects = {}; // To store Konva group objects for linking

            nodesData.forEach(nodeData => {
                // Basic validation for node data
                if (!nodeData.position || typeof nodeData.position.x !== 'number' || typeof nodeData.position.y !== 'number') {
                    console.warn("Node data missing valid position, skipping:", nodeData);
                    return;
                }

                const style = { ...DEFAULT_NODE_STYLE, ...(nodeData.style || {}) };
                const fullText = nodeData.text || "";

                // Calculate available width for text considering padding and icon
                let iconWidthForCalc = 0;
                if (style.icon && style.icon !== '') {
                    const tempIcon = new Konva.Text({ text: style.icon, fontSize: style.iconSize, fontFamily: style.fontFamily });
                    iconWidthForCalc = tempIcon.width() + style.iconSpacing;
                }
                const textRenderWidth = style.width - (2 * style.padding) - iconWidthForCalc;

                // Determine text display height and if truncation is needed
                const tempTextObj = new Konva.Text({
                    text: fullText,
                    fontSize: style.fontSize,
                    fontFamily: style.fontFamily,
                    width: textRenderWidth > 0 ? textRenderWidth : 0, // Prevent negative width
                    lineHeight: 1.2, // Consistent line height for calculation
                    align: 'center'
                });
                const fullTextActualHeight = tempTextObj.height(); // Actual height of the full text

                const estimatedLineHeight = style.fontSize * 1.2;
                const maxVisibleTextHeightInNode = estimatedLineHeight * MAX_DISPLAY_LINES_IN_NODE;
                const isTextTruncated = fullTextActualHeight > maxVisibleTextHeightInNode;
                const textDisplayHeight = isTextTruncated ? maxVisibleTextHeightInNode : fullTextActualHeight;

                // Calculate shape height based on text, minHeight, and "Read more" indicator
                let shapeRenderHeight = Math.max(style.minHeight, textDisplayHeight + (2 * style.padding));

                if (isTextTruncated) {
                    const readMoreIndicatorHeight = estimatedLineHeight * 0.8; // Approximate height for "Xem th√™m"
                    // Ensure shape is tall enough for text + padding + "Read more"
                    shapeRenderHeight = Math.max(shapeRenderHeight, textDisplayHeight + (2 * style.padding) + readMoreIndicatorHeight + style.padding * 0.5);
                }

                // Create Konva Group for the node
                const group = new Konva.Group({
                    x: nodeData.position.x,
                    y: nodeData.position.y,
                    draggable: false, // Will be enabled on drag start after threshold
                    id: nodeData.id,
                    name: 'mindmapNodeGroup',
                    fullTextData: fullText // Store full text in an attribute for easy access
                });

                // Create the main shape (rectangle, ellipse, etc.)
                let shape;
                if (style.shape === 'ellipse') {
                    shape = new Konva.Ellipse({
                        x: style.width / 2, y: shapeRenderHeight / 2, // Center of ellipse
                        radiusX: style.width / 2, radiusY: shapeRenderHeight / 2,
                        fill: style.backgroundColor, stroke: style.borderColor, strokeWidth: 1, name: 'nodeShape'
                    });
                } else if (style.shape === 'roundedRectangle') {
                    shape = new Konva.Rect({
                        width: style.width, height: shapeRenderHeight,
                        fill: style.backgroundColor, stroke: style.borderColor, strokeWidth: 1,
                        cornerRadius: style.cornerRadius || 10, name: 'nodeShape' // Default cornerRadius if not specified
                    });
                } else { // Default to rectangle
                    shape = new Konva.Rect({
                        width: style.width, height: shapeRenderHeight,
                        fill: style.backgroundColor, stroke: style.borderColor, strokeWidth: 1,
                        cornerRadius: 0, name: 'nodeShape' // No corner radius for plain rectangle
                    });
                }
                group.add(shape);
                shape.moveToBottom(); // Ensure shape is behind text and icon

                // Add icon if specified
                if (style.icon && style.icon !== '') {
                    const iconObject = new Konva.Text({
                        text: style.icon, fontSize: style.iconSize, fontFamily: style.fontFamily, fill: style.textColor,
                        x: style.padding, // Position icon with padding
                        y: (shapeRenderHeight - style.iconSize) / 2, // Vertically center icon
                        listening: false, // Icon itself shouldn't capture events
                        name: 'nodeIcon'
                    });
                    group.add(iconObject);
                }

                // Create text object for display (potentially truncated)
                const textToRender = new Konva.Text({
                    text: fullText, // Initially set to full text, clipping will handle display
                    fontSize: style.fontSize, fontFamily: style.fontFamily, fill: style.textColor,
                    width: textRenderWidth > 0 ? textRenderWidth : 0, // Ensure width is not negative
                    height: textDisplayHeight, // Set to calculated display height
                    x: style.padding + iconWidthForCalc, // Position text after icon and padding
                    y: style.padding, // Position text with padding from top
                    align: 'center', // Center align text
                    verticalAlign: 'top', // Align text to the top of its bounding box
                    lineHeight: 1.2, // Consistent line height
                    listening: true, // Text should be clickable/tappable
                    name: 'nodeTextContent'
                });

                // Apply clipping if text is truncated
                if (isTextTruncated) {
                    if (typeof textToRender.clip === 'function') { // Check if clip method exists (Konva versions)
                         textToRender.clip({
                            x: 0, y: 0, // Clip relative to the text object's position
                            width: textRenderWidth, height: textDisplayHeight
                        });
                    } else { // Fallback for older Konva or if .clip() is not a function
                        console.warn(`textToRender.clip is not a function for node ${nodeData.id}. Attempting to set clip as an attribute.`);
                        try {
                            textToRender.setAttr('clip', { x: 0, y: 0, width: textRenderWidth, height: textDisplayHeight });
                        } catch (clipAttrError) {
                            console.error("Failed to set clip as attribute:", clipAttrError);
                        }
                    }

                    // Add "Read more" indicator
                     const readMoreText = new Konva.Text({
                        x: style.padding + iconWidthForCalc, // Align with main text
                        y: style.padding + textDisplayHeight + style.padding * 0.2, // Position below truncated text
                        text: '... Xem th√™m',
                        fontSize: style.fontSize * 0.8, // Smaller font for indicator
                        fill: '#007bff', // Link-like color
                        fontStyle: 'italic',
                        name: 'readMoreIndicator',
                        width: textRenderWidth, // Same width as text block for alignment
                        align: 'right' // Align to the right
                    });
                    group.add(readMoreText);
                    // Event listener for "Read more"
                    readMoreText.on('click tap', (ev) => {
                        const isPrimaryInteraction = (ev.evt.button === 0 && ev.type === 'click') || ev.type === 'tap';
                        if (isPrimaryInteraction && !contextMenuJustOpened) { // Avoid conflict with context menu
                            openNodeContentModal(nodeData.text.substring(0,30)+"...", fullText);
                        } else if (contextMenuJustOpened) {
                            contextMenuJustOpened = false; // Reset flag if context menu was just opened
                        }
                        ev.evt.cancelBubble = true; // Prevent event bubbling to the group
                    });
                }
                group.add(textToRender);

                // If text is truncated, clicking the text area itself (not just "read more") should also open the modal
                if (isTextTruncated) {
                    textToRender.on('click tap', (ev) => {
                        const isPrimaryInteraction = (ev.evt.button === 0 && ev.type === 'click') || ev.type === 'tap';
                        if (isPrimaryInteraction && !contextMenuJustOpened) {
                            openNodeContentModal(nodeData.text.substring(0,30)+"...", fullText);
                        } else if (contextMenuJustOpened) {
                            contextMenuJustOpened = false;
                        }
                        ev.evt.cancelBubble = true;
                    });
                }

                // Event listener for node drag end
                group.on('dragend', async function() {
                    if(!db) return;
                    try {
                        await updateDoc(doc(db, "nodes", this.id()), { position: { x: this.x(), y: this.y() } });
                    } catch (e) {
                        console.error("Error updating node position:", e);
                    }
                    this.draggable(false); // Disable draggable after drag ends (re-enabled on mousedown if needed)
                });

                // Event listener for node click/tap (selection)
                group.on('click tap', function(e) {
                    e.evt.cancelBubble = true; // Prevent event bubbling to the stage
                    if (isEditingText) return; // Prevent selection if modal is open
                    if (e.target.name() === 'readMoreIndicator') return; // Handled by its own listener
                    if (this.isDragging && this.isDragging()) { return; } // Don't select if it was a drag operation

                    const isPrimaryInteraction = (e.evt.button === 0 && e.type === 'click') || e.type === 'tap';

                    if (isPrimaryInteraction) {
                        if (contextMenuJustOpened) { // If context menu was just opened by this click/tap (e.g., long press)
                            contextMenuJustOpened = false; // Reset the flag
                        } else { // If it's a normal click/tap not related to context menu opening
                            const fullTextFromAttr = this.getAttr('fullTextData');
                            const hasReadMore = this.findOne('.readMoreIndicator');
                            // If node has "Read more" and the click was on the text or shape (not the indicator itself)
                            if (hasReadMore && (e.target.name() === 'nodeTextContent' || e.target.name() === 'nodeShape' || e.target === this ) ) {
                                if (e.target.name() !== 'nodeTextContent' && e.target.name() !== 'readMoreIndicator') { // Avoid double-opening if text itself was clicked
                                     openNodeContentModal(fullTextFromAttr.substring(0,30)+"...", fullTextFromAttr);
                                }
                            }
                        }
                    }

                    // Node selection logic
                    if (selectedKonvaNode && selectedKonvaNode !== this) { // Deselect previous node
                        selectedKonvaNode.findOne('.nodeShape')?.strokeWidth(1);
                        removeCreationHandle(selectedKonvaNode);
                    }
                    selectedKonvaNode = this; // Select current node
                    const shapeNode = this.findOne('.nodeShape');
                    if (shapeNode) {
                      shapeNode.strokeWidth(3); // Highlight selected node
                      addCreationHandle(this, shapeNode.height()); // Add creation handle
                    }

                    const clickedNodeData = allNodesDataForCurrentMap.find(n => n.id === this.id());
                    if (clickedNodeData) updateNodeStylePanel(clickedNodeData); // Update style panel
                    currentKonvaLayer.batchDraw(); // Redraw layer

                    // Hide context menu if a primary click occurs outside of it
                    if (isPrimaryInteraction && contextMenu && !contextMenu.classList.contains('hidden')) {
                        if (!contextMenu.contains(e.evt.target)) { // If click is outside context menu
                             hideContextMenu();
                        }
                    }
                });
                // UPDATED: Call new editTextOnKonvaNode for dblclick/dbltap
                group.on('dblclick dbltap', function() {
                    editTextOnKonvaNode(this); // Pass the group directly
                    hideContextMenu(); // Hide context menu if open
                });

                konvaNodeObjects[nodeData.id] = group; // Store Konva group for line drawing
                currentKonvaLayer.add(group);

                // If this node was previously selected, re-apply selected state
                if (selectedKonvaNode && selectedKonvaNode.id() === nodeData.id) {
                    shape.strokeWidth(3);
                    addCreationHandle(group, shape.height());
                }
            });

            // Draw lines between parent and child nodes
            nodesData.forEach(nodeData => {
                if (nodeData.parentId && konvaNodeObjects[nodeData.parentId] && konvaNodeObjects[nodeData.id]) {
                    const parentKonvaNode = konvaNodeObjects[nodeData.parentId];
                    const childKonvaNode = konvaNodeObjects[nodeData.id];
                    const parentNodeFromData = allNodesDataForCurrentMap.find(n=>n.id === nodeData.parentId); // Get parent's full data for style

                    const parentRenderedShape = parentKonvaNode.findOne('.nodeShape');
                    const childRenderedShape = childKonvaNode.findOne('.nodeShape');

                    // Ensure shapes exist before trying to get dimensions
                    if (!parentRenderedShape || !childRenderedShape) {
                        console.warn("Skipping line: parent or child shape not found for line between", nodeData.parentId, "and", nodeData.id);
                        return;
                    }

                    const parentActualHeight = parentRenderedShape.height();
                    const childActualHeight = childRenderedShape.height();
                    const parentActualWidth = parentRenderedShape.width();
                    const childActualWidth = childRenderedShape.width();

                    const parentStyle = { ...DEFAULT_NODE_STYLE, ...(parentNodeFromData?.style || {}) }; // Use parent's line style

                    const line = new Konva.Line({
                        points: [
                            parentKonvaNode.x() + parentActualWidth / 2, parentKonvaNode.y() + parentActualHeight / 2, // Center of parent
                            childKonvaNode.x() + childActualWidth / 2, childKonvaNode.y() + childActualHeight / 2    // Center of child
                        ],
                        stroke: parentStyle.lineColor,
                        strokeWidth: parentStyle.lineWidth,
                        dash: parentStyle.lineDash,
                        lineCap: 'round',
                        lineJoin: 'round',
                        name: 'connectionLine'
                    });
                    currentKonvaLayer.add(line);
                    line.moveToBottom(); // Draw lines behind nodes
                }
            });
            currentKonvaLayer.batchDraw(); // Redraw the layer with all nodes and lines
        }
        function addCreationHandle(parentNodeGroup, parentCurrentShapeHeight) {
            if (!parentNodeGroup || parentNodeGroup.findOne('.creationHandle')) return; // Don't add if exists

            const parentShapeInitial = parentNodeGroup.findOne('.nodeShape');
            if (!parentShapeInitial) {
                console.error("addCreationHandle: parentShapeInitial is undefined. Cannot add handle to node:", parentNodeGroup.id());
                return;
            }
            const shapeWidth = parentShapeInitial.width();
            // Position handle at the bottom-center of the shape
            let handleX = shapeWidth / 2;
            let handleY = parentCurrentShapeHeight; // Use the passed current height
            // Adjust for ellipse if needed (though typically a rect/roundedRect is better for this handle)
            if (parentShapeInitial.getClassName() === 'Ellipse') {
                handleX = parentShapeInitial.x(); // Ellipse x is center
                handleY = parentShapeInitial.y() + parentShapeInitial.radiusY(); // Bottom edge of ellipse
            }

            const handle = new Konva.Circle({
                x: handleX, y: handleY, radius: HANDLE_RADIUS, fill: HANDLE_FILL,
                stroke: HANDLE_STROKE, strokeWidth: 1, draggable: true, name: 'creationHandle',
                dragDistance: 3, // Minimum distance to start drag
                dragBoundFunc: function(pos) { // Keep handle within parent's local coordinate system
                    const parentAbsPos = parentNodeGroup.getAbsolutePosition();
                    return {
                        x: pos.x - parentAbsPos.x, // Convert absolute pos to relative
                        y: pos.y - parentAbsPos.y,
                    };
                }
            });
            parentNodeGroup.add(handle);
            parentNodeGroup.creationHandle = handle; // Store reference

            handle.on('dragstart', function(e) {
                e.evt.cancelBubble = true;
                if (!currentKonvaLayer || !parentNodeGroup) {
                    console.error("dragstart: currentKonvaLayer or parentNodeGroup is missing");
                    return;
                }
                const currentParentShape = parentNodeGroup.findOne('.nodeShape');
                if (!currentParentShape) {
                    console.error("dragstart: currentParentShape is undefined. parentNodeGroup ID:", parentNodeGroup.id());
                    return;
                }
                const parentNodeData = allNodesDataForCurrentMap.find(n => n.id === parentNodeGroup.id());
                const parentStyle = { ...DEFAULT_NODE_STYLE, ...(parentNodeData?.style || {}) };

                const lineColor = parentStyle.lineColor || DEFAULT_NODE_STYLE.lineColor;
                const lineWidth = parentStyle.lineWidth || DEFAULT_NODE_STYLE.lineWidth;
                let startX = currentParentShape.width() / 2;
                let startY = currentParentShape.height() / 2;
                if (currentParentShape.getClassName() === 'Ellipse') { // Adjust for ellipse center
                    startX = currentParentShape.x();
                    startY = currentParentShape.y();
                }
                tempCreationLine = new Konva.Line({
                    points: [ startX, startY, this.x(), this.y() ], // Line from parent center to handle
                    stroke: lineColor, strokeWidth: lineWidth, dash: parentStyle.lineDash || []
                });
                parentNodeGroup.add(tempCreationLine); // Add line to the same group as the handle
                currentKonvaLayer.batchDraw();
            });
            handle.on('dragmove', function(e) {
                e.evt.cancelBubble = true;
                if (tempCreationLine) {
                    const points = tempCreationLine.points();
                    points[2] = this.x(); // Update end point of the line to handle's current position
                    points[3] = this.y();
                    tempCreationLine.points(points);
                    currentKonvaLayer.batchDraw();
                }
            });
            handle.on('dragend', async function(e) {
                e.evt.cancelBubble = true;
                if (tempCreationLine) { tempCreationLine.destroy(); tempCreationLine = null; }

                if (!parentNodeGroup) {
                     console.error("dragend: parentNodeGroup is missing");
                     // Attempt to reset handle position even if parent is gone (though unlikely)
                     this.position({ x: (this.getStage()?.width() || 0) / 2, y: (this.getStage()?.height() || 0) / 2 });
                     currentKonvaLayer.batchDraw();
                     return;
                }
                const currentParentShapeForReset = parentNodeGroup.findOne('.nodeShape');
                if (!currentParentShapeForReset) {
                    console.error("dragend: currentParentShapeForReset is undefined. parentNodeGroup ID:", parentNodeGroup.id());
                    // Fallback reset position if shape is gone
                    const groupWidth = parentNodeGroup.width() || DEFAULT_NODE_STYLE.width;
                    const groupHeight = parentNodeGroup.height() || DEFAULT_NODE_STYLE.minHeight; // Use group height if shape height unknown
                    this.position({ x: groupWidth / 2, y: groupHeight });
                    currentKonvaLayer.batchDraw();
                    return;
                }

                // Calculate new node's absolute position based on handle's final position
                const handleFinalRelativeX = this.x();
                const handleFinalRelativeY = this.y();
                const parentAbsPos = parentNodeGroup.getAbsolutePosition();
                const newNodeAbsX = parentAbsPos.x + handleFinalRelativeX;
                const newNodeAbsY = parentAbsPos.y + handleFinalRelativeY;

                // Reset handle to its original position at the bottom of the parent
                let resetHandleX = currentParentShapeForReset.width() / 2;
                let resetHandleY = currentParentShapeForReset.height();
                if (currentParentShapeForReset.getClassName() === 'Ellipse') {
                    resetHandleX = currentParentShapeForReset.x();
                    resetHandleY = currentParentShapeForReset.y() + currentParentShapeForReset.radiusY();
                }
                this.position({ x: resetHandleX, y: resetHandleY });

                // Create the new child node in Firestore
                if (currentMindMapId && db && parentNodeGroup) {
                    const defaultChildWidth = 120;
                    const defaultChildMinHeight = 40;
                    const defaultChildPadding = 10;
                    const newNodeData = {
                        mapId: currentMindMapId,
                        parentId: parentNodeGroup.id(),
                        text: "N√∫t m·ªõi (k√©o)",
                        position: { // Position the new node centered at the handle's drop location
                            x: newNodeAbsX - defaultChildWidth / 2,
                            y: newNodeAbsY - defaultChildMinHeight / 2
                        },
                        style: { ...DEFAULT_NODE_STYLE, backgroundColor: "#f9f9f9", textColor: "#333333", borderColor: "#cccccc", width: defaultChildWidth, minHeight: defaultChildMinHeight, padding: defaultChildPadding, cornerRadius: 3, shape: "rectangle", icon: '' },
                        createdAt: serverTimestamp()
                    };
                    try { await addDoc(collection(db, "nodes"), newNodeData); }
                    catch (err) { console.error("Error creating child node by dragging:", err); alert("L·ªói khi t·∫°o n√∫t con: " + err.message); }
                }
                currentKonvaLayer.batchDraw();
            });
            currentKonvaLayer.batchDraw();
        }
        function removeCreationHandle(parentNodeGroup) {
            if (parentNodeGroup && parentNodeGroup.creationHandle) {
                parentNodeGroup.creationHandle.destroy();
                parentNodeGroup.creationHandle = null; // Clear reference
                currentKonvaLayer.batchDraw();
            }
        }

        // --- REVISED: Node Text Editing Logic (Using Modal) ---
        function editTextOnKonvaNode(konvaGroup) {
            if (!konvaGroup || isEditingText || !editNodeTextModalOverlay || !editNodeTextarea) {
                // console.warn("editTextOnKonvaNode: called with invalid params or already editing.");
                return;
            }

            const fullTextData = konvaGroup.getAttr('fullTextData') || "";
            const nodeShortText = (fullTextData.substring(0, 25) + (fullTextData.length > 25 ? "..." : "")) || "N√∫t kh√¥ng t√™n";

            editingNodeIdForModal = konvaGroup.id(); // Store the ID of the node being edited

            if(editNodeTextModalTitle) editNodeTextModalTitle.textContent = `S·ª≠a n·ªôi dung: ${nodeShortText}`;
            if(editNodeTextarea) {
                editNodeTextarea.value = fullTextData;
                // Dynamically adjust textarea height based on content
                const lineCount = (fullTextData.match(/\n/g) || []).length + 1; // Count newlines + 1
                const calculatedHeight = lineCount * 20 + 20; // Approx 20px per line + 20px padding/buffer
                const newTextareaHeight = Math.min(Math.max(calculatedHeight, 150), 400); // Clamp height between 150px and 400px
                editNodeTextarea.style.height = `${newTextareaHeight}px`;
                editNodeTextarea.focus();
                // editNodeTextarea.select(); // Optional: select all text when modal opens
            }

            showElement(editNodeTextModalOverlay);

            if (currentKonvaStage && currentKonvaStage.listening()) {
                currentKonvaStage.listening(false); // Disable stage interaction while modal is open
            }
            isEditingText = true; // Set editing flag
        }

        function closeEditNodeModal() {
            if (editNodeTextModalOverlay) {
                hideElement(editNodeTextModalOverlay);
            }
            if (currentKonvaStage && !currentKonvaStage.listening()) {
                currentKonvaStage.listening(true); // Re-enable stage interaction
            }
            editingNodeIdForModal = null; // Clear stored node ID
            isEditingText = false; // Reset editing flag
        }

        async function handleSaveNodeTextFromModal() {
            if (!editingNodeIdForModal || !editNodeTextarea || !db) {
                alert("L·ªói: Kh√¥ng th·ªÉ l∆∞u n·ªôi dung n√∫t. D·ªØ li·ªáu c·∫ßn thi·∫øt b·ªã thi·∫øu.");
                closeEditNodeModal();
                return;
            }
            const newFullText = editNodeTextarea.value;
            try {
                await updateDoc(doc(db, "nodes", editingNodeIdForModal), { text: newFullText });
                // Firestore onSnapshot in renderNodesAndLines will automatically trigger re-render of the node on canvas
            } catch (e) {
                console.error("Error updating node text from modal:", e);
                alert("L·ªói khi c·∫≠p nh·∫≠t n·ªôi dung n√∫t: " + e.message);
            } finally {
                closeEditNodeModal(); // Close modal whether save succeeds or fails
            }
        }


        // --- H√ÄM THU TH·∫¨P D·ªÆ LI·ªÜU NH√ÅNH ---
        function collectBranchDataRecursive(nodeId, allNodes, level, collectedTexts) {
            const node = allNodes.find(n => n.id === nodeId);
            if (!node) {
                return; // Node not found, stop recursion for this path
            }
            const indent = '    '.repeat(level); // Use spaces for indentation
            collectedTexts.push(indent + (node.text || "").trim()); // Add current node's text

            const children = allNodes.filter(n => n.parentId === nodeId); // Find direct children
            for (const child of children) {
                collectBranchDataRecursive(child.id, allNodes, level + 1, collectedTexts); // Recurse for each child
            }
        }


        // --- AI LOGIC FUNCTIONS (Function definitions) ---
        async function suggestChildNodesWithAI(parentNodeKonva) {
            if (!generativeModel || !parentNodeKonva || !currentMindMapId || !currentUser || !db) {
                alert("Ch·ª©c nƒÉng AI ch∆∞a s·∫µn s√†ng ho·∫∑c thi·∫øu th√¥ng tin c·∫ßn thi·∫øt.");
                hideContextMenu(); return;
            }
            const parentNodeId = parentNodeKonva.id();
            const parentNodeData = allNodesDataForCurrentMap.find(n => n.id === parentNodeId);
            if (!parentNodeData) { alert("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu n√∫t cha."); hideContextMenu(); return; }

            const parentText = parentNodeData.text;
            const prompt = `Cho m·ªôt n√∫t s∆° ƒë·ªì t∆∞ duy v·ªõi n·ªôi dung l√† "${parentText}", h√£y g·ª£i √Ω 3 √Ω t∆∞·ªüng ng·∫Øn g·ªçn (kho·∫£ng 2-5 t·ª´ m·ªói √Ω t∆∞·ªüng) cho c√°c n√∫t con li√™n quan tr·ª±c ti·∫øp. M·ªói √Ω t∆∞·ªüng tr√™n m·ªôt d√≤ng ri√™ng bi·ªát. Kh√¥ng s·ª≠ d·ª•ng ƒë√°nh s·ªë, g·∫°ch ƒë·∫ßu d√≤ng hay b·∫•t k·ª≥ k√Ω t·ª± ƒë·∫∑c bi·ªát n√†o ·ªü ƒë·∫ßu d√≤ng.`;

            showLoadingIndicator("AI ƒëang t·∫°o g·ª£i √Ω...");
            hideContextMenu();
            try {
                const result = await generativeModel.generateContent(prompt);
                const response = result.response;
                const suggestionsText = response.text();
                const suggestions = suggestionsText.split('\n').map(s => s.trim()).filter(s => s.length > 0 && s.length < 50); // Filter and trim suggestions

                if (suggestions.length > 0) {
                    const batch = writeBatch(db);
                    let startX = parentNodeKonva.x();
                    let startY = parentNodeKonva.y();
                    const parentShape = parentNodeKonva.findOne('.nodeShape');
                    const parentWidth = parentShape?.width() || DEFAULT_NODE_STYLE.width;
                    const parentHeight = parentShape?.height() || DEFAULT_NODE_STYLE.minHeight;

                    // Position new nodes below and slightly offset from parent
                    startX += parentWidth / 4; // Offset a bit to the right
                    startY += parentHeight + 30; // Below the parent
                    const yOffsetIncrement = (DEFAULT_NODE_STYLE.minHeight || 50) + 20; // Spacing between new nodes

                    suggestions.slice(0, 5).forEach((suggestion, index) => { // Limit to 5 suggestions
                        const newNodeId = doc(collection(db, "nodes")).id; // Generate new ID locally
                        const newNodeData = {
                            mapId: currentMindMapId,
                            parentId: parentNodeId,
                            text: suggestion,
                            position: { x: startX, y: startY + (index * yOffsetIncrement) },
                            style: { ...DEFAULT_NODE_STYLE, backgroundColor: "#E3F2FD", textColor: "#0D47A1", borderColor: "#90CAF9", shape: "roundedRectangle", cornerRadius: 8, width: 130, minHeight: 40, fontSize: 13, icon: '' },
                            createdAt: serverTimestamp()
                        };
                        const nodeRef = doc(db, "nodes", newNodeId);
                        batch.set(nodeRef, newNodeData);
                    });
                    await batch.commit();
                } else {
                    alert("AI kh√¥ng th·ªÉ ƒë∆∞a ra g·ª£i √Ω n√†o ph√π h·ª£p v√†o l√∫c n√†y.");
                }
            } catch (error) {
                console.error("Error calling Gemini API (suggestChildNodesWithAI):", error);
                let userMessage = "L·ªói khi AI g·ª£i √Ω n√∫t con: " + error.message;
                if (error.message?.includes("API key not valid")) { userMessage += "\nVui l√≤ng ki·ªÉm tra l·∫°i thi·∫øt l·∫≠p API Key trong Firebase Console cho Gemini API."; }
                else if (error.message?.includes("429") || error.message?.toLowerCase().includes("quota")) { userMessage = "B·∫°n ƒë√£ g·ª≠i qu√° nhi·ªÅu y√™u c·∫ßu t·ªõi AI ho·∫∑c ƒë√£ h·∫øt h·∫°n ng·∫°ch. Vui l√≤ng th·ª≠ l·∫°i sau √≠t ph√∫t."; }
                else if (error.message?.toLowerCase().includes("billing")){ userMessage = "C√≥ v·∫•n ƒë·ªÅ v·ªõi c√†i ƒë·∫∑t thanh to√°n cho d·ª± √°n Firebase c·ªßa b·∫°n. Vui l√≤ng ki·ªÉm tra trong Google Cloud Console."; }
                else if (error.message?.toLowerCase().includes("model not found")){ userMessage = "Model AI kh√¥ng ƒë∆∞·ª£c t√¨m th·∫•y. Vui l√≤ng ki·ªÉm tra l·∫°i t√™n model ƒë√£ c·∫•u h√¨nh.";}
                else if (error.message?.toLowerCase().includes("candidate.safetyRatings")){ userMessage = "Ph·∫£n h·ªìi t·ª´ AI b·ªã ch·∫∑n do v·∫•n ƒë·ªÅ an to√†n n·ªôi dung.";}
                alert(userMessage);
            } finally {
                hideLoadingIndicator();
            }
        }
        async function expandNodeWithAI(targetNodeKonva) {
            if (!generativeModel || !targetNodeKonva || !currentMindMapId || !currentUser || !db) {
                alert("Ch·ª©c nƒÉng AI ch∆∞a s·∫µn s√†ng ho·∫∑c thi·∫øu th√¥ng tin n√∫t.");
                hideContextMenu(); return;
            }
            const targetNodeId = targetNodeKonva.id();
            const targetNodeData = allNodesDataForCurrentMap.find(n => n.id === targetNodeId);
            if (!targetNodeData) { alert("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho n√∫t ƒë√£ ch·ªçn."); hideContextMenu(); return; }

            const currentText = targetNodeData.text;
            const prompt = `V·ªõi √Ω t∆∞·ªüng ch√≠nh l√† "${currentText}", h√£y vi·∫øt m·ªôt ƒëo·∫°n vƒÉn b·∫£n chi ti·∫øt h∆°n (kho·∫£ng 3-5 c√¢u) ƒë·ªÉ gi·∫£i th√≠ch, l√†m r√µ ho·∫∑c m·ªü r·ªông √Ω t∆∞·ªüng n√†y. Gi·ªØ vƒÉn phong m·∫°ch l·∫°c v√† t·∫≠p trung v√†o ch·ªß ƒë·ªÅ.`;

            showLoadingIndicator("AI ƒëang m·ªü r·ªông √Ω t∆∞·ªüng...");
            hideContextMenu();
            try {
                const result = await generativeModel.generateContent(prompt);
                const response = result.response;
                const expandedText = response.text().trim();

                if (expandedText && expandedText !== currentText) {
                    const nodeRef = doc(db, "nodes", targetNodeId);
                    await updateDoc(nodeRef, { text: expandedText });
                    // Firestore onSnapshot will re-render the node
                } else if (expandedText === currentText) {
                    alert("AI kh√¥ng t√¨m th·∫•y c√°ch m·ªü r·ªông th√™m cho √Ω t∆∞·ªüng n√†y.");
                }
                else {
                    alert("AI kh√¥ng th·ªÉ m·ªü r·ªông √Ω t∆∞·ªüng v√†o l√∫c n√†y.");
                }
            } catch (error) {
                console.error("Error calling Gemini API (expandNodeWithAI):", error);
                let userMessage = "L·ªói khi AI m·ªü r·ªông √Ω t∆∞·ªüng: " + error.message;
                if (error.message?.includes("API key not valid")) { userMessage += "\nVui l√≤ng ki·ªÉm tra l·∫°i thi·∫øt l·∫≠p API Key trong Firebase Console cho Gemini API."; }
                else if (error.message?.includes("429") || error.message?.toLowerCase().includes("quota")) { userMessage = "B·∫°n ƒë√£ g·ª≠i qu√° nhi·ªÅu y√™u c·∫ßu t·ªõi AI ho·∫∑c ƒë√£ h·∫øt h·∫°n ng·∫°ch. Vui l√≤ng th·ª≠ l·∫°i sau √≠t ph√∫t."; }
                else if (error.message?.toLowerCase().includes("billing")){ userMessage = "C√≥ v·∫•n ƒë·ªÅ v·ªõi c√†i ƒë·∫∑t thanh to√°n cho d·ª± √°n Firebase c·ªßa b·∫°n. Vui l√≤ng ki·ªÉm tra trong Google Cloud Console."; }
                else if (error.message?.toLowerCase().includes("model not found")){ userMessage = "Model AI kh√¥ng ƒë∆∞·ª£c t√¨m th·∫•y. Vui l√≤ng ki·ªÉm tra l·∫°i t√™n model ƒë√£ c·∫•u h√¨nh.";}
                else if (error.message?.toLowerCase().includes("candidate.safetyRatings")){ userMessage = "Ph·∫£n h·ªìi t·ª´ AI b·ªã ch·∫∑n do v·∫•n ƒë·ªÅ an to√†n n·ªôi dung.";}
                alert(userMessage);
            } finally {
                hideLoadingIndicator();
            }
        }
        async function generateExamplesWithAI(targetNodeKonva) {
             if (!generativeModel || !targetNodeKonva || !currentMindMapId || !currentUser || !db) {
                alert("Ch·ª©c nƒÉng AI ch∆∞a s·∫µn s√†ng ho·∫∑c thi·∫øu th√¥ng tin n√∫t.");
                hideContextMenu(); return;
            }
            const targetNodeId = targetNodeKonva.id();
            const targetNodeData = allNodesDataForCurrentMap.find(n => n.id === targetNodeId);
            if (!targetNodeData) { alert("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho n√∫t ƒë√£ ch·ªçn."); hideContextMenu(); return; }

            const currentText = targetNodeData.text;
            const prompt = `Cho ch·ªß ƒë·ªÅ sau: "${currentText}", h√£y t·∫°o ra 2 ho·∫∑c 3 v√≠ d·ª• c·ª• th·ªÉ ƒë·ªÉ minh h·ªça cho ch·ªß ƒë·ªÅ n√†y. M·ªói v√≠ d·ª• tr√™n m·ªôt d√≤ng ri√™ng bi·ªát. Kh√¥ng d√πng ƒë√°nh s·ªë hay g·∫°ch ƒë·∫ßu d√≤ng. C√°c v√≠ d·ª• n√™n ng·∫Øn g·ªçn v√† d·ªÖ hi·ªÉu.`;

            showLoadingIndicator("AI ƒëang t·∫°o v√≠ d·ª•...");
            hideContextMenu();
            try {
                const result = await generativeModel.generateContent(prompt);
                const response = result.response;
                const examplesText = response.text().trim();
                const examples = examplesText.split('\n').map(ex => ex.trim()).filter(ex => ex.length > 0 && ex.length < 150); // Filter and trim examples

                if (examples.length > 0) {
                    const batch = writeBatch(db);
                    let startX = targetNodeKonva.x();
                    let startY = targetNodeKonva.y();
                    const parentShape = targetNodeKonva.findOne('.nodeShape');
                    const parentWidth = parentShape?.width() || DEFAULT_NODE_STYLE.width;
                    const parentHeight = parentShape?.height() || DEFAULT_NODE_STYLE.minHeight;

                    startX += parentWidth / 3; // Offset for new example nodes
                    startY += parentHeight + 35;
                    const yOffsetIncrement = (DEFAULT_NODE_STYLE.minHeight || 50) + 20;

                    examples.slice(0, 3).forEach((example, index) => { // Limit to 3 examples
                        const newNodeId = doc(collection(db, "nodes")).id;
                        const exampleNodeStyle = { ...DEFAULT_NODE_STYLE, backgroundColor: "#E8F5E9", textColor: "#2E7D32", borderColor: "#A5D6A7", shape: "roundedRectangle", cornerRadius: 7, width: 160, minHeight: 40, fontSize: 13, icon: 'üí°' };
                        const newNodeData = {
                            mapId: currentMindMapId,
                            parentId: targetNodeId,
                            text: `V√≠ d·ª•: ${example}`,
                            position: { x: startX + (index * 10), y: startY + (index * yOffsetIncrement) }, // Stagger positions slightly
                            style: exampleNodeStyle,
                            createdAt: serverTimestamp()
                        };
                        const nodeRef = doc(db, "nodes", newNodeId);
                        batch.set(nodeRef, newNodeData);
                    });
                    await batch.commit();
                } else {
                    alert("AI kh√¥ng th·ªÉ t·∫°o v√≠ d·ª• n√†o ph√π h·ª£p v√†o l√∫c n√†y.");
                }
            } catch (error) {
                console.error("Error calling Gemini API (generateExamplesWithAI):", error);
                let userMessage = "L·ªói khi AI t·∫°o v√≠ d·ª•: " + error.message;
                if (error.message?.includes("API key not valid")) { userMessage += "\nVui l√≤ng ki·ªÉm tra l·∫°i thi·∫øt l·∫≠p API Key trong Firebase Console cho Gemini API."; }
                else if (error.message?.includes("429") || error.message?.toLowerCase().includes("quota")) { userMessage = "B·∫°n ƒë√£ g·ª≠i qu√° nhi·ªÅu y√™u c·∫ßu t·ªõi AI ho·∫∑c ƒë√£ h·∫øt h·∫°n ng·∫°ch. Vui l√≤ng th·ª≠ l·∫°i sau √≠t ph√∫t."; }
                else if (error.message?.toLowerCase().includes("billing")){ userMessage = "C√≥ v·∫•n ƒë·ªÅ v·ªõi c√†i ƒë·∫∑t thanh to√°n cho d·ª± √°n Firebase c·ªßa b·∫°n. Vui l√≤ng ki·ªÉm tra trong Google Cloud Console."; }
                else if (error.message?.toLowerCase().includes("model not found")){ userMessage = "Model AI kh√¥ng ƒë∆∞·ª£c t√¨m th·∫•y. Vui l√≤ng ki·ªÉm tra l·∫°i t√™n model ƒë√£ c·∫•u h√¨nh.";}
                else if (error.message?.toLowerCase().includes("candidate.safetyRatings")){ userMessage = "Ph·∫£n h·ªìi t·ª´ AI b·ªã ch·∫∑n do v·∫•n ƒë·ªÅ an to√†n n·ªôi dung.";}
                alert(userMessage);
            } finally {
                hideLoadingIndicator();
            }
        }
        async function askAIAboutNode(targetNodeKonva) {
            if (!generativeModel || !targetNodeKonva || !currentMindMapId || !currentUser || !db) {
                alert("Ch·ª©c nƒÉng AI ch∆∞a s·∫µn s√†ng ho·∫∑c thi·∫øu th√¥ng tin n√∫t.");
                hideContextMenu(); return;
            }
            const targetNodeId = targetNodeKonva.id();
            const targetNodeData = allNodesDataForCurrentMap.find(n => n.id === targetNodeId);
            if (!targetNodeData) { alert("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho n√∫t ƒë√£ ch·ªçn."); hideContextMenu(); return; }

            const nodeTextContext = targetNodeData.text;
            const userQuestion = window.prompt(`H·ªèi AI v·ªÅ n·ªôi dung c·ªßa n√∫t: "${nodeTextContext}"\nNh·∫≠p c√¢u h·ªèi c·ªßa b·∫°n:`, "");

            if (!userQuestion || userQuestion.trim() === "") {
                hideContextMenu(); return; // User cancelled or entered nothing
            }

            const prompt = `N·ªôi dung c·ªßa m·ªôt n√∫t trong s∆° ƒë·ªì t∆∞ duy l√†: "${nodeTextContext}".\n\nNg∆∞·ªùi d√πng c√≥ c√¢u h·ªèi sau v·ªÅ n√∫t n√†y: "${userQuestion.trim()}"\n\nH√£y tr·∫£ l·ªùi c√¢u h·ªèi ƒë√≥ m·ªôt c√°ch ng·∫Øn g·ªçn v√† s√∫c t√≠ch, t·∫≠p trung v√†o ng·ªØ c·∫£nh ƒë∆∞·ª£c cung c·∫•p t·ª´ n√∫t.`;
            showLoadingIndicator("AI ƒëang tr·∫£ l·ªùi c√¢u h·ªèi...");
            hideContextMenu();
            try {
                const result = await generativeModel.generateContent(prompt);
                const response = result.response;
                const aiAnswer = response.text().trim();

                if (aiAnswer) {
                    openAiResponseModal(`H·ªèi AI v·ªÅ: "${nodeTextContext.substring(0,30)}..."`, userQuestion.trim(), aiAnswer);
                }
                else {
                    openAiResponseModal(`H·ªèi AI v·ªÅ: "${nodeTextContext.substring(0,30)}..."`, userQuestion.trim(), "AI kh√¥ng th·ªÉ ƒë∆∞a ra c√¢u tr·∫£ l·ªùi v√†o l√∫c n√†y.");
                }
            } catch (error) {
                console.error("Error calling Gemini API (askAIAboutNode):", error);
                let userMessage = "L·ªói khi AI tr·∫£ l·ªùi c√¢u h·ªèi: " + error.message;
                if (error.message?.includes("API key not valid")) { userMessage += "\nVui l√≤ng ki·ªÉm tra l·∫°i thi·∫øt l·∫≠p API Key trong Firebase Console cho Gemini API."; }
                else if (error.message?.includes("429") || error.message?.toLowerCase().includes("quota")) { userMessage = "B·∫°n ƒë√£ g·ª≠i qu√° nhi·ªÅu y√™u c·∫ßu t·ªõi AI ho·∫∑c ƒë√£ h·∫øt h·∫°n ng·∫°ch. Vui l√≤ng th·ª≠ l·∫°i sau √≠t ph√∫t."; }
                else if (error.message?.toLowerCase().includes("billing")){ userMessage = "C√≥ v·∫•n ƒë·ªÅ v·ªõi c√†i ƒë·∫∑t thanh to√°n cho d·ª± √°n Firebase c·ªßa b·∫°n. Vui l√≤ng ki·ªÉm tra trong Google Cloud Console."; }
                else if (error.message?.toLowerCase().includes("model not found")){ userMessage = "Model AI kh√¥ng ƒë∆∞·ª£c t√¨m th·∫•y. Vui l√≤ng ki·ªÉm tra l·∫°i t√™n model ƒë√£ c·∫•u h√¨nh.";}
                else if (error.message?.toLowerCase().includes("candidate.safetyRatings")){ userMessage = "Ph·∫£n h·ªìi t·ª´ AI b·ªã ch·∫∑n do v·∫•n ƒë·ªÅ an to√†n n·ªôi dung.";}
                openAiResponseModal("L·ªói AI", userQuestion.trim(), userMessage);
            } finally {
                hideLoadingIndicator();
            }
        }

        async function summarizeBranchWithAI(targetNodeKonva) {
            if (!generativeModel || !targetNodeKonva || !currentMindMapId || !currentUser || !db) {
                alert("Ch·ª©c nƒÉng AI ch∆∞a s·∫µn s√†ng ho·∫∑c kh√¥ng c√≥ n√∫t n√†o ƒë∆∞·ª£c ch·ªçn.");
                hideContextMenu(); return;
            }
            const rootNodeId = targetNodeKonva.id();
            const rootNodeData = allNodesDataForCurrentMap.find(n => n.id === rootNodeId);
            if (!rootNodeData) {
                alert("Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho n√∫t g·ªëc c·ªßa nh√°nh.");
                hideContextMenu(); return;
            }

            showLoadingIndicator("AI ƒëang chu·∫©n b·ªã d·ªØ li·ªáu ƒë·ªÉ t√≥m t·∫Øt...");
            hideContextMenu();

            const branchTextsArray = [];
            collectBranchDataRecursive(rootNodeId, allNodesDataForCurrentMap, 0, branchTextsArray);

            if (branchTextsArray.length === 0) {
                alert("Kh√¥ng c√≥ d·ªØ li·ªáu vƒÉn b·∫£n trong nh√°nh n√†y ƒë·ªÉ t√≥m t·∫Øt.");
                hideLoadingIndicator(); return;
            }

            const branchContentForPrompt = branchTextsArray.join('\n');
            const maxContentLength = 15000; // Adjust as needed, consider token limits for the model
            let truncatedContent = branchContentForPrompt;
            let isTruncated = false;
            if (branchContentForPrompt.length > maxContentLength) {
                console.warn("N·ªôi dung nh√°nh qu√° d√†i, ƒë√£ ƒë∆∞·ª£c c·∫Øt b·ªõt ƒë·ªÉ g·ª≠i cho AI.");
                truncatedContent = branchContentForPrompt.substring(0, maxContentLength) + "\n... (n·ªôi dung ƒë√£ ƒë∆∞·ª£c c·∫Øt b·ªõt do qu√° d√†i)";
                isTruncated = true;
            }

            const prompt = `B·∫°n l√† m·ªôt tr·ª£ l√Ω AI xu·∫•t s·∫Øc, chuy√™n v·ªÅ ph√¢n t√≠ch v√† t√≥m t·∫Øt th√¥ng tin t·ª´ s∆° ƒë·ªì t∆∞ duy.
D∆∞·ªõi ƒë√¢y l√† n·ªôi dung c·ªßa m·ªôt nh√°nh trong s∆° ƒë·ªì t∆∞ duy, ƒë∆∞·ª£c tr√¨nh b√†y theo c·∫•u tr√∫c ph√¢n c·∫•p (c√°c m·ª•c con ƒë∆∞·ª£c th·ª•t ƒë·∫ßu d√≤ng t∆∞∆°ng ·ª©ng v·ªõi c·∫•p ƒë·ªô c·ªßa ch√∫ng trong s∆° ƒë·ªì):
---
${truncatedContent}
---
${isTruncated ? "\L∆ØU √ù: N·ªôi dung tr√™n c√≥ th·ªÉ ƒë√£ ƒë∆∞·ª£c r√∫t g·ªçn do gi·ªõi h·∫°n ƒë·ªô d√†i.\n" : ""}
Nhi·ªám v·ª• c·ªßa b·∫°n l√† t·∫°o m·ªôt b·∫£n t√≥m t·∫Øt m·∫°ch l·∫°c, s√∫c t√≠ch v√† ch√≠nh x√°c (kho·∫£ng 3 ƒë·∫øn 7 c√¢u vƒÉn, ho·∫∑c nhi·ªÅu h∆°n m·ªôt ch√∫t n·∫øu c·∫ßn thi·∫øt ƒë·ªÉ bao qu√°t √Ω ch√≠nh) v·ªÅ nh√°nh s∆° ƒë·ªì t∆∞ duy n√†y. B·∫£n t√≥m t·∫Øt c·∫ßn:
1. N√™u b·∫≠t ƒë∆∞·ª£c √Ω t∆∞·ªüng ho·∫∑c ch·ªß ƒë·ªÅ ch√≠nh c·ªßa n√∫t g·ªëc.
2. ƒê·ªÅ c·∫≠p ƒë·∫øn c√°c ch·ªß ƒë·ªÅ con ho·∫∑c c√°c kh√≠a c·∫°nh quan tr·ªçng nh·∫•t ƒë∆∞·ª£c ph√°t tri·ªÉn trong nh√°nh.
3. Ch·ªâ ra ƒë∆∞·ª£c m·ªëi quan h·ªá logic ch√≠nh y·∫øu ho·∫∑c d√≤ng ch·∫£y √Ω t∆∞·ªüng trong nh√°nh (n·∫øu c√≥).
4. S·ª≠ d·ª•ng ng√¥n ng·ªØ r√µ r√†ng, d·ªÖ hi·ªÉu.
H√£y cung c·∫•p b·∫£n t√≥m t·∫Øt d∆∞·ªõi d·∫°ng m·ªôt ƒëo·∫°n vƒÉn b·∫£n duy nh·∫•t.`;

            showLoadingIndicator("AI ƒëang t√≥m t·∫Øt nh√°nh...");
            try {
                const result = await generativeModel.generateContent(prompt);
                const response = result.response;
                const summaryText = response.text().trim();
                const rootNodeTextPreview = (rootNodeData.text || "Kh√¥ng c√≥ ti√™u ƒë·ªÅ").substring(0, 30) + ((rootNodeData.text || "").length > 30 ? "..." : "");

                if (summaryText) {
                    // Create a new node as a child of the summarized node to display the summary
                    const parentShape = targetNodeKonva.findOne('.nodeShape');
                    const parentHeight = parentShape ? parentShape.height() : DEFAULT_NODE_STYLE.minHeight;
                    const parentWidth = parentShape ? parentShape.width() : DEFAULT_NODE_STYLE.width;


                    const newNodeData = {
                        mapId: currentMindMapId,
                        parentId: rootNodeId, // Child of the node that was summarized
                        text: `üìÑ T√≥m t·∫Øt nh√°nh:\n${summaryText}`,
                        position: {
                            x: targetNodeKonva.x() + parentWidth / 4 + 10, // Position it near the parent
                            y: targetNodeKonva.y() + parentHeight + 35
                        },
                        style: {
                            ...DEFAULT_NODE_STYLE,
                            backgroundColor: "#FFFDE7", // Light yellow for summary
                            textColor: "#4E342E", // Dark brown text
                            borderColor: "#FFD54F", // Amber border
                            shape: "roundedRectangle",
                            cornerRadius: 6,
                            width: 250, // Wider for summary
                            minHeight: 70,
                            fontSize: 13,
                            icon: 'üìÑ'
                        },
                        createdAt: serverTimestamp()
                    };
                    await addDoc(collection(db, "nodes"), newNodeData);
                    alert(`AI ƒë√£ t·∫°o m·ªôt n√∫t t√≥m t·∫Øt con cho nh√°nh "${rootNodeTextPreview}".`);

                } else {
                     openAiResponseModal(
                        `AI T√≥m t·∫Øt nh√°nh: "${rootNodeTextPreview}"`,
                        truncatedContent, // Show what was sent to AI
                        "AI kh√¥ng th·ªÉ t·∫°o t√≥m t·∫Øt cho nh√°nh n√†y v√†o l√∫c n√†y. Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c ki·ªÉm tra n·ªôi dung nh√°nh."
                    );
                }
            } catch (error) {
                console.error("Error calling Gemini API (summarizeBranchWithAI):", error);
                let userMessage = "L·ªói khi AI t√≥m t·∫Øt nh√°nh: " + error.message;
                 if (error.message?.includes("API key not valid")) { userMessage += "\nVui l√≤ng ki·ªÉm tra l·∫°i thi·∫øt l·∫≠p API Key trong Firebase Console cho Gemini API."; }
                else if (error.message?.includes("429") || error.message?.toLowerCase().includes("quota")) { userMessage = "B·∫°n ƒë√£ g·ª≠i qu√° nhi·ªÅu y√™u c·∫ßu t·ªõi AI ho·∫∑c ƒë√£ h·∫øt h·∫°n ng·∫°ch. Vui l√≤ng th·ª≠ l·∫°i sau √≠t ph√∫t."; }
                else if (error.message?.toLowerCase().includes("billing")){ userMessage = "C√≥ v·∫•n ƒë·ªÅ v·ªõi c√†i ƒë·∫∑t thanh to√°n cho d·ª± √°n Firebase c·ªßa b·∫°n. Vui l√≤ng ki·ªÉm tra trong Google Cloud Console."; }
                else if (error.message?.toLowerCase().includes("model not found")){ userMessage = "Model AI kh√¥ng ƒë∆∞·ª£c t√¨m th·∫•y. Vui l√≤ng ki·ªÉm tra l·∫°i t√™n model ƒë√£ c·∫•u h√¨nh.";}
                else if (error.message?.toLowerCase().includes("candidate.safetyRatings")){ userMessage = "Ph·∫£n h·ªìi t·ª´ AI b·ªã ch·∫∑n do v·∫•n ƒë·ªÅ an to√†n n·ªôi dung. N·ªôi dung nh√°nh c√≥ th·ªÉ ch·ª©a t·ª´ kh√≥a nh·∫°y c·∫£m.";}
                openAiResponseModal( `L·ªói AI khi t√≥m t·∫Øt nh√°nh`, truncatedContent, userMessage );
            } finally {
                hideLoadingIndicator();
            }
        }
        async function generateActionPlanWithAI(targetNodeKonva) {
            if (!generativeModel || !targetNodeKonva || !currentMindMapId || !currentUser || !db) {
                alert("Ch·ª©c nƒÉng AI ch∆∞a s·∫µn s√†ng ho·∫∑c kh√¥ng c√≥ n√∫t n√†o ƒë∆∞·ª£c ch·ªçn.");
                hideContextMenu(); return;
            }
            const targetNodeId = targetNodeKonva.id();
            const targetNodeData = allNodesDataForCurrentMap.find(n => n.id === targetNodeId);
            if (!targetNodeData || !targetNodeData.text || targetNodeData.text.trim() === "") {
                alert("N√∫t ƒë∆∞·ª£c ch·ªçn kh√¥ng c√≥ n·ªôi dung ho·∫∑c n·ªôi dung kh√¥ng h·ª£p l·ªá ƒë·ªÉ t·∫°o k·∫ø ho·∫°ch h√†nh ƒë·ªông.");
                hideContextMenu(); return;
            }

            const nodeContent = targetNodeData.text.trim();
            const nodeContentPreview = nodeContent.substring(0, 30) + (nodeContent.length > 30 ? "..." : "");

            showLoadingIndicator("AI ƒëang t·∫°o k·∫ø ho·∫°ch h√†nh ƒë·ªông...");
            hideContextMenu();

            const prompt = `B·∫°n l√† m·ªôt tr·ª£ l√Ω AI chuy√™n nghi·ªáp trong vi·ªác l·∫≠p k·∫ø ho·∫°ch v√† ƒë·ªÅ xu·∫•t chi·∫øn l∆∞·ª£c h√†nh ƒë·ªông.
D·ª±a tr√™n m·ª•c ti√™u ho·∫∑c v·∫•n ƒë·ªÅ ƒë∆∞·ª£c m√¥ t·∫£ d∆∞·ªõi ƒë√¢y:
"${nodeContent}"

H√£y ƒë·ªÅ xu·∫•t m·ªôt k·∫ø ho·∫°ch h√†nh ƒë·ªông s∆° b·ªô, bao g·ªìm t·ª´ 3 ƒë·∫øn 5 b∆∞·ªõc c·ª• th·ªÉ, r√µ r√†ng v√† c√≥ t√≠nh kh·∫£ thi cao ƒë·ªÉ ƒë·∫°t ƒë∆∞·ª£c m·ª•c ti√™u ho·∫∑c gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ ƒë√£ n√™u. M·ªói b∆∞·ªõc n√™n:
1. B·∫Øt ƒë·∫ßu b·∫±ng m·ªôt ƒë·ªông t·ª´ h√†nh ƒë·ªông m·∫°nh m·∫Ω (v√≠ d·ª•: Ph√¢n t√≠ch, X√°c ƒë·ªãnh, Thi·∫øt k·∫ø, X√¢y d·ª±ng, Tri·ªÉn khai, Ki·ªÉm tra, ƒê√°nh gi√°, T·ªëi ∆∞u h√≥a).
2. M√¥ t·∫£ ng·∫Øn g·ªçn nh∆∞ng ƒë·∫ßy ƒë·ªß v·ªÅ h√†nh ƒë·ªông c·∫ßn th·ª±c hi·ªán.
3. C√≥ th·ªÉ ƒë∆∞·ª£c th·ª±c hi·ªán m·ªôt c√°ch ƒë·ªôc l·∫≠p ho·∫∑c theo tr√¨nh t·ª± logic.
Vui l√≤ng tr√¨nh b√†y to√†n b·ªô k·∫ø ho·∫°ch d∆∞·ªõi d·∫°ng m·ªôt kh·ªëi vƒÉn b·∫£n, v·ªõi m·ªói b∆∞·ªõc h√†nh ƒë·ªông tr√™n m·ªôt d√≤ng ri√™ng bi·ªát, b·∫Øt ƒë·∫ßu b·∫±ng s·ªë th·ª© t·ª± (v√≠ d·ª•: 1. ..., 2. ...).`;

            try {
                const result = await generativeModel.generateContent(prompt);
                const response = result.response;
                const actionPlanText = response.text().trim();

                if (actionPlanText) {
                    const parentShape = targetNodeKonva.findOne('.nodeShape');
                    const parentHeight = parentShape ? parentShape.height() : DEFAULT_NODE_STYLE.minHeight;
                    const parentWidth = parentShape ? parentShape.width() : DEFAULT_NODE_STYLE.width;

                    const newNodeData = {
                        mapId: currentMindMapId,
                        parentId: targetNodeId, // Child of the node the plan is for
                        text: `üöÄ K·∫ø ho·∫°ch h√†nh ƒë·ªông:\n${actionPlanText}`,
                        position: {
                            x: targetNodeKonva.x() + parentWidth / 4 + 10,
                            y: targetNodeKonva.y() + parentHeight + 35 // Similar positioning to summary node
                        },
                        style: {
                            ...DEFAULT_NODE_STYLE,
                            backgroundColor: "#E3F2FD", // Light blue for action plan
                            textColor: "#0D47A1", // Dark blue text
                            borderColor: "#90CAF9", // Lighter blue border
                            shape: "roundedRectangle",
                            cornerRadius: 4,
                            width: 280, // Wider for action plan
                            minHeight: 80,
                            fontSize: 13,
                            icon: 'üöÄ'
                        },
                        createdAt: serverTimestamp()
                    };
                    await addDoc(collection(db, "nodes"), newNodeData);
                    alert(`AI ƒë√£ t·∫°o m·ªôt n√∫t k·∫ø ho·∫°ch h√†nh ƒë·ªông cho "${nodeContentPreview}".`);

                } else {
                    openAiResponseModal(
                        `K·∫ø ho·∫°ch h√†nh ƒë·ªông cho: "${nodeContentPreview}"`,
                        `M·ª•c ti√™u/V·∫•n ƒë·ªÅ: ${nodeContent}`,
                        "AI kh√¥ng th·ªÉ t·∫°o k·∫ø ho·∫°ch h√†nh ƒë·ªông cho m·ª•c ti√™u n√†y v√†o l√∫c n√†y. Vui l√≤ng th·ª≠ l·∫°i."
                    );
                }
            } catch (error) {
                console.error("Error calling Gemini API (generateActionPlanWithAI):", error);
                let userMessage = "L·ªói khi AI t·∫°o k·∫ø ho·∫°ch h√†nh ƒë·ªông: " + error.message;
                if (error.message?.includes("API key not valid")) { userMessage += "\nVui l√≤ng ki·ªÉm tra l·∫°i thi·∫øt l·∫≠p API Key trong Firebase Console cho Gemini API."; }
                else if (error.message?.includes("429") || error.message?.toLowerCase().includes("quota")) { userMessage = "B·∫°n ƒë√£ g·ª≠i qu√° nhi·ªÅu y√™u c·∫ßu t·ªõi AI ho·∫∑c ƒë√£ h·∫øt h·∫°n ng·∫°ch. Vui l√≤ng th·ª≠ l·∫°i sau √≠t ph√∫t."; }
                else if (error.message?.toLowerCase().includes("billing")){ userMessage = "C√≥ v·∫•n ƒë·ªÅ v·ªõi c√†i ƒë·∫∑t thanh to√°n cho d·ª± √°n Firebase c·ªßa b·∫°n. Vui l√≤ng ki·ªÉm tra trong Google Cloud Console."; }
                else if (error.message?.toLowerCase().includes("model not found")){ userMessage = "Model AI kh√¥ng ƒë∆∞·ª£c t√¨m th·∫•y. Vui l√≤ng ki·ªÉm tra l·∫°i t√™n model ƒë√£ c·∫•u h√¨nh.";}
                else if (error.message?.toLowerCase().includes("candidate.safetyRatings")){ userMessage = "Ph·∫£n h·ªìi t·ª´ AI b·ªã ch·∫∑n do v·∫•n ƒë·ªÅ an to√†n n·ªôi dung. N·ªôi dung c·ªßa n√∫t c√≥ th·ªÉ ch·ª©a t·ª´ kh√≥a nh·∫°y c·∫£m.";}
                openAiResponseModal(
                    `L·ªói AI khi t·∫°o k·∫ø ho·∫°ch h√†nh ƒë·ªông`,
                    `M·ª•c ti√™u/V·∫•n ƒë·ªÅ: ${nodeContent}`,
                    userMessage
                );
            } finally {
                hideLoadingIndicator();
            }
        }

        // --- TOOLBAR BUTTON ACTIONS & KEYBOARD SHORTCUTS & ZOOM ---
        async function addChildNodeLogic(parentNode) {
            if (!parentNode || !currentMindMapId || !db) return;
            const parentShape = parentNode.findOne('.nodeShape');
            if (!parentShape) {
                console.error("addChildNodeLogic: Could not find '.nodeShape' in parentNode:", parentNode.id());
                alert("L·ªói: Kh√¥ng t√¨m th·∫•y h√¨nh d·∫°ng c·ªßa n√∫t cha ƒë·ªÉ th√™m n√∫t con.");
                return;
            }
            const parentWidth = parentShape.width();
            const parentHeight = parentShape.height();

            const defaultChildStyle = { ...DEFAULT_NODE_STYLE, backgroundColor: "#f9f9f9", textColor: "#333333", borderColor: "#cccccc", shape: "rectangle", cornerRadius: 3, icon: '' };
            const newNodeData = {
                mapId: currentMindMapId,
                parentId: parentNode.id(),
                text: "N√∫t con m·ªõi",
                position: { // Position below and slightly to the right of parent
                    x: parentNode.x() + parentWidth / 4,
                    y: parentNode.y() + parentHeight + 30
                },
                style: defaultChildStyle,
                createdAt: serverTimestamp()
            };
            try {
                await addDoc(collection(db, "nodes"), newNodeData);
                // Firestore onSnapshot will handle re-rendering
            }
            catch (e) {
                console.error("Error adding child node:", e);
                alert("L·ªói khi th√™m n√∫t con: " + e.message);
            }
        }
        function findAllDescendantNodeIds(parentNodeId, allNodes) {
            let descendantIds = [];
            const directChildren = allNodes.filter(node => node.parentId === parentNodeId);
            for (const child of directChildren) {
                descendantIds.push(child.id);
                descendantIds = descendantIds.concat(findAllDescendantNodeIds(child.id, allNodes)); // Recursively find children of children
            }
            return descendantIds;
        }
        async function deleteNodeLogic(nodeToDelete) {
            if (!nodeToDelete || !currentMindMapId || !db) return;
            const nodeId = nodeToDelete.id();
            const konvaTextNode = nodeToDelete.findOne('.nodeTextContent');
            const nodeText = konvaTextNode ? (nodeToDelete.getAttr('fullTextData') || "N√∫t kh√¥ng t√™n") : "N√∫t kh√¥ng t√™n"; // Use full text for confirm
            const nodeTextPreview = nodeText.substring(0,30) + (nodeText.length > 30 ? "..." : "");

            if (window.confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a n√∫t "${nodeTextPreview}" v√† T·∫§T C·∫¢ c√°c n√∫t con c·ªßa n√≥ kh√¥ng? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.`)) {
                try {
                    const descendantIds = findAllDescendantNodeIds(nodeId, allNodesDataForCurrentMap);
                    const allIdsToDelete = [nodeId, ...descendantIds];

                    const batch = writeBatch(db);
                    allIdsToDelete.forEach(id => {
                        batch.delete(doc(db, "nodes", id));
                    });
                    await batch.commit();

                    // Reset selection if the deleted node or one of its descendants was selected
                    if (selectedKonvaNode && allIdsToDelete.includes(selectedKonvaNode.id())) {
                        selectedKonvaNode = null;
                        if(nodeStylePanel) hideElement(nodeStylePanel);
                    }
                    if (rightClickedKonvaNode && allIdsToDelete.includes(rightClickedKonvaNode.id())) {
                        rightClickedKonvaNode = null;
                    }
                    // Firestore onSnapshot will handle re-rendering
                } catch (e) {
                    console.error("Error deleting node and descendants:", e);
                    alert("L·ªói khi x√≥a n√∫t: " + e.message);
                }
            }
        }
        function handleGlobalKeyDown(e) {
            if (isEditingText) return; // Prevent global key actions if a modal (like edit node) is active

            // If context menu is open, Escape should close it
            if (contextMenu && !contextMenu.classList.contains('hidden')) {
                if (e.key === 'Escape') {
                    hideContextMenu();
                }
                return; // Don't process other keys if context menu is open
            }

            // If no node is selected, only allow arrow keys for stage panning
            if (!selectedKonvaNode && !['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                // Allow these keys even if no node is selected for other potential global shortcuts (none currently)
                if (e.key === 'Tab' || e.key === 'Enter' || e.key === 'Delete' || e.key === 'Backspace') return;
            }

            const KEYBOARD_MOVE_STEP = 10; // Pixels to move node/stage per key press
            switch (e.key) {
                case 'Tab': // Add child to selected node
                    if (selectedKonvaNode) {
                        e.preventDefault(); // Prevent default tab behavior
                        addChildNodeLogic(selectedKonvaNode);
                    }
                    break;
                case 'Enter': // Edit selected node
                    if (selectedKonvaNode) {
                        e.preventDefault();
                        editTextOnKonvaNode(selectedKonvaNode); // UPDATED call to use modal
                    }
                    break;
                case 'Delete':
                case 'Backspace': // Delete selected node and its children
                    if (selectedKonvaNode) {
                        e.preventDefault();
                        deleteNodeLogic(selectedKonvaNode);
                    }
                    break;
                case 'ArrowUp':
                case 'ArrowDown':
                case 'ArrowLeft':
                case 'ArrowRight':
                    e.preventDefault(); // Prevent page scrolling
                    if (selectedKonvaNode) { // Move selected node
                        let newX = selectedKonvaNode.x();
                        let newY = selectedKonvaNode.y();
                        if (e.key === 'ArrowUp') newY -= KEYBOARD_MOVE_STEP;
                        else if (e.key === 'ArrowDown') newY += KEYBOARD_MOVE_STEP;
                        else if (e.key === 'ArrowLeft') newX -= KEYBOARD_MOVE_STEP;
                        else if (e.key === 'ArrowRight') newX += KEYBOARD_MOVE_STEP;
                        selectedKonvaNode.position({ x: newX, y: newY });
                        currentKonvaLayer.batchDraw();
                        // Debounce Firestore update or update on dragend equivalent for keyboard
                        if (db) {
                            updateDoc(doc(db, "nodes", selectedKonvaNode.id()), { position: { x: newX, y: newY } })
                                .catch(err => console.error("Error updating node position via keyboard:", err));
                        }
                    } else if (currentKonvaStage) { // Pan the stage if no node is selected
                        let stageX = currentKonvaStage.x();
                        let stageY = currentKonvaStage.y();
                        // Invert direction for intuitive panning
                        if (e.key === 'ArrowUp') stageY += KEYBOARD_MOVE_STEP * 2; // Pan view up = move stage content down
                        else if (e.key === 'ArrowDown') stageY -= KEYBOARD_MOVE_STEP * 2;
                        else if (e.key === 'ArrowLeft') stageX += KEYBOARD_MOVE_STEP * 2;
                        else if (e.key === 'ArrowRight') stageX -= KEYBOARD_MOVE_STEP * 2;
                        currentKonvaStage.position({x: stageX, y: stageY });
                        currentKonvaStage.batchDraw();
                        saveCanvasState(); // Save new stage position
                    }
                    break;
            }
        }

        // --- MAIN SCRIPT EXECUTION AFTER DOM IS LOADED ---
        window.addEventListener('DOMContentLoaded', () => {
            // Initialize Firebase services
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                // Initialize Firebase AI (Gemini)
                if (typeof getAI === 'function' && typeof GoogleAIBackend === 'function' && typeof getGenerativeModel === 'function') {
                    ai = getAI(app, { backend: new GoogleAIBackend() }); // Using default backend
                    generativeModel = getGenerativeModel(ai, { model: "gemini-1.5-flash-latest" }); // Specify your desired model
                    // console.log("Firebase initialized successfully with AI Logic SDK!");
                } else {
                    console.error("Firebase AI SDK components not found. AI features will be disabled.");
                    alert("L·ªói: Kh√¥ng th·ªÉ t·∫£i c√°c th√†nh ph·∫ßn AI c·ªßa Firebase. C√°c t√≠nh nƒÉng AI s·∫Ω b·ªã v√¥ hi·ªáu h√≥a.");
                }
            } catch (error) {
                console.error("Firebase initialization error:", error);
                alert("L·ªói nghi√™m tr·ªçng: Kh√¥ng th·ªÉ kh·ªüi t·∫°o Firebase ho·∫∑c AI SDK. Chi ti·∫øt: " + error.message + "\nH√£y ch·∫Øc ch·∫Øn b·∫°n ƒë√£ thay th·∫ø c√°c gi√° tr·ªã placeholder trong firebaseConfig b·∫±ng th√¥ng tin d·ª± √°n Firebase c·ªßa b·∫°n.");
            }

            // Assign DOM elements
            nodeStylePanel = document.getElementById('node-style-panel');
            nodeShapeSelect = document.getElementById('node-shape-select');
            nodeFontFamilySelect = document.getElementById('node-font-family-select');
            nodeFontSizeInput = document.getElementById('node-font-size-input');
            nodeIconSelect = document.getElementById('node-icon-select');
            nodeBgColorInput = document.getElementById('node-bg-color');
            nodeTextColorInput = document.getElementById('node-text-color');
            nodeBorderColorInput = document.getElementById('node-border-color');
            nodeLineColorInput = document.getElementById('node-line-color');
            nodeLineDashSelect = document.getElementById('node-line-dash-select');
            nodeLineWidthInput = document.getElementById('node-line-width');

            contextMenu = document.getElementById('context-menu');
            ctxAddChildButton = document.getElementById('ctx-add-child');
            ctxEditTextButton = document.getElementById('ctx-edit-text');
            ctxViewFullContentButton = document.getElementById('ctx-view-full-content');
            ctxSuggestChildrenButton = document.getElementById('ctx-suggest-children');
            ctxExpandNodeButton = document.getElementById('ctx-expand-node');
            ctxGenerateExamplesButton = document.getElementById('ctx-generate-examples');
            ctxAskAiNodeButton = document.getElementById('ctx-ask-ai-node');
            ctxSummarizeBranchButton = document.getElementById('ctx-summarize-branch');
            ctxGenerateActionPlanButton = document.getElementById('ctx-generate-action-plan');
            ctxDeleteNodeButton = document.getElementById('ctx-delete-node');

            aiLoadingIndicator = document.getElementById('ai-loading-indicator');
            aiResponseModalOverlay = document.getElementById('ai-response-modal-overlay');
            aiResponseModalTitle = document.getElementById('ai-response-modal-title');
            aiResponseModalBody = document.getElementById('ai-response-modal-body');
            aiResponseModalCloseButton = document.getElementById('ai-response-modal-close-button');

            nodeContentModalOverlay = document.getElementById('node-content-modal-overlay');
            nodeContentModalTitle = document.getElementById('node-content-modal-title');
            nodeContentModalBody = document.getElementById('node-content-modal-body');
            nodeContentModalCloseButton = document.getElementById('node-content-modal-close-button');

            // NEW: Assign Edit Node Text Modal elements
            editNodeTextModalOverlay = document.getElementById('edit-node-text-modal-overlay');
            editNodeTextModalTitle = document.getElementById('edit-node-text-modal-title');
            editNodeTextarea = document.getElementById('edit-node-textarea');
            editNodeTextModalSaveButton = document.getElementById('edit-node-text-modal-save-button');
            editNodeTextModalCancelButton = document.getElementById('edit-node-text-modal-cancel-button');
            editNodeTextModalCloseButton = document.getElementById('edit-node-text-modal-close-button');


            authSection = document.getElementById('auth-section');
            loginForm = document.getElementById('login-form');
            registerForm = document.getElementById('register-form');
            loginEmailInput = document.getElementById('login-email');
            loginPasswordInput = document.getElementById('login-password');
            loginButton = document.getElementById('login-button');
            showRegisterLink = document.getElementById('show-register-link');
            registerEmailInput = document.getElementById('register-email');
            registerPasswordInput = document.getElementById('register-password');
            registerButton = document.getElementById('register-button');
            showLoginLink = document.getElementById('show-login-link');
            loginErrorMsg = document.getElementById('login-error');
            registerErrorMsg = document.getElementById('register-error');


            mainAppSection = document.getElementById('main-app-section');
            mainAppTitle = document.getElementById('main-app-title');
            userEmailDisplay = document.getElementById('user-email-display');
            logoutButton = document.getElementById('logout-button');


            mindmapManagementView = document.getElementById('mindmap-management-view');
            newMindmapTitleInput = document.getElementById('new-mindmap-title-input');
            createMindmapButton = document.getElementById('create-mindmap-button');
            mindmapListUl = document.getElementById('mindmap-list');
            mindmapListLoading = document.getElementById('mindmap-list-loading');


            canvasView = document.getElementById('canvas-view');
            backToMapsListButton = document.getElementById('back-to-maps-list-button');
            currentMindmapTitleDisplay = document.getElementById('current-mindmap-title-display');
            addChildNodeButton = document.getElementById('add-child-node-button');
            deleteNodeButton = document.getElementById('delete-node-button');
            zoomInButton = document.getElementById('zoom-in-button');
            zoomOutButton = document.getElementById('zoom-out-button');
            resetZoomButton = document.getElementById('reset-zoom-button');
            konvaContainer = document.getElementById('konva-container');
            konvaContainerLoading = document.getElementById('konva-container-loading');


            // Setup event listeners
            if (aiResponseModalCloseButton) { aiResponseModalCloseButton.addEventListener('click', closeAiResponseModal); }
            if (aiResponseModalOverlay) { aiResponseModalOverlay.addEventListener('click', function(event) { if (event.target === aiResponseModalOverlay) closeAiResponseModal(); }); }
            if (nodeContentModalCloseButton) { nodeContentModalCloseButton.addEventListener('click', closeNodeContentModal); }
            if (nodeContentModalOverlay) { nodeContentModalOverlay.addEventListener('click', function(event) { if (event.target === nodeContentModalOverlay) closeNodeContentModal(); });}

            // NEW: Event listeners for Edit Node Text Modal
            if (editNodeTextModalSaveButton) { editNodeTextModalSaveButton.addEventListener('click', handleSaveNodeTextFromModal); }
            if (editNodeTextModalCancelButton) { editNodeTextModalCancelButton.addEventListener('click', closeEditNodeModal); }
            if (editNodeTextModalCloseButton) { editNodeTextModalCloseButton.addEventListener('click', closeEditNodeModal); }
            if (editNodeTextarea) { // Allow Ctrl+Enter to save, Enter for new line
                editNodeTextarea.addEventListener('keydown', function(e) {
                    if (e.key === 'Enter' && e.ctrlKey) { // Ctrl+Enter to save
                        e.preventDefault();
                        handleSaveNodeTextFromModal();
                    } else if (e.key === 'Escape') { // Allow Esc from textarea to close modal
                        e.preventDefault();
                        closeEditNodeModal();
                    }
                    // Default Enter behavior (new line) is allowed if Ctrl is not pressed
                });
            }


            if (showRegisterLink) { showRegisterLink.addEventListener('click', (e) => { e.preventDefault(); hideElement(loginForm); showElement(registerForm); clearAuthError(loginErrorMsg); }); }
            if (showLoginLink) { showLoginLink.addEventListener('click', (e) => { e.preventDefault(); hideElement(registerForm); showElement(loginForm); clearAuthError(registerErrorMsg); }); }
            if (registerButton) { registerButton.addEventListener('click', handleRegister); }
            if (loginButton) { loginButton.addEventListener('click', handleLogin); }
            if (logoutButton) { logoutButton.addEventListener('click', handleLogout); }

            if (auth) { onAuthStateChanged(auth, authStateChangedHandler); }

            if (backToMapsListButton) { backToMapsListButton.addEventListener('click', showMindmapManagementView); }

            // Node Style Panel Listeners
            if (nodeShapeSelect) nodeShapeSelect.addEventListener('change', (e) => handleNodeStyleChange('shape', e.target.value));
            if (nodeFontFamilySelect) nodeFontFamilySelect.addEventListener('change', (e) => handleNodeStyleChange('fontFamily', e.target.value));
            if (nodeFontSizeInput) nodeFontSizeInput.addEventListener('input', (e) => handleNodeStyleChange('fontSize', e.target.value)); // Use input for live changes
            if (nodeIconSelect) nodeIconSelect.addEventListener('change', (e) => handleNodeStyleChange('icon', e.target.value));
            if (nodeBgColorInput) nodeBgColorInput.addEventListener('input', (e) => handleNodeStyleChange('backgroundColor', e.target.value));
            if (nodeTextColorInput) nodeTextColorInput.addEventListener('input', (e) => handleNodeStyleChange('textColor', e.target.value));
            if (nodeBorderColorInput) nodeBorderColorInput.addEventListener('input', (e) => handleNodeStyleChange('borderColor', e.target.value));
            if (nodeLineColorInput) nodeLineColorInput.addEventListener('input', (e) => handleNodeStyleChange('lineColor', e.target.value));
            if (nodeLineDashSelect) nodeLineDashSelect.addEventListener('change', (e) => handleNodeStyleChange('lineDash', e.target.value));
            if (nodeLineWidthInput) nodeLineWidthInput.addEventListener('input', (e) => handleNodeStyleChange('lineWidth', e.target.value));


            if (createMindmapButton) { createMindmapButton.addEventListener('click', handleCreateMindmap); }

            // Context Menu item listeners
            if (ctxAddChildButton) {
                ctxAddChildButton.addEventListener('click', async () => {
                    let targetNode = rightClickedKonvaNode || selectedKonvaNode;
                    if (!targetNode || !currentMindMapId || !db) {
                        alert("Kh√¥ng th·ªÉ th√™m n√∫t con. Vui l√≤ng th·ª≠ l·∫°i.");
                        hideContextMenu(); return;
                    }
                    await addChildNodeLogic(targetNode);
                    hideContextMenu();
                });
            }
            if (ctxEditTextButton) {
                ctxEditTextButton.addEventListener('click', () => {
                    let targetNode = rightClickedKonvaNode || selectedKonvaNode;
                    if (targetNode) {
                        editTextOnKonvaNode(targetNode); // UPDATED call
                    }
                    hideContextMenu();
                });
            }
            if (ctxViewFullContentButton) {
                ctxViewFullContentButton.addEventListener('click', () => {
                    const targetNode = rightClickedKonvaNode || selectedKonvaNode;
                    if (targetNode) {
                        const fullText = targetNode.getAttr('fullTextData');
                        if (fullText) { openNodeContentModal(fullText.substring(0,30)+"...", fullText); }
                        else { alert("Kh√¥ng c√≥ n·ªôi dung ƒë·∫ßy ƒë·ªß ƒë·ªÉ hi·ªÉn th·ªã."); }
                    } else { alert("Vui l√≤ng ch·ªçn m·ªôt n√∫t ƒë·ªÉ xem n·ªôi dung."); }
                    hideContextMenu();
                });
            }
            if (ctxSuggestChildrenButton) {
                ctxSuggestChildrenButton.addEventListener('click', async () => {
                    let targetNodeForAI = rightClickedKonvaNode || selectedKonvaNode;
                    if (targetNodeForAI) { await suggestChildNodesWithAI(targetNodeForAI); }
                    else { alert("Vui l√≤ng ch·ªçn m·ªôt n√∫t cha ƒë·ªÉ AI g·ª£i √Ω n√∫t con."); hideContextMenu(); }
                });
            }
            if (ctxExpandNodeButton) {
                ctxExpandNodeButton.addEventListener('click', async () => {
                    let targetNodeForAI = rightClickedKonvaNode || selectedKonvaNode;
                    if (targetNodeForAI) { await expandNodeWithAI(targetNodeForAI); }
                    else { alert("Vui l√≤ng ch·ªçn m·ªôt n√∫t ƒë·ªÉ AI m·ªü r·ªông √Ω t∆∞·ªüng."); hideContextMenu(); }
                });
            }
            if (ctxGenerateExamplesButton) {
                ctxGenerateExamplesButton.addEventListener('click', async () => {
                    let targetNodeForAI = rightClickedKonvaNode || selectedKonvaNode;
                    if (targetNodeForAI) { await generateExamplesWithAI(targetNodeForAI); }
                    else { alert("Vui l√≤ng ch·ªçn m·ªôt n√∫t ƒë·ªÉ AI t·∫°o v√≠ d·ª•."); hideContextMenu(); }
                });
            }
            if (ctxAskAiNodeButton) {
                ctxAskAiNodeButton.addEventListener('click', async () => {
                    let targetNodeForAI = rightClickedKonvaNode || selectedKonvaNode;
                    if (targetNodeForAI) { await askAIAboutNode(targetNodeForAI); }
                    else { alert("Vui l√≤ng ch·ªçn m·ªôt n√∫t ƒë·ªÉ ƒë·∫∑t c√¢u h·ªèi cho AI."); hideContextMenu(); }
                });
            }
            if (ctxSummarizeBranchButton) {
                ctxSummarizeBranchButton.addEventListener('click', async () => {
                    let targetNodeForSummarize = rightClickedKonvaNode || selectedKonvaNode;
                    if (targetNodeForSummarize) { await summarizeBranchWithAI(targetNodeForSummarize); }
                    else { alert("Vui l√≤ng ch·ªçn m·ªôt n√∫t g·ªëc c·ªßa nh√°nh ƒë·ªÉ AI t√≥m t·∫Øt."); hideContextMenu(); }
                });
            }
            if (ctxGenerateActionPlanButton) {
                ctxGenerateActionPlanButton.addEventListener('click', async () => {
                    let targetNodeForPlan = rightClickedKonvaNode || selectedKonvaNode;
                    if (targetNodeForPlan) { await generateActionPlanWithAI(targetNodeForPlan); }
                    else { alert("Vui l√≤ng ch·ªçn m·ªôt n√∫t ƒë·ªÉ AI t·∫°o k·∫ø ho·∫°ch h√†nh ƒë·ªông."); hideContextMenu(); }
                });
            }
            if (ctxDeleteNodeButton) {
                ctxDeleteNodeButton.addEventListener('click', async () => {
                    let targetNode = rightClickedKonvaNode || selectedKonvaNode;
                    if (!targetNode || !currentMindMapId || !db) {
                         alert("Kh√¥ng th·ªÉ x√≥a n√∫t. Vui l√≤ng th·ª≠ l·∫°i."); hideContextMenu(); return;
                    }
                    await deleteNodeLogic(targetNode);
                    hideContextMenu();
                });
            }


            // Global click listener to hide context menu if clicked outside
            document.addEventListener('click', function (e) {
                if (contextMenu && !contextMenu.classList.contains('hidden')) {
                    // Check if the click is outside the context menu and not on a Konva node (which might open it again)
                    if (!contextMenu.contains(e.target) && e.target !== currentKonvaStage && !e.target.hasName?.('mindmapNodeGroup') && !e.target.getParent?.()?.hasName?.('mindmapNodeGroup')) {
                         hideContextMenu();
                    }
                }
            });

            // Toolbar button listeners
             if (addChildNodeButton) {
                addChildNodeButton.addEventListener('click', async () => {
                    if (!selectedKonvaNode) { alert("Vui l√≤ng ch·ªçn m·ªôt n√∫t cha ƒë·ªÉ th√™m n√∫t con."); return; }
                    await addChildNodeLogic(selectedKonvaNode);
                });
            }
            if (deleteNodeButton) {
                deleteNodeButton.addEventListener('click', async () => {
                    if (!selectedKonvaNode) { alert("Vui l√≤ng ch·ªçn m·ªôt n√∫t ƒë·ªÉ x√≥a."); return; }
                    await deleteNodeLogic(selectedKonvaNode);
                });
            }
            if(zoomInButton) { zoomInButton.addEventListener('click', () => { if (!currentKonvaStage) return; const oldScale = currentKonvaStage.scaleX(); currentKonvaStage.scale({ x: oldScale * scaleBy, y: oldScale * scaleBy }); currentKonvaStage.batchDraw(); saveCanvasState(); }); }
            if(zoomOutButton) { zoomOutButton.addEventListener('click', () => { if (!currentKonvaStage) return; const oldScale = currentKonvaStage.scaleX(); currentKonvaStage.scale({ x: oldScale / scaleBy, y: oldScale / scaleBy }); currentKonvaStage.batchDraw(); saveCanvasState(); }); }
            if(resetZoomButton) { resetZoomButton.addEventListener('click', () => { if (!currentKonvaStage) return; currentKonvaStage.scale({ x: 1, y: 1 }); currentKonvaStage.position({ x: 0, y: 0 }); currentKonvaStage.batchDraw(); saveCanvasState(); }); }


            // Resize Konva stage when window resizes
            window.addEventListener('resize', () => {
                if (currentKonvaStage && konvaContainer && konvaContainer.offsetParent !== null) { // Check if canvas is visible
                    const newWidth = konvaContainer.clientWidth;
                    const newHeight = konvaContainer.clientHeight;
                    currentKonvaStage.width(newWidth);
                    currentKonvaStage.height(newHeight);
                    // No need to redraw everything, Konva handles it or next batchDraw will.
                }
            });

        }); // End of DOMContentLoaded

    </script>
</body>
</html>
