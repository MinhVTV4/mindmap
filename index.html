<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sơ đồ tư duy MVP - Firebase AI</title>
    <script src="https://unpkg.com/konva@9.3.6/konva.min.js"></script>
    <style>
        html, body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
            color: #1c1e21;
            height: 100%;
            overflow: hidden;
        }
        #app-root {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        .container {
            width: 100%;
            padding: 0;
            background-color: #fff;
            box-shadow: none;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        /* --- AUTH SECTION --- */
        #auth-section {
            padding: 20px;
            max-width: 450px;
            margin: auto;
            flex-grow: 0;
        }
        .form-container {
            max-width: 400px;
            margin: 20px auto;
            padding: 20px;
            border: 1px solid #dddfe2;
            border-radius: 8px;
        }
        .form-container h3 {
            text-align: center;
            color: #1877f2;
            margin-bottom: 20px;
        }
        input[type="email"], input[type="password"], input[type="text"] {
            width: calc(100% - 22px);
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid #dddfe2;
            border-radius: 6px;
            font-size: 16px;
        }
        input[type="number"] {
            width: 50px;
            padding: 6px;
            margin-left: 3px;
            margin-right: 10px;
            border: 1px solid #dddfe2;
            border-radius: 4px;
            font-size: 13px;
            text-align: center;
        }
        select { /* Style cho select dropdown */
            padding: 6px;
            margin-left: 3px;
            margin-right: 10px;
            border: 1px solid #dddfe2;
            border-radius: 4px;
            font-size: 13px;
            background-color: white;
        }
        button {
            padding: 8px 12px;
            font-size: 14px;
            font-weight: bold;
            background-color: #1877f2;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 6px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #166fe5;
        }
        button.secondary {
            background-color: #e4e6eb;
            color: #4b4f56;
        }
        button.secondary:hover {
            background-color: #ccd0d5;
        }
        button.danger {
            background-color: #fa3e3e;
        }
        button.danger:hover {
            background-color: #e03030;
        }
        .auth-toggle {
            text-align: center;
            margin-top: 15px;
        }
        .auth-toggle a {
            color: #1877f2;
            text-decoration: none;
            font-weight: bold;
        }
        .auth-toggle a:hover {
            text-decoration: underline;
        }
        .error-message {
            color: #fa3e3e;
            font-size: 0.9em;
            margin-bottom: 10px;
            text-align: center;
        }
        /* --- MAIN APP SECTION --- */
        #main-app-section {
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 8px;
            box-sizing: border-box;
        }
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 8px;
            margin-bottom: 8px;
            border-bottom: 1px solid #dddfe2;
            flex-shrink: 0;
        }
        header h1 {
            color: #1c1e21;
            font-size: 18px;
            margin: 0;
        }
        #user-info span {
            margin-right: 8px;
            font-size: 0.85em;
        }
        #mindmap-management-view {
             display: flex;
             flex-direction: column;
        }
        #mindmap-management, #canvas-view {
            margin-bottom: 8px;
        }
        #mindmap-list-container{
            flex-grow: 1;
            overflow-y: auto;
        }
        #mindmap-list {
            list-style: none;
            padding: 0;
        }
        #mindmap-list li {
            padding: 8px;
            border: 1px solid #dddfe2;
            margin-bottom: 4px;
            cursor: pointer;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s;
        }
        #mindmap-list li:hover {
            background-color: #f0f2f5;
        }

        #canvas-view {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #canvas-toolbar {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            padding: 6px 5px;
            margin-bottom: 5px;
            border-bottom: 1px solid #ccd0d5;
            flex-shrink: 0;
        }
        #canvas-toolbar .toolbar-section {
            display: flex;
            align-items: center;
            margin-right: 15px;
            margin-bottom: 5px;
        }
        #canvas-toolbar .toolbar-section:last-child {
            margin-right: 0;
        }
        #canvas-toolbar h2 {
            margin: 0 10px 0 0;
            font-size: 16px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 150px;
        }
        #back-to-maps-list-button {
            padding: 6px 8px;
            font-size: 18px;
            line-height: 1;
        }
        #konva-container {
            width: 100%;
            flex-grow: 1;
            background-color: #f7f7f7;
            border: 1px solid #ccd0d5;
            border-radius: 6px;
            position: relative;
            overflow: hidden;
        }
        .hidden {
            display: none !important;
        }
        .loading-indicator { /* Chung cho các loading indicator */
            text-align: center;
            padding: 20px;
            font-style: italic;
            color: #555;
        }
        /* AI Loading Indicator */
        #ai-loading-indicator {
            position: fixed;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Đảm bảo nó ở trên cùng */
            font-size: 1.2em;
            text-shadow: 1px 1px 2px black;
        }

        /* Node Style Panel */
        #node-style-panel {
            padding: 5px;
            background-color: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
        }
        #node-style-panel h5 {
            margin: 0 5px 0 0;
            font-size: 0.85em;
            color: #606770;
            white-space: nowrap;
        }
        #node-style-panel label {
            margin-right: 2px;
            font-size: 0.8em;
            vertical-align: middle;
            white-space: nowrap;
        }
        #node-style-panel input[type="color"] {
            width: 22px;
            height: 22px;
            padding: 0;
            border: 1px solid #ccc;
            border-radius: 3px;
            vertical-align: middle;
            margin-right: 5px;
        }
        #node-style-panel input[type="number"], #node-style-panel select {
            width: auto;
            min-width: 60px;
            padding: 4px;
            font-size: 0.8em;
        }
        .style-group {
            margin-bottom: 0;
            display: flex;
            align-items: center;
            margin-right: 8px;
        }
        .style-group:last-child {
            margin-right: 0;
        }
        /* Context Menu */
        #context-menu {
            position: absolute;
            z-index: 1000;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            border-radius: 4px;
            padding: 5px 0;
        }
        #context-menu ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #context-menu li {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 0.9em;
        }
        #context-menu li:hover {
            background-color: #f0f0f0;
        }
    </style>
</head>
<body>
    <div id="app-root">
        <section id="auth-section" class="container">
            <div id="login-form" class="form-container">
                <h3>Đăng nhập Sơ đồ tư duy</h3>
                <p id="login-error" class="error-message hidden"></p>
                <input type="email" id="login-email" placeholder="Email" required>
                <input type="password" id="login-password" placeholder="Mật khẩu" required>
                <button id="login-button">Đăng nhập</button>
                <p class="auth-toggle">Chưa có tài khoản? <a href="#" id="show-register-link">Đăng ký ngay</a></p>
            </div>
            <div id="register-form" class="form-container hidden">
                <h3>Đăng ký tài khoản</h3>
                <p id="register-error" class="error-message hidden"></p>
                <input type="email" id="register-email" placeholder="Email" required>
                <input type="password" id="register-password" placeholder="Mật khẩu (ít nhất 6 ký tự)" required>
                <button id="register-button">Đăng ký</button>
                <p class="auth-toggle">Đã có tài khoản? <a href="#" id="show-login-link">Đăng nhập</a></p>
            </div>
        </section>

        <section id="main-app-section" class="container hidden">
            <header>
                <h1 id="main-app-title">Bảng điều khiển</h1>
                <div id="user-info">
                    <span id="user-email-display"></span>
                    <button id="logout-button" class="secondary">Đăng xuất</button>
                </div>
            </header>

            <div id="mindmap-management-view">
                <h2>Quản lý Sơ đồ tư duy</h2>
                <div style="margin-bottom: 15px;">
                    <input type="text" id="new-mindmap-title-input" placeholder="Nhập tiêu đề sơ đồ mới...">
                    <button id="create-mindmap-button">Tạo Sơ đồ mới</button>
                </div>
                <div id="mindmap-list-container">
                    <h3>Danh sách sơ đồ của bạn:</h3>
                    <div id="mindmap-list-loading" class="loading-indicator hidden">Đang tải danh sách...</div>
                    <ul id="mindmap-list">
                        </ul>
                </div>
            </div>

            <div id="canvas-view" class="hidden">
                <div id="canvas-toolbar">
                    <div class="toolbar-section">
                        <button id="back-to-maps-list-button" class="secondary" title="Quay lại danh sách">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-left-short" viewBox="0 0 16 16">
                                <path fill-rule="evenodd" d="M12 8a.5.5 0 0 1-.5.5H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H11.5a.5.5 0 0 1 .5.5z"/>
                            </svg>
                        </button>
                        <h2 id="current-mindmap-title-display"></h2>
                    </div>
                    <div class="toolbar-section">
                        <button id="add-child-node-button" title="Thêm nút con (Click)">Thêm Nút</button>
                        <button id="delete-node-button" class="danger" title="Xóa nút đã chọn (Delete/Backspace)">Xóa Nút</button>
                    </div>
                    <div class="toolbar-section">
                        <span style="font-size:0.9em; margin-right: 3px;">Zoom:</span>
                        <button id="zoom-in-button" class="secondary" title="Phóng to">+</button>
                        <button id="zoom-out-button" class="secondary" title="Thu nhỏ">-</button>
                        <button id="reset-zoom-button" class="secondary" title="Reset zoom">Reset</button>
                    </div>
                     <div id="node-style-panel" class="toolbar-section hidden">
                        <div class="style-group">
                            <label for="node-shape-select">Hình dạng:</label>
                            <select id="node-shape-select" title="Hình dạng nút">
                                <option value="rectangle">Chữ nhật</option>
                                <option value="ellipse">Elip</option>
                                <option value="roundedRectangle">Bo góc</option>
                            </select>
                        </div>
                         <div class="style-group">
                            <label for="node-font-family-select">Font:</label>
                            <select id="node-font-family-select" title="Font chữ nút">
                                <option value="Arial">Arial</option>
                                <option value="Verdana">Verdana</option>
                                <option value="Tahoma">Tahoma</option>
                                <option value="Times New Roman">Times New Roman</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Courier New">Courier New</option>
                            </select>
                        </div>
                        <div class="style-group">
                            <label for="node-font-size-input">Cỡ:</label>
                            <input type="number" id="node-font-size-input" min="8" max="72" title="Cỡ chữ nút">
                        </div>
                        <div class="style-group">
                            <label for="node-icon-select">Icon:</label>
                            <select id="node-icon-select" title="Biểu tượng nút">
                                <option value="">Không có</option>
                                <option value="⭐">⭐ Ngôi sao</option>
                                <option value="💡">💡 Bóng đèn</option>
                                <option value="✔️">✔️ Check</option>
                                <option value="❗">❗ Chú ý</option>
                                <option value="❓">❓ Hỏi</option>
                            </select>
                        </div>
                        <div class="style-group">
                            <label for="node-bg-color">Nền:</label>
                            <input type="color" id="node-bg-color" title="Màu nền nút">
                        </div>
                        <div class="style-group">
                            <label for="node-text-color">Chữ:</label>
                            <input type="color" id="node-text-color" title="Màu chữ nút">
                        </div>
                        <div class="style-group">
                             <label for="node-border-color">Viền:</label>
                            <input type="color" id="node-border-color" title="Màu viền nút">
                        </div>
                        <div class="style-group">
                            <label for="node-line-color">Màu đường:</label>
                            <input type="color" id="node-line-color" title="Màu đường nối từ nút này">
                        </div>
                         <div class="style-group">
                            <label for="node-line-dash-select">Kiểu đường:</label>
                            <select id="node-line-dash-select" title="Kiểu đường nối từ nút này">
                                <option value="solid">Liền</option>
                                <option value="dashed">Đứt</option>
                                <option value="dotted">Chấm</option>
                            </select>
                        </div>
                        <div class="style-group">
                            <label for="node-line-width">Dày:</label>
                            <input type="number" id="node-line-width" min="1" max="10" title="Độ dày đường nối từ nút này">
                        </div>
                    </div>
                </div>
                <div id="konva-container-loading" class="loading-indicator hidden">Đang tải sơ đồ...</div>
                <div id="konva-container"></div>
            </div>
        </section>

        <div id="context-menu" class="hidden">
            <ul>
                <li id="ctx-add-child">Thêm nút con (Tab)</li>
                <li id="ctx-edit-text">Sửa văn bản (Enter)</li>
                <li id="ctx-suggest-children">✨ Gợi ý nút con (AI)</li>
                <li id="ctx-expand-node">🔍 Mở rộng ý tưởng (AI)</li> <li id="ctx-delete-node">Xóa nút & con (Delete)</li>
            </ul>
        </div>

        <div id="ai-loading-indicator" class="hidden">Đang xử lý AI...</div>
    </div>

    <script type="module">
        // --- FIREBASE SDK IMPORTS ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-app.js";
        import {
            getAuth,
            createUserWithEmailAndPassword,
            signInWithEmailAndPassword,
            signOut,
            onAuthStateChanged
        } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-auth.js";
        import {
            getFirestore,
            collection,
            addDoc,
            doc,
            getDoc,
            getDocs,
            updateDoc,
            deleteDoc,
            query,
            where,
            serverTimestamp,
            onSnapshot,
            writeBatch
        } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-firestore.js";
        import { getAI, getGenerativeModel, GoogleAIBackend } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-ai.js";


        // --- FIREBASE CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyDLVuv2RGAJWUjhan-5oNCkGBwQZAN60aY", // Thay bằng API Key của bạn
            authDomain: "vocab-91599.firebaseapp.com", // Thay bằng Auth Domain của bạn
            projectId: "vocab-91599", // Thay bằng Project ID của bạn
            storageBucket: "vocab-91599.appspot.com", // Thay bằng Storage Bucket của bạn
            messagingSenderId: "918212044361", // Thay bằng Messaging Sender ID của bạn
            appId: "1:918212044361:web:50b7a065fe0b22b1924198" // Thay bằng App ID của bạn
        };

        // --- INITIALIZE FIREBASE ---
        let app;
        let auth;
        let db;
        let ai;
        let generativeModel;

        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            ai = getAI(app, { backend: new GoogleAIBackend() });
            // Model name có thể là "gemini-1.5-flash-latest", "gemini-pro", "gemini-2.0-flash", etc.
            // Kiểm tra tài liệu Firebase/Google AI để có tên model mới nhất và phù hợp.
            generativeModel = getGenerativeModel(ai, { model: "gemini-1.5-flash-latest" }); // Ví dụ
            console.log("Firebase initialized successfully with AI Logic SDK!");
        } catch (error) {
            console.error("Firebase initialization error:", error);
            alert("Lỗi nghiêm trọng: Không thể khởi tạo Firebase hoặc AI SDK. Ứng dụng có thể không hoạt động. Chi tiết: " + error.message);
        }


        // --- GLOBAL APP STATE ---
        let currentUser = null;
        let currentMindMapId = null;
        let currentKonvaStage = null;
        let currentKonvaLayer = null;
        let selectedKonvaNode = null;
        let mindmapNodesUnsubscribe = null;
        let allNodesDataForCurrentMap = [];
        let mindmapDataUnsubscribe = null;
        let tempCreationLine = null;
        let rightClickedKonvaNode = null;
        let isEditingText = false;
        const DEFAULT_NODE_STYLE = {
            backgroundColor: "#e0e0e0", textColor: "#000000", borderColor: "#555555",
            shape: "rectangle",
            width: 150, minHeight: 50, padding: 10,
            cornerRadius: 5,
            fontSize: 14, fontFamily: 'Arial',
            icon: '',
            iconSize: 16,
            iconSpacing: 5,
            lineColor: "#888888", lineWidth: 3, lineDash: []
        };


        // --- DOM ELEMENTS ---
        const nodeStylePanel = document.getElementById('node-style-panel');
        const nodeShapeSelect = document.getElementById('node-shape-select');
        const nodeFontFamilySelect = document.getElementById('node-font-family-select');
        const nodeFontSizeInput = document.getElementById('node-font-size-input');
        const nodeIconSelect = document.getElementById('node-icon-select');
        const nodeBgColorInput = document.getElementById('node-bg-color');
        const nodeTextColorInput = document.getElementById('node-text-color');
        const nodeBorderColorInput = document.getElementById('node-border-color');
        const nodeLineColorInput = document.getElementById('node-line-color');
        const nodeLineDashSelect = document.getElementById('node-line-dash-select');
        const nodeLineWidthInput = document.getElementById('node-line-width');

        // Context Menu Elements
        const contextMenu = document.getElementById('context-menu');
        const ctxAddChildButton = document.getElementById('ctx-add-child');
        const ctxEditTextButton = document.getElementById('ctx-edit-text');
        const ctxSuggestChildrenButton = document.getElementById('ctx-suggest-children');
        const ctxExpandNodeButton = document.getElementById('ctx-expand-node'); // DOM element cho nút AI mới
        const ctxDeleteNodeButton = document.getElementById('ctx-delete-node');
        const aiLoadingIndicator = document.getElementById('ai-loading-indicator');


        // Auth (Giữ nguyên)
        const authSection = document.getElementById('auth-section');
        const loginForm = document.getElementById('login-form');
        const registerForm = document.getElementById('register-form');
        const loginEmailInput = document.getElementById('login-email');
        const loginPasswordInput = document.getElementById('login-password');
        const loginButton = document.getElementById('login-button');
        const showRegisterLink = document.getElementById('show-register-link');
        const registerEmailInput = document.getElementById('register-email');
        const registerPasswordInput = document.getElementById('register-password');
        const registerButton = document.getElementById('register-button');
        const showLoginLink = document.getElementById('show-login-link');
        const loginErrorMsg = document.getElementById('login-error');
        const registerErrorMsg = document.getElementById('register-error');

        // Main App (Giữ nguyên)
        const mainAppSection = document.getElementById('main-app-section');
        const mainAppTitle = document.getElementById('main-app-title');
        const userEmailDisplay = document.getElementById('user-email-display');
        const logoutButton = document.getElementById('logout-button');

        // Mind Map Management View (Giữ nguyên)
        const mindmapManagementView = document.getElementById('mindmap-management-view');
        const newMindmapTitleInput = document.getElementById('new-mindmap-title-input');
        const createMindmapButton = document.getElementById('create-mindmap-button');
        const mindmapListUl = document.getElementById('mindmap-list');
        const mindmapListLoading = document.getElementById('mindmap-list-loading');

        // Canvas View (Giữ nguyên)
        const canvasView = document.getElementById('canvas-view');
        const backToMapsListButton = document.getElementById('back-to-maps-list-button');
        const currentMindmapTitleDisplay = document.getElementById('current-mindmap-title-display');
        const addChildNodeButton = document.getElementById('add-child-node-button');
        const deleteNodeButton = document.getElementById('delete-node-button');
        const zoomInButton = document.getElementById('zoom-in-button');
        const zoomOutButton = document.getElementById('zoom-out-button');
        const resetZoomButton = document.getElementById('reset-zoom-button');
        const konvaContainer = document.getElementById('konva-container');
        const konvaContainerLoading = document.getElementById('konva-container-loading');


        // --- UTILITY FUNCTIONS ---
        function showElement(el) { if(el) el.classList.remove('hidden'); }
        function hideElement(el) { if(el) el.classList.add('hidden'); }
        function displayAuthError(el, message) {
            if(el) {
                el.textContent = message;
                showElement(el);
            }
        }
        function clearAuthError(el) {
            if(el) {
                el.textContent = '';
                hideElement(el);
            }
        }
        function showLoadingIndicator(message) {
            if (aiLoadingIndicator) {
                aiLoadingIndicator.textContent = message || "Đang xử lý AI...";
                showElement(aiLoadingIndicator);
            }
        }
        function hideLoadingIndicator() {
            if (aiLoadingIndicator) {
                hideElement(aiLoadingIndicator);
            }
        }


        // --- AUTHENTICATION LOGIC --- (Giữ nguyên)
        if (showRegisterLink) {
            showRegisterLink.addEventListener('click', (e) => {
                e.preventDefault();
                hideElement(loginForm);
                showElement(registerForm);
                clearAuthError(loginErrorMsg);
            });
        }
        if (showLoginLink) {
            showLoginLink.addEventListener('click', (e) => {
                e.preventDefault();
                hideElement(registerForm);
                showElement(loginForm);
                clearAuthError(registerErrorMsg);
            });
        }
        if (registerButton) {
            registerButton.addEventListener('click', async () => {
                if (!auth) {
                     displayAuthError(registerErrorMsg, "Lỗi: Dịch vụ xác thực chưa sẵn sàng.");
                     return;
                }
                const email = registerEmailInput.value;
                const password = registerPasswordInput.value;
                clearAuthError(registerErrorMsg);
                if (!firebaseConfig.apiKey || firebaseConfig.apiKey === "YOUR_API_KEY_HERE") {
                    displayAuthError(registerErrorMsg, "Lỗi cấu hình Firebase: API Key không hợp lệ. Vui lòng kiểm tra lại firebaseConfig.");
                    return;
                }
                try {
                    await createUserWithEmailAndPassword(auth, email, password);
                } catch (error) {
                    console.error("Register error:", error);
                    displayAuthError(registerErrorMsg, "Lỗi đăng ký: " + error.code + " - " + error.message);
                }
            });
        }
        if (loginButton) {
            loginButton.addEventListener('click', async () => {
                if (!auth) {
                     displayAuthError(loginErrorMsg, "Lỗi: Dịch vụ xác thực chưa sẵn sàng.");
                     return;
                }
                const email = loginEmailInput.value;
                const password = loginPasswordInput.value;
                clearAuthError(loginErrorMsg);
                if (!firebaseConfig.apiKey || firebaseConfig.apiKey === "YOUR_API_KEY_HERE") {
                    displayAuthError(loginErrorMsg, "Lỗi cấu hình Firebase: API Key không hợp lệ. Vui lòng kiểm tra lại firebaseConfig.");
                    return;
                }
                try {
                    await signInWithEmailAndPassword(auth, email, password);
                } catch (error) {
                    console.error("Login error:", error);
                    displayAuthError(loginErrorMsg, "Lỗi đăng nhập: " + error.code + " - " + error.message);
                }
            });
        }
        if (logoutButton) {
            logoutButton.addEventListener('click', async () => {
                if (!auth) return;
                try {
                    await signOut(auth);
                    currentMindMapId = null;
                    if (mindmapNodesUnsubscribe) mindmapNodesUnsubscribe();
                    if (mindmapDataUnsubscribe) mindmapDataUnsubscribe();
                    window.removeEventListener('keydown', handleGlobalKeyDown);
                } catch (error) {
                    console.error("Logout error:", error);
                }
            });
        }
        if (auth) {
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    currentUser = user;
                    if(userEmailDisplay) userEmailDisplay.textContent = `Chào, ${user.email}`;
                    hideElement(authSection);
                    showElement(mainAppSection);
                    showMindmapManagementView();
                    loadUserMindMaps();
                } else {
                    currentUser = null;
                    if(userEmailDisplay) userEmailDisplay.textContent = '';
                    showElement(authSection);
                    hideElement(mainAppSection);
                    hideElement(canvasView);
                    if(nodeStylePanel) hideElement(nodeStylePanel);
                    if(contextMenu) hideElement(contextMenu);
                    if(mindmapListUl) mindmapListUl.innerHTML = '';
                    window.removeEventListener('keydown', handleGlobalKeyDown);
                }
            });
        }


        // --- UI VIEW MANAGEMENT --- (Giữ nguyên)
        function showMindmapManagementView() {
            if(mainAppTitle) mainAppTitle.textContent = "Bảng điều khiển";
            showElement(mindmapManagementView);
            hideElement(canvasView);
            if(nodeStylePanel) hideElement(nodeStylePanel);
            if(contextMenu) hideElement(contextMenu);
            currentMindMapId = null;
            selectedKonvaNode = null;
            rightClickedKonvaNode = null;
            if (mindmapNodesUnsubscribe) {
                mindmapNodesUnsubscribe();
                mindmapNodesUnsubscribe = null;
            }
            if (mindmapDataUnsubscribe) {
                mindmapDataUnsubscribe();
                mindmapDataUnsubscribe = null;
            }
            if (currentKonvaStage) {
                currentKonvaStage.destroyChildren();
                currentKonvaLayer = null;
            }
            window.removeEventListener('keydown', handleGlobalKeyDown);
        }
        async function showCanvasView(mapId, mapTitle) {
            if(mainAppTitle) mainAppTitle.textContent = "Sơ đồ tư duy";
            hideElement(mindmapManagementView);
            showElement(canvasView);
            if(currentMindmapTitleDisplay) currentMindmapTitleDisplay.textContent = mapTitle;
            currentMindMapId = mapId;
            initKonvaStage();
            if (db && currentMindMapId) {
                const mapDocRef = doc(db, "mindmaps", currentMindMapId);
                if (mindmapDataUnsubscribe) mindmapDataUnsubscribe();
                mindmapDataUnsubscribe = onSnapshot(mapDocRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const mapData = docSnap.data();
                        if (mapData.canvasState && currentKonvaStage) {
                            currentKonvaStage.scaleX(mapData.canvasState.scaleX || 1);
                            currentKonvaStage.scaleY(mapData.canvasState.scaleY || 1);
                            currentKonvaStage.x(mapData.canvasState.x || 0);
                            currentKonvaStage.y(mapData.canvasState.y || 0);
                            currentKonvaStage.batchDraw();
                        }
                    }
                }, (error) => {
                    console.error("Error listening to mindmap data:", error);
                });
            }
            loadAndListenNodesForCurrentMap();
            hideElement(nodeStylePanel);
            hideElement(contextMenu);
            window.addEventListener('keydown', handleGlobalKeyDown);
        }
        if (backToMapsListButton) {
            backToMapsListButton.addEventListener('click', showMindmapManagementView);
        }

        // --- NODE STYLE PANEL LOGIC --- (Giữ nguyên)
        function lineDashArrayToString(dashArray) {
            if (!dashArray || dashArray.length === 0) return 'solid';
            if (JSON.stringify(dashArray) === JSON.stringify([15, 8])) return 'dashed';
            if (JSON.stringify(dashArray) === JSON.stringify([3, 8])) return 'dotted';
            return 'solid';
        }
        function stringToLineDashArray(dashString) {
            if (dashString === 'dashed') return [15, 8];
            if (dashString === 'dotted') return [3, 8];
            return [];
        }
        function updateNodeStylePanel(nodeData) {
            if (!nodeData || !nodeData.style) {
                if(nodeStylePanel) hideElement(nodeStylePanel);
                return;
            }
            const style = nodeData.style;
            if(nodeShapeSelect) nodeShapeSelect.value = style.shape || DEFAULT_NODE_STYLE.shape;
            if(nodeFontFamilySelect) nodeFontFamilySelect.value = style.fontFamily || DEFAULT_NODE_STYLE.fontFamily;
            if(nodeFontSizeInput) nodeFontSizeInput.value = style.fontSize || DEFAULT_NODE_STYLE.fontSize;
            if(nodeIconSelect) nodeIconSelect.value = style.icon || '';
            if(nodeBgColorInput) nodeBgColorInput.value = style.backgroundColor || DEFAULT_NODE_STYLE.backgroundColor;
            if(nodeTextColorInput) nodeTextColorInput.value = style.textColor || DEFAULT_NODE_STYLE.textColor;
            if(nodeBorderColorInput) nodeBorderColorInput.value = style.borderColor || DEFAULT_NODE_STYLE.borderColor;
            if(nodeLineColorInput) nodeLineColorInput.value = style.lineColor || DEFAULT_NODE_STYLE.lineColor;
            if(nodeLineDashSelect) nodeLineDashSelect.value = lineDashArrayToString(style.lineDash);
            if(nodeLineWidthInput) nodeLineWidthInput.value = style.lineWidth || DEFAULT_NODE_STYLE.lineWidth;
            if(nodeStylePanel) showElement(nodeStylePanel);
        }
        async function handleNodeStyleChange(property, value) {
            if (!selectedKonvaNode || !db) return;
            const nodeId = selectedKonvaNode.id();
            let processedValue = value;
            if (property === 'lineWidth' || property === 'fontSize') {
                processedValue = parseInt(value, 10);
            } else if (property === 'lineDash') {
                processedValue = stringToLineDashArray(value);
            }
            try {
                const nodeRef = doc(db, "nodes", nodeId);
                const nodeSnap = await getDoc(nodeRef);
                if (nodeSnap.exists()) {
                    const existingData = nodeSnap.data();
                    const existingStyle = existingData.style || {};
                    let updatedStyle = { ...existingStyle, [property]: processedValue };

                    if (property === 'shape') {
                        if (processedValue === 'ellipse') {}
                        else if (processedValue === 'rectangle' && !updatedStyle.cornerRadius) { updatedStyle.cornerRadius = 0; }
                        else if (processedValue === 'roundedRectangle' && (!updatedStyle.cornerRadius || updatedStyle.cornerRadius === 0) ) { updatedStyle.cornerRadius = 5; }
                    }

                    // Tính toán lại chiều cao nếu font, size, text, hoặc icon thay đổi
                    if (['fontFamily', 'fontSize', 'text', 'icon'].includes(property) || (property === 'style' && (value.fontFamily || value.fontSize || value.text || value.icon))) {
                        const styleForCalc = property === 'style' ? { ...existingStyle, ...value } : updatedStyle;
                        updatedStyle = { ...updatedStyle, ...calculateNodeHeight(styleForCalc.text || existingData.text, styleForCalc) };
                    }
                    await updateDoc(nodeRef, { style: updatedStyle });
                } else {
                    console.warn("Node not found for style update:", nodeId);
                }
            } catch (e) {
                console.error(`Error updating node style (${property}):`, e);
            }
        }

        // Hàm tính toán chiều cao động của node dựa trên text và style
        function calculateNodeHeight(text, styleConfig) {
            const style = { ...DEFAULT_NODE_STYLE, ...styleConfig };
            const textPadding = style.padding;
            const iconSize = style.iconSize;
            const iconSpacing = style.iconSpacing;
            let iconTextWidth = 0;

            if (style.icon && style.icon !== '') {
                // Không cần tạo Konva.Text ở đây nếu chỉ để tính toán, có thể ước lượng hoặc bỏ qua nếu quá phức tạp
                // Tạm thời giả định icon không ảnh hưởng nhiều đến chiều cao tính toán từ text
                const tempIconForCalc = new Konva.Text({ text: style.icon, fontSize: iconSize, fontFamily: style.fontFamily });
                iconTextWidth = tempIconForCalc.width() + iconSpacing;
            }

            const mainTextWidth = style.width - 2 * textPadding - iconTextWidth;

            const tempText = new Konva.Text({
                text: text,
                fontSize: style.fontSize,
                fontFamily: style.fontFamily,
                width: mainTextWidth > 0 ? mainTextWidth : 0, // Đảm bảo width không âm
                align: 'center' // Hoặc style.textAlign nếu có
            });
            const actualTextContentHeight = tempText.height();
            const dynamicShapeHeight = Math.max(style.minHeight, actualTextContentHeight + 2 * textPadding, style.icon ? (iconSize + 2 * textPadding) : 0);
            return { height: dynamicShapeHeight }; // Trả về object chứa height
        }


        if (nodeShapeSelect) nodeShapeSelect.addEventListener('change', (e) => handleNodeStyleChange('shape', e.target.value));
        if (nodeFontFamilySelect) nodeFontFamilySelect.addEventListener('change', (e) => handleNodeStyleChange('fontFamily', e.target.value));
        if (nodeFontSizeInput) nodeFontSizeInput.addEventListener('input', (e) => handleNodeStyleChange('fontSize', e.target.value));
        if (nodeIconSelect) nodeIconSelect.addEventListener('change', (e) => handleNodeStyleChange('icon', e.target.value));
        if (nodeBgColorInput) nodeBgColorInput.addEventListener('input', (e) => handleNodeStyleChange('backgroundColor', e.target.value));
        if (nodeTextColorInput) nodeTextColorInput.addEventListener('input', (e) => handleNodeStyleChange('textColor', e.target.value));
        if (nodeBorderColorInput) nodeBorderColorInput.addEventListener('input', (e) => handleNodeStyleChange('borderColor', e.target.value));
        if (nodeLineColorInput) nodeLineColorInput.addEventListener('input', (e) => handleNodeStyleChange('lineColor', e.target.value));
        if (nodeLineDashSelect) nodeLineDashSelect.addEventListener('change', (e) => handleNodeStyleChange('lineDash', e.target.value));
        if (nodeLineWidthInput) nodeLineWidthInput.addEventListener('input', (e) => handleNodeStyleChange('lineWidth', e.target.value));


        // --- FIRESTORE SERVICE LOGIC (Mind Maps) --- (Giữ nguyên)
        if (createMindmapButton) {
            createMindmapButton.addEventListener('click', async () => {
                if (!db) { alert("Lỗi: Dịch vụ cơ sở dữ liệu chưa sẵn sàng."); return; }
                const title = newMindmapTitleInput.value.trim();
                if (!title) { alert("Vui lòng nhập tiêu đề cho sơ đồ."); return; }
                if (!currentUser) { alert("Vui lòng đăng nhập để tạo sơ đồ."); return; }
                try {
                    const mindMapData = {
                        userId: currentUser.uid, title: title, createdAt: serverTimestamp(),
                        lastModified: serverTimestamp(), canvasState: { scaleX: 1, scaleY: 1, x: 0, y: 0 }
                    };
                    const mindMapDocRef = await addDoc(collection(db, "mindmaps"), mindMapData);
                    const rootNodeData = {
                        mapId: mindMapDocRef.id, parentId: null, text: "Ý tưởng trung tâm",
                        position: { x: (konvaContainer?.clientWidth || 800) / 2 - 75, y: 50 },
                        style: { ...DEFAULT_NODE_STYLE, backgroundColor: "#1877f2", textColor: "#ffffff", borderColor: "#0e5aab", shape: "ellipse", minHeight: 60 },
                        createdAt: serverTimestamp()
                    };
                    await addDoc(collection(db, "nodes"), rootNodeData);
                    newMindmapTitleInput.value = '';
                    // alert(`Sơ đồ "${title}" đã được tạo!`); // onSnapshot sẽ cập nhật UI
                } catch (e) { console.error("Error creating new mind map: ", e); alert("Lỗi khi tạo sơ đồ: " + e.message); }
            });
        }
        async function loadUserMindMaps() {
            if (!currentUser || !db) return;
            showElement(mindmapListLoading);
            if(mindmapListUl) mindmapListUl.innerHTML = '';
            try {
                const q = query(collection(db, "mindmaps"), where("userId", "==", currentUser.uid));
                if (typeof window.mindmapsListenerUnsubscribe === 'function') { window.mindmapsListenerUnsubscribe(); }
                window.mindmapsListenerUnsubscribe = onSnapshot(q, (querySnapshot) => {
                    if(mindmapListUl) mindmapListUl.innerHTML = '';
                    if (querySnapshot.empty) { if(mindmapListUl) mindmapListUl.innerHTML = '<li>Bạn chưa có sơ đồ nào. Hãy tạo một cái mới!</li>';}
                    querySnapshot.forEach((docSnap) => {
                        const map = { id: docSnap.id, ...docSnap.data() };
                        const li = document.createElement('li');
                        li.textContent = map.title;
                        li.dataset.mapId = map.id; li.dataset.mapTitle = map.title;
                        const deleteButton = document.createElement('button');
                        deleteButton.textContent = 'Xóa'; deleteButton.classList.add('danger', 'secondary');
                        deleteButton.style.fontSize = '0.8em'; deleteButton.style.padding = '5px 8px';
                        deleteButton.onclick = async (e) => {
                            e.stopPropagation();
                            if (window.confirm(`Bạn có chắc muốn xóa sơ đồ "${map.title}" và tất cả các nút của nó?`)) { await deleteMindMap(map.id); }
                        };
                        li.appendChild(deleteButton);
                        li.addEventListener('click', () => { showCanvasView(map.id, map.title); });
                        if(mindmapListUl) mindmapListUl.appendChild(li);
                    });
                    hideElement(mindmapListLoading);
                }, (error) => {
                    console.error("Error fetching user mind maps: ", error);
                    if(mindmapListUl) mindmapListUl.innerHTML = '<li>Lỗi khi tải danh sách sơ đồ.</li>';
                    hideElement(mindmapListLoading);
                });
            } catch (e) {
                console.error("Error setting up mind map listener: ", e);
                if(mindmapListUl) mindmapListUl.innerHTML = '<li>Lỗi khi tải danh sách sơ đồ.</li>';
                hideElement(mindmapListLoading);
            }
        }
        async function deleteMindMap(mapId) {
            if (!mapId || !db) return;
            try {
                const nodesQuery = query(collection(db, "nodes"), where("mapId", "==", mapId));
                const nodesSnapshot = await getDocs(nodesQuery);
                const batch = writeBatch(db);
                nodesSnapshot.forEach(nodeDoc => { batch.delete(doc(db, "nodes", nodeDoc.id)); });
                await batch.commit();
                await deleteDoc(doc(db, "mindmaps", mapId));
                // alert("Sơ đồ đã được xóa."); // onSnapshot sẽ cập nhật UI
            } catch (error) { console.error("Error deleting mind map: ", error); alert("Lỗi khi xóa sơ đồ: " + error.message); }
        }

        // --- FIRESTORE SERVICE LOGIC (Nodes) & KONVA INTEGRATION --- (Giữ nguyên phần lớn)
        function initKonvaStage() {
            if (currentKonvaStage) { currentKonvaStage.off('dragstart dragmove dragend click tap wheel contextmenu'); currentKonvaStage.destroy(); currentKonvaStage = null; }
            if (currentKonvaLayer) { currentKonvaLayer.destroy(); currentKonvaLayer = null; }
            const container = document.getElementById('konva-container');
            if (!container) { console.error("Konva container not found!"); return; }
            currentKonvaStage = new Konva.Stage({ container: 'konva-container', width: container.clientWidth, height: container.clientHeight, draggable: true });
            currentKonvaLayer = new Konva.Layer();
            currentKonvaStage.add(currentKonvaLayer);
            selectedKonvaNode = null;
            currentKonvaStage.on('dragend', saveCanvasState);
            currentKonvaStage.on('wheel', (e) => {
                e.evt.preventDefault(); const oldScale = currentKonvaStage.scaleX();
                const pointer = currentKonvaStage.getPointerPosition(); if (!pointer) return;
                const mousePointTo = { x: (pointer.x - currentKonvaStage.x()) / oldScale, y: (pointer.y - currentKonvaStage.y()) / oldScale, };
                const direction = e.evt.deltaY > 0 ? -1 : 1; const newScale = direction > 0 ? oldScale * scaleBy : oldScale / scaleBy;
                currentKonvaStage.scale({ x: newScale, y: newScale });
                const newPos = { x: pointer.x - mousePointTo.x * newScale, y: pointer.y - mousePointTo.y * newScale, };
                currentKonvaStage.position(newPos); currentKonvaStage.batchDraw(); saveCanvasState();
            });
            currentKonvaStage.on('click tap', function(e) {
                if (e.target === currentKonvaStage) {
                    if (selectedKonvaNode) { selectedKonvaNode.findOne('.nodeShape')?.strokeWidth(1); removeCreationHandle(selectedKonvaNode); selectedKonvaNode = null; if(nodeStylePanel) hideElement(nodeStylePanel); currentKonvaLayer.batchDraw(); }
                    if(contextMenu) hideElement(contextMenu);
                }
            });
            currentKonvaStage.on('contextmenu', function(e) {
                e.evt.preventDefault(); let targetNodeGroup = e.target;
                while (targetNodeGroup && targetNodeGroup !== currentKonvaStage && !targetNodeGroup.hasName('mindmapNodeGroup')) { targetNodeGroup = targetNodeGroup.getParent(); }
                if (targetNodeGroup && targetNodeGroup.hasName('mindmapNodeGroup')) {
                    rightClickedKonvaNode = targetNodeGroup;
                    if (!selectedKonvaNode || selectedKonvaNode.id() !== rightClickedKonvaNode.id()) {
                        if (selectedKonvaNode) { selectedKonvaNode.findOne('.nodeShape')?.strokeWidth(1); removeCreationHandle(selectedKonvaNode); }
                        selectedKonvaNode = rightClickedKonvaNode; selectedKonvaNode.findOne('.nodeShape')?.strokeWidth(3);
                        const nodeDataForHandle = allNodesDataForCurrentMap.find(n => n.id === selectedKonvaNode.id());
                        const currentHeightForHandle = nodeDataForHandle?.style?.height || selectedKonvaNode.findOne('.nodeShape')?.height() || DEFAULT_NODE_STYLE.minHeight;
                        addCreationHandle(selectedKonvaNode, currentHeightForHandle);
                        const nodeData = allNodesDataForCurrentMap.find(n => n.id === selectedKonvaNode.id());
                        if (nodeData) updateNodeStylePanel(nodeData);
                        currentKonvaLayer.batchDraw();
                    }
                    if(contextMenu) { contextMenu.style.top = e.evt.pageY + 'px'; contextMenu.style.left = e.evt.pageX + 'px'; showElement(contextMenu); }
                } else { rightClickedKonvaNode = null; if(contextMenu) hideElement(contextMenu); }
            });
        }
        async function saveCanvasState() { /* ... giữ nguyên ... */ }
        function loadAndListenNodesForCurrentMap() {
            if (!currentMindMapId || !currentKonvaLayer || !db) { console.warn("Cannot load nodes..."); return; }
            showElement(konvaContainerLoading); currentKonvaLayer.destroyChildren(); currentKonvaLayer.draw(); allNodesDataForCurrentMap = [];
            const q = query(collection(db, "nodes"), where("mapId", "==", currentMindMapId));
            if (mindmapNodesUnsubscribe) mindmapNodesUnsubscribe();
            mindmapNodesUnsubscribe = onSnapshot(q, (querySnapshot) => {
                const nodesFromDb = []; querySnapshot.forEach((docSnap) => { nodesFromDb.push({ id: docSnap.id, ...docSnap.data() }); });
                allNodesDataForCurrentMap = nodesFromDb; renderNodesAndLines(allNodesDataForCurrentMap); hideElement(konvaContainerLoading);
            }, (error) => { console.error(`Error listening to nodes for map ${currentMindMapId}:`, error); alert("Lỗi khi tải các nút của sơ đồ: " + error.message); hideElement(konvaContainerLoading); });
        }
        function renderNodesAndLines(nodesData) {
            if (!currentKonvaLayer) return;
            currentKonvaLayer.destroyChildren(); const konvaNodeObjects = {};
            nodesData.forEach(nodeData => {
                if (!nodeData.position || typeof nodeData.position.x !== 'number' || typeof nodeData.position.y !== 'number') { console.warn("Node data missing valid position, skipping:", nodeData); return; }
                const style = { ...DEFAULT_NODE_STYLE, ...(nodeData.style || {}) };
                // Chiều cao của shape sẽ được lấy từ nodeData.style.height nếu có, nếu không sẽ tự tính
                const dynamicShapeHeight = nodeData.style?.height || calculateNodeHeight(nodeData.text, style).height;

                const textPadding = style.padding; const iconSize = style.iconSize; const iconSpacing = style.iconSpacing;
                let iconTextWidth = 0; let iconObject = null;
                if (style.icon && style.icon !== '') {
                    iconObject = new Konva.Text({ text: style.icon, fontSize: iconSize, fontFamily: style.fontFamily, fill: style.textColor, x: textPadding, listening: false, name: 'nodeIcon' });
                    iconTextWidth = iconObject.width() + iconSpacing;
                }
                const mainTextWidth = style.width - 2 * textPadding - iconTextWidth;
                const group = new Konva.Group({ x: nodeData.position.x, y: nodeData.position.y, draggable: true, id: nodeData.id, name: 'mindmapNodeGroup' });
                let shape;
                if (style.shape === 'ellipse') {
                    shape = new Konva.Ellipse({ x: style.width / 2, y: dynamicShapeHeight / 2, radiusX: style.width / 2, radiusY: dynamicShapeHeight / 2, fill: style.backgroundColor, stroke: style.borderColor, strokeWidth: 1, name: 'nodeShape' });
                } else if (style.shape === 'roundedRectangle') {
                    shape = new Konva.Rect({ width: style.width, height: dynamicShapeHeight, fill: style.backgroundColor, stroke: style.borderColor, strokeWidth: 1, cornerRadius: style.cornerRadius || 10, name: 'nodeShape' });
                } else {
                    shape = new Konva.Rect({ width: style.width, height: dynamicShapeHeight, fill: style.backgroundColor, stroke: style.borderColor, strokeWidth: 1, cornerRadius: 0, name: 'nodeShape' });
                }
                group.add(shape); shape.moveToBottom();
                if (iconObject) { iconObject.y((dynamicShapeHeight - iconObject.height()) / 2); group.add(iconObject); }
                const textToRender = new Konva.Text({
                    text: nodeData.text, fontSize: style.fontSize, fontFamily: style.fontFamily, fill: style.textColor,
                    width: mainTextWidth > 0 ? mainTextWidth : 0, x: textPadding + iconTextWidth, padding: 0, align: 'center', listening: false
                });
                textToRender.y((dynamicShapeHeight - textToRender.height()) / 2); group.add(textToRender);
                group.on('dragend', async function() { if(!db) return; try { await updateDoc(doc(db, "nodes", this.id()), { position: { x: this.x(), y: this.y() } }); } catch (e) { console.error("Error updating node position:", e); } });
                group.on('click tap', function(e) {
                    e.evt.cancelBubble = true;
                    if (selectedKonvaNode && selectedKonvaNode !== this) { selectedKonvaNode.findOne('.nodeShape')?.strokeWidth(1); removeCreationHandle(selectedKonvaNode); }
                    selectedKonvaNode = this; this.findOne('.nodeShape')?.strokeWidth(3);
                    const nodeDataForHandle = allNodesDataForCurrentMap.find(n => n.id === this.id());
                    const currentHeightForHandle = nodeDataForHandle?.style?.height || this.findOne('.nodeShape')?.height() || DEFAULT_NODE_STYLE.minHeight;
                    addCreationHandle(this, currentHeightForHandle);
                    const clickedNodeData = allNodesDataForCurrentMap.find(n => n.id === this.id());
                    if(clickedNodeData) updateNodeStylePanel(clickedNodeData);
                    currentKonvaLayer.batchDraw(); if(contextMenu) hideElement(contextMenu);
                });
                group.on('dblclick dbltap', function() { editTextOnKonvaNode(this, textToRender, dynamicShapeHeight); if(contextMenu) hideElement(contextMenu); });
                konvaNodeObjects[nodeData.id] = group; currentKonvaLayer.add(group);
                if (selectedKonvaNode && selectedKonvaNode.id() === nodeData.id) {
                    shape.strokeWidth(3);
                    const nodeDataForHandle = allNodesDataForCurrentMap.find(n => n.id === selectedKonvaNode.id());
                    const currentHeightForHandle = nodeDataForHandle?.style?.height || group.findOne('.nodeShape')?.height() || DEFAULT_NODE_STYLE.minHeight;
                    addCreationHandle(group, currentHeightForHandle);
                }
            });
            nodesData.forEach(nodeData => { /* ... vẽ đường nối, giữ nguyên ... */
                if (nodeData.parentId && konvaNodeObjects[nodeData.parentId] && konvaNodeObjects[nodeData.id]) {
                    const parentKonvaNode = konvaNodeObjects[nodeData.parentId]; const childKonvaNode = konvaNodeObjects[nodeData.id];
                    const parentNodeFromData = allNodesDataForCurrentMap.find(n=>n.id === nodeData.parentId);
                    const parentRenderedShape = parentKonvaNode.findOne('.nodeShape'); const childRenderedShape = childKonvaNode.findOne('.nodeShape');
                    const parentActualHeight = parentRenderedShape ? parentRenderedShape.height() : (parentNodeFromData?.style?.height || DEFAULT_NODE_STYLE.minHeight);
                    const childActualHeight = childRenderedShape ? childRenderedShape.height() : (nodeData.style?.height || DEFAULT_NODE_STYLE.minHeight);
                    const parentActualWidth = parentRenderedShape ? parentRenderedShape.width() : (parentNodeFromData?.style?.width || DEFAULT_NODE_STYLE.width);
                    const childActualWidth = childRenderedShape ? childRenderedShape.width() : (nodeData.style?.width || DEFAULT_NODE_STYLE.width);
                    const parentStyle = { ...DEFAULT_NODE_STYLE, ...(parentNodeFromData?.style || {}) };
                    const line = new Konva.Line({
                        points: [ parentKonvaNode.x() + parentActualWidth / 2, parentKonvaNode.y() + parentActualHeight / 2, childKonvaNode.x() + childActualWidth / 2, childKonvaNode.y() + childActualHeight / 2 ],
                        stroke: parentStyle.lineColor, strokeWidth: parentStyle.lineWidth, dash: parentStyle.lineDash, lineCap: 'round', lineJoin: 'round', name: 'connectionLine'
                    });
                    currentKonvaLayer.add(line); line.moveToBottom();
                }
            });
            currentKonvaLayer.batchDraw();
        }

        // --- Creation Handle Logic --- (Giữ nguyên, đảm bảo parentCurrentHeight được sử dụng đúng)
        const HANDLE_RADIUS = 8; const HANDLE_FILL = 'rgba(0,180,0,0.7)'; const HANDLE_STROKE = 'rgba(0,100,0,0.9)';
        function addCreationHandle(parentNodeGroup, parentCurrentHeight) {
            if (!parentNodeGroup || parentNodeGroup.findOne('.creationHandle')) return;
            const parentShape = parentNodeGroup.findOne('.nodeShape'); if (!parentShape) return;
            const shapeWidth = parentShape.width(); const actualHeight = parentCurrentHeight || parentShape.height();
            let handleX = shapeWidth / 2; let handleY = actualHeight;
            if (parentShape.getClassName() === 'Ellipse') { handleX = parentShape.x(); handleY = parentShape.y() + parentShape.radiusY(); }
            const handle = new Konva.Circle({
                x: handleX, y: handleY, radius: HANDLE_RADIUS, fill: HANDLE_FILL, stroke: HANDLE_STROKE, strokeWidth: 1, draggable: true, name: 'creationHandle',
                dragBoundFunc: function(pos) { const parentAbsPos = parentNodeGroup.getAbsolutePosition(); return { x: pos.x - parentAbsPos.x, y: pos.y - parentAbsPos.y, }; }
            });
            parentNodeGroup.add(handle); parentNodeGroup.creationHandle = handle;
            handle.on('dragstart', function(e) { /* ... giữ nguyên ... */ });
            handle.on('dragmove', function(e) { /* ... giữ nguyên ... */ });
            handle.on('dragend', async function(e) { /* ... giữ nguyên ... */ });
            currentKonvaLayer.batchDraw();
        }
        function removeCreationHandle(parentNodeGroup) { if (parentNodeGroup && parentNodeGroup.creationHandle) { parentNodeGroup.creationHandle.destroy(); parentNodeGroup.creationHandle = null; currentKonvaLayer.batchDraw(); } }

        // --- Edit Text Logic --- (Cập nhật để sử dụng calculateNodeHeight)
        function editTextOnKonvaNode(konvaGroup, konvaTextNode, currentShapeHeight) {
            if (!currentKonvaStage || !currentKonvaLayer || isEditingText) return;
            isEditingText = true; konvaTextNode.hide(); const iconNode = konvaGroup.findOne('.nodeIcon'); if (iconNode) iconNode.hide();
            currentKonvaLayer.draw();
            const textAbsPos = konvaTextNode.getAbsolutePosition(); const stageBox = currentKonvaStage.container().getBoundingClientRect();
            let textareaBeingRemoved = false;
            const areaPosition = { x: stageBox.left + textAbsPos.x, y: stageBox.top + textAbsPos.y };
            const textarea = document.createElement('textarea'); document.body.appendChild(textarea);
            textarea.value = konvaTextNode.text();
            textarea.style.position = 'absolute'; textarea.style.top = areaPosition.y + 'px'; textarea.style.left = areaPosition.x + 'px';
            textarea.style.width = konvaTextNode.width() * currentKonvaStage.scaleX() + 'px';
            textarea.style.height = konvaTextNode.height() * currentKonvaStage.scaleY() + 'px'; // Sẽ điều chỉnh lại sau
            textarea.style.fontSize = konvaTextNode.fontSize() * currentKonvaStage.scaleY() + 'px';
            textarea.style.border = '1px solid #999'; textarea.style.padding = '0px'; textarea.style.margin = '0px';
            textarea.style.overflow = 'hidden'; textarea.style.background = 'white'; textarea.style.outline = 'none';
            textarea.style.resize = 'none'; textarea.style.textAlign = konvaTextNode.align(); textarea.style.fontFamily = konvaTextNode.fontFamily();
            textarea.style.display = 'flex'; textarea.style.alignItems = 'center'; textarea.style.justifyContent = 'center';
            textarea.focus(); textarea.select();

            async function saveAndRemoveTextarea() {
                if (textareaBeingRemoved) return; textareaBeingRemoved = true;
                const newText = textarea.value;
                if (textarea.parentNode) { textarea.parentNode.removeChild(textarea); }
                const nodeRef = doc(db, "nodes", konvaGroup.id());
                const nodeSnap = await getDoc(nodeRef);
                let currentStyleForCalc = DEFAULT_NODE_STYLE;
                if (nodeSnap.exists() && nodeSnap.data().style) { currentStyleForCalc = {...DEFAULT_NODE_STYLE, ...nodeSnap.data().style}; }

                const { height: newFinalShapeHeight } = calculateNodeHeight(newText, currentStyleForCalc); // Lấy chiều cao mới

                window.removeEventListener('click', handleOutsideClick); isEditingText = false;
                if(!db) return;
                try {
                    const updatedNodeData = { text: newText, style: { ...currentStyleForCalc, height: newFinalShapeHeight } };
                    await updateDoc(nodeRef, updatedNodeData);
                } catch (e) {
                    console.error("Error updating node text and height in Firestore:", e);
                    // Khôi phục text cũ nếu lỗi
                    const originalKonvaTextNode = konvaGroup.findOne('Text');
                    if (originalKonvaTextNode) { originalKonvaTextNode.text(textarea.value); originalKonvaTextNode.show(); }
                    const originalIconNode = konvaGroup.findOne('.nodeIcon'); if (originalIconNode) originalIconNode.show();
                    currentKonvaLayer.batchDraw();
                }
            }
            function removeTextareaWithoutSaving() { /* ... giữ nguyên ... */ }
            textarea.addEventListener('keydown', function (e) { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); saveAndRemoveTextarea(); } if (e.key === 'Escape') { removeTextareaWithoutSaving(); } });
            textarea.addEventListener('blur', saveAndRemoveTextarea);
            function handleOutsideClick(e) { if (e.target !== textarea) { saveAndRemoveTextarea(); } }
            setTimeout(() => { window.addEventListener('click', handleOutsideClick); }, 0);
        }


        // --- AI LOGIC FOR SUGGESTING CHILD NODES --- (Giữ nguyên)
        async function suggestChildNodesWithAI(parentNodeKonva) {
            if (!generativeModel || !parentNodeKonva || !currentMindMapId || !currentUser || !db) {
                alert("Chức năng AI chưa sẵn sàng hoặc thiếu thông tin cần thiết."); if(contextMenu) hideElement(contextMenu); return;
            }
            const parentNodeId = parentNodeKonva.id();
            const parentNodeData = allNodesDataForCurrentMap.find(n => n.id === parentNodeId);
            if (!parentNodeData) { alert("Không tìm thấy dữ liệu cho nút cha đã chọn."); if(contextMenu) hideElement(contextMenu); return; }
            const parentText = parentNodeData.text;
            const prompt = `Cho một nút sơ đồ tư duy với nội dung là "${parentText}", hãy gợi ý 3 ý tưởng ngắn gọn (khoảng 2-5 từ mỗi ý tưởng) cho các nút con liên quan trực tiếp. Mỗi ý tưởng trên một dòng riêng biệt. Không sử dụng đánh số, gạch đầu dòng hay bất kỳ ký tự đặc biệt nào ở đầu dòng.`;
            showLoadingIndicator("AI đang tạo gợi ý..."); if(contextMenu) hideElement(contextMenu);
            try {
                const result = await generativeModel.generateContent(prompt);
                const response = result.response; const suggestionsText = response.text();
                const suggestions = suggestionsText.split('\n').map(s => s.trim()).filter(s => s.length > 0 && s.length < 50);
                if (suggestions.length > 0) {
                    const batch = writeBatch(db);
                    let startX = parentNodeKonva.x(); let startY = parentNodeKonva.y();
                    const parentShape = parentNodeKonva.findOne('.nodeShape');
                    const parentWidth = parentShape?.width() || (parentShape?.radiusX && parentShape.radiusX() * 2) || DEFAULT_NODE_STYLE.width;
                    const parentHeight = parentShape?.height() || (parentShape?.radiusY && parentShape.radiusY() * 2) || DEFAULT_NODE_STYLE.minHeight;
                    startX += parentWidth / 4; startY += parentHeight + 30;
                    const yOffsetIncrement = (DEFAULT_NODE_STYLE.minHeight || 50) + 20;
                    suggestions.slice(0, 5).forEach((suggestion, index) => {
                        const newNodeId = doc(collection(db, "nodes")).id;
                        const { height: newGeneratedNodeHeight } = calculateNodeHeight(suggestion, { ...DEFAULT_NODE_STYLE, width: 130, fontSize: 13, padding: 10 });
                        const newNodeData = {
                            mapId: currentMindMapId, parentId: parentNodeId, text: suggestion,
                            position: { x: startX, y: startY + (index * yOffsetIncrement) },
                            style: { ...DEFAULT_NODE_STYLE, backgroundColor: "#E3F2FD", textColor: "#0D47A1", borderColor: "#90CAF9", shape: "roundedRectangle", cornerRadius: 8, width: 130, minHeight: 40, fontSize: 13, height: newGeneratedNodeHeight },
                            createdAt: serverTimestamp()
                        };
                        const nodeRef = doc(db, "nodes", newNodeId); batch.set(nodeRef, newNodeData);
                    });
                    await batch.commit();
                } else { alert("AI không thể đưa ra gợi ý nào phù hợp vào lúc này."); }
            } catch (error) {
                console.error("Error calling Gemini API (suggestChildNodesWithAI):", error);
                let userMessage = "Lỗi khi AI gợi ý nút con: " + error.message;
                if (error.message && error.message.includes("API key not valid")) { userMessage += "\nVui lòng kiểm tra lại thiết lập API Key trong Firebase Console cho Gemini API."; }
                else if (error.message && (error.message.includes("429") || error.message.toLowerCase().includes("quota")) ) { userMessage = "Bạn đã gửi quá nhiều yêu cầu tới AI hoặc đã hết hạn ngạch. Vui lòng thử lại sau ít phút."; }
                else if (error.message && error.message.toLowerCase().includes("billing")){ userMessage = "Có vấn đề với cài đặt thanh toán cho dự án Firebase của bạn. Vui lòng kiểm tra trong Google Cloud Console."; }
                else if (error.message && error.message.toLowerCase().includes("model not found")){ userMessage = "Model AI không được tìm thấy. Vui lòng kiểm tra lại tên model đã cấu hình.";}
                alert(userMessage);
            } finally { hideLoadingIndicator(); }
        }

        // --- AI LOGIC FOR EXPANDING NODE TEXT --- (TÍNH NĂNG MỚI)
        async function expandNodeWithAI(targetNodeKonva) {
            if (!generativeModel || !targetNodeKonva || !currentMindMapId || !currentUser || !db) {
                alert("Chức năng AI chưa sẵn sàng hoặc thiếu thông tin cần thiết.");
                if(contextMenu) hideElement(contextMenu);
                return;
            }

            const targetNodeId = targetNodeKonva.id();
            const targetNodeData = allNodesDataForCurrentMap.find(n => n.id === targetNodeId);

            if (!targetNodeData) {
                alert("Không tìm thấy dữ liệu cho nút đã chọn để mở rộng.");
                if(contextMenu) hideElement(contextMenu);
                return;
            }

            const currentText = targetNodeData.text;
            const prompt = `Với ý tưởng chính là "${currentText}", hãy viết một đoạn văn bản chi tiết hơn (khoảng 3-5 câu) để giải thích, làm rõ hoặc mở rộng ý tưởng này. Giữ văn phong mạch lạc và tập trung vào chủ đề.`;

            showLoadingIndicator("AI đang mở rộng ý tưởng...");
            if(contextMenu) hideElement(contextMenu);

            try {
                const result = await generativeModel.generateContent(prompt);
                const response = result.response;
                const expandedText = response.text().trim();

                if (expandedText && expandedText !== currentText) {
                    const nodeRef = doc(db, "nodes", targetNodeId);
                    const existingStyle = targetNodeData.style || {};

                    // Tính toán chiều cao mới dựa trên văn bản mở rộng và style hiện tại
                    const { height: newCalculatedHeight } = calculateNodeHeight(expandedText, existingStyle);

                    const updatedStyle = { ...existingStyle, height: newCalculatedHeight };

                    await updateDoc(nodeRef, {
                        text: expandedText,
                        style: updatedStyle
                    });
                    // console.log(`Node ${targetNodeId} expanded by AI.`);
                } else if (expandedText === currentText) {
                    alert("AI không tìm thấy cách mở rộng thêm cho ý tưởng này.");
                } else {
                    alert("AI không thể mở rộng ý tưởng vào lúc này.");
                }

            } catch (error) {
                console.error("Error calling Gemini API (expandNodeWithAI):", error);
                let userMessage = "Lỗi khi AI mở rộng ý tưởng: " + error.message;
                 if (error.message && error.message.includes("API key not valid")) { userMessage += "\nVui lòng kiểm tra lại thiết lập API Key trong Firebase Console cho Gemini API."; }
                else if (error.message && (error.message.includes("429") || error.message.toLowerCase().includes("quota")) ) { userMessage = "Bạn đã gửi quá nhiều yêu cầu tới AI hoặc đã hết hạn ngạch. Vui lòng thử lại sau ít phút."; }
                else if (error.message && error.message.toLowerCase().includes("billing")){ userMessage = "Có vấn đề với cài đặt thanh toán cho dự án Firebase của bạn. Vui lòng kiểm tra trong Google Cloud Console."; }
                else if (error.message && error.message.toLowerCase().includes("model not found")){ userMessage = "Model AI không được tìm thấy. Vui lòng kiểm tra lại tên model đã cấu hình.";}
                alert(userMessage);
            } finally {
                hideLoadingIndicator();
            }
        }


        // --- CONTEXT MENU ACTIONS ---
        if (ctxAddChildButton) { /* ... giữ nguyên ... */ }
        if (ctxEditTextButton) { /* ... giữ nguyên ... */ }
        if (ctxSuggestChildrenButton) {
            ctxSuggestChildrenButton.addEventListener('click', async () => {
                let targetNodeForAI = rightClickedKonvaNode || selectedKonvaNode;
                if (targetNodeForAI) { await suggestChildNodesWithAI(targetNodeForAI); }
                else { alert("Vui lòng chọn một nút cha để AI gợi ý nút con."); if(contextMenu) hideElement(contextMenu); }
            });
        }
        // Gắn sự kiện cho nút "Mở rộng ý tưởng (AI)"
        if (ctxExpandNodeButton) {
            ctxExpandNodeButton.addEventListener('click', async () => {
                let targetNodeForAI = rightClickedKonvaNode || selectedKonvaNode;
                if (targetNodeForAI) {
                    await expandNodeWithAI(targetNodeForAI);
                } else {
                    alert("Vui lòng chọn một nút để AI mở rộng ý tưởng.");
                    if(contextMenu) hideElement(contextMenu);
                }
            });
        }
        if (ctxDeleteNodeButton) { /* ... giữ nguyên ... */ }
        document.addEventListener('click', function (e) { /* ... giữ nguyên ... */ });


        // --- TOOLBAR BUTTON ACTIONS --- (Giữ nguyên)
        async function addChildNodeLogic(parentNode) { /* ... giữ nguyên ... */ }
        function findAllDescendantNodeIds(parentNodeId, allNodes) { /* ... giữ nguyên ... */ }
        async function deleteNodeLogic(nodeToDelete) { /* ... giữ nguyên ... */ }
        if (addChildNodeButton) { /* ... giữ nguyên ... */ }
        if (deleteNodeButton) { /* ... giữ nguyên ... */ }

        // --- KEYBOARD SHORTCUTS --- (Giữ nguyên)
        const KEYBOARD_MOVE_STEP = 10;
        function handleGlobalKeyDown(e) { /* ... giữ nguyên ... */ }

        // --- ZOOM CONTROLS --- (Giữ nguyên)
        const scaleBy = 1.1;
        if(zoomInButton) { /* ... giữ nguyên ... */ }
        if(zoomOutButton) { /* ... giữ nguyên ... */ }
        if(resetZoomButton) { /* ... giữ nguyên ... */ }

        window.addEventListener('resize', () => { /* ... giữ nguyên ... */ });

    </script>
</body>
</html>
